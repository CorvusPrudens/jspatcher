{"version":3,"file":"src_core_audio_AudioEditor_ts-src_core_audio_AudioRecorder_ts-src_core_audio_PatcherAudio_ts.js/77d8e597c4d4d7cba765.worklet.js","mappings":"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ACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU,wBAAwB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAUE;AACF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,sBAAsB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gBAAgB;AAC5B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,UAAU;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,aAAa;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,OAAO;AAC7B;AACA,cAAc;AACd,sBAAsB,OAAO;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,eAAe,iBAAiB,2BAA2B;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B,qBAAqB;AACrB,YAAY;AACZ,2BAA2B;AAC3B,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,6BAA6B,IAAI,mDAAmD,EAAE;AACzG,qDAAqD,yBAAyB;AAC9E;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,GAAG;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,OAAO,EAAE,WAAW;AACtC,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,eAAe;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,KAAK;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,KAAK;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,QAAQ;AAClC;AACA;AACA,0BAA0B,QAAQ;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,eAAe;AACrD;AACA;AACA;AACA,YAAY;AACZ,sCAAsC,eAAe;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,yBAAyB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gBAAgB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,YAAY,+BAA+B;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,eAAe;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,kBAAkB,2BAA2B;AAC7C;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA;AACA,UAAU;AACV;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA,YAAY;AACZ,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA,UAAU;AACV;AACA,oBAAoB,QAAQ;AAC5B,oCAAoC,WAAW;AAC/C;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,oBAAoB,wBAAwB;AAC5C;AACA;AACA;AACA,UAAU;AACV;AACA,oBAAoB,wBAAwB;AAC5C;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,YAAY;AACZ,oBAAoB,2CAA2C;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,wBAAwB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,0BAA0B;AACxC;AACA;AACA;AACA,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,cAAc;AAClD;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,mEAAmE;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,8CAA8C;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,aAAa;AAC3C,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,aAAa;AAC3C,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,aAAa;AAC7C;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA,4BAA4B,eAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,aAAa;AAC3C,KAAK;AACL;AACA;AACA,YAAY,OAAO;AACnB,YAAY,4BAA4B;AACxC;AACA,cAAc,cAAc;AAC5B;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,cAAc,8BAA8B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT,OAAO;AACP,MAAM;AACN;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA,uEAAuE,6BAA6B;AACpG;AACA;AACA;AACA;AACA;AAgBE;AACF","sources":["webpack://JSPatcher/./src/core/audio/AudioEditor.ts","webpack://JSPatcher/./src/core/audio/AudioHistory.ts","webpack://JSPatcher/./src/core/audio/AudioPlayer.ts","webpack://JSPatcher/./src/core/audio/AudioRecorder.ts","webpack://JSPatcher/./src/core/audio/OperableAudioBuffer.ts","webpack://JSPatcher/./src/core/audio/PatcherAudio.ts","webpack://JSPatcher/./src/core/worklets/AudioWorkletProxyNode.ts","webpack://JSPatcher/./src/core/worklets/AudioWorkletRegister.ts","webpack://JSPatcher/./src/core/worklets/TemporalAnalyser.ts","webpack://JSPatcher/./src/core/worklets/Transmitter.ts","webpack://JSPatcher/./src/utils/Waveform.ts","webpack://JSPatcher/./src/core/worklets/TemporalAnalyser.worklet.ts","webpack://JSPatcher/./src/core/worklets/Transmitter.worklet.ts","webpack://JSPatcher/./node_modules/@webaudiomodules/api/dist/index.js","webpack://JSPatcher/./node_modules/@webaudiomodules/sdk/dist/index.js"],"sourcesContent":["import type { SemanticICONS } from \"semantic-ui-react\";\nimport type { WebAudioModule } from \"@webaudiomodules/api\";\nimport { dbtoa } from \"../../utils/math\";\nimport AudioPlayer from \"./AudioPlayer\";\nimport AudioRecorder from \"./AudioRecorder\";\nimport FileEditor from \"../file/FileEditor\";\nimport TempAudioFile from \"./TempAudioFile\";\nimport type PatcherAudio from \"./PatcherAudio\";\nimport type { TAudioPlayingState } from \"../types\";\nimport type PersistentProjectFile from \"../file/PersistentProjectFile\";\nimport type Env from \"../Env\";\nimport type { IJSPatcherEnv } from \"../Env\";\nimport type { IProject } from \"../Project\";\n\nexport interface AudioEditorEventMap {\n    \"pasted\": { range?: [number, number]; cursor?: number; audio: PatcherAudio; oldAudio?: PatcherAudio };\n    \"cutEnd\": { range: [number, number]; oldAudio: PatcherAudio };\n    \"deleted\": { range: [number, number]; oldAudio: PatcherAudio };\n    \"silenced\": { range: [number, number]; audio: PatcherAudio; oldAudio: PatcherAudio };\n    \"insertedSilence\": { range: [number, number]; audio: PatcherAudio };\n    \"inversed\": { range: [number, number]; audio: PatcherAudio; oldAudio: PatcherAudio };\n    \"reversed\": { range: [number, number]; audio: PatcherAudio; oldAudio: PatcherAudio };\n    \"faded\": { gain: number; range: [number, number]; audio: PatcherAudio; oldAudio: PatcherAudio };\n    \"fadedIn\": { length: number; exponent: number; audio: PatcherAudio; oldAudio: PatcherAudio };\n    \"fadedOut\": { length: number; exponent: number; audio: PatcherAudio; oldAudio: PatcherAudio };\n    \"recorded\": { range?: [number, number]; cursor?: number; audio: PatcherAudio; oldAudio: PatcherAudio };\n    \"resampled\": { audio: PatcherAudio; oldAudio: PatcherAudio };\n    \"remixed\": { audio: PatcherAudio; oldAudio: PatcherAudio };\n    \"viewRange\": [number, number];\n    \"selRange\": [number, number];\n    \"selRangeToPlay\": [number, number] | null;\n    \"cursor\": number;\n    \"enabledChannels\": boolean[];\n    \"playing\": TAudioPlayingState;\n    \"monitoring\": boolean;\n    \"loop\": boolean;\n    \"recording\": boolean;\n    \"pluginsChanged\": { plugins: WebAudioModule[]; pluginsEnabled: boolean[]; pluginsShowing: boolean[] };\n    \"pluginsApplied\": { range?: [number, number]; audio: PatcherAudio; oldAudio: PatcherAudio };\n    \"uiResized\": never;\n    \"setAudio\": never;\n    \"ready\": never;\n}\n\nexport interface AudioHistoryEventMap extends Pick<AudioEditorEventMap, \"faded\" | \"fadedIn\" | \"fadedOut\" | \"cutEnd\" | \"pasted\" | \"deleted\" | \"silenced\" | \"insertedSilence\" | \"reversed\" | \"inversed\" | \"resampled\" | \"remixed\" | \"recorded\" | \"pluginsApplied\"> {}\n\nexport interface AudioEditorState {\n    playing: TAudioPlayingState;\n    monitoring: boolean;\n    recording: boolean;\n    loop: boolean;\n    cursor: number;\n    selRange: [number, number];\n    viewRange: [number, number];\n    enabledChannels: boolean[];\n    plugins: WebAudioModule[];\n    pluginsEnabled: WeakSet<WebAudioModule>;\n    pluginsShowing: WeakSet<WebAudioModule>;\n    preFxGain: number;\n    postFxGain: number;\n}\n\nexport default class AudioEditor extends FileEditor<PatcherAudio, AudioEditorEventMap> {\n    static async fromProjectItem({ file, env, project, instanceId }: { file: PersistentProjectFile | TempAudioFile; env: IJSPatcherEnv; project?: IProject; instanceId?: string }) {\n        const audio = file instanceof TempAudioFile ? file.data : await file.instantiate({ env, project, instanceId }) as PatcherAudio;\n        const editor = new this(audio);\n        return editor.init();\n    }\n    readonly audio: PatcherAudio;\n    readonly player = new AudioPlayer(this);\n    readonly recorder = new AudioRecorder(this);\n    readonly state: AudioEditorState = {\n        playing: \"stopped\",\n        monitoring: false,\n        loop: true,\n        recording: false,\n        cursor: 0,\n        selRange: null,\n        viewRange: [0, 0],\n        enabledChannels: [],\n        plugins: new Array(10).fill(undefined),\n        pluginsEnabled: new WeakSet(),\n        pluginsShowing: new WeakSet(),\n        preFxGain: 0,\n        postFxGain: 0\n    };\n    get fileExtension() {\n        return \"wav\";\n    }\n    get fileIcon(): SemanticICONS {\n        return \"music\";\n    }\n    get clipboard() {\n        return (this.env as Env).audioClipboard;\n    }\n    set clipboard(audio: PatcherAudio) {\n        (this.env as Env).audioClipboard = audio;\n    }\n    get ctx() {\n        return this.instance.ctx;\n    }\n    get audioCtx() {\n        return this.instance.audioCtx;\n    }\n    get length() {\n        return this.instance.length;\n    }\n    get numberOfChannels() {\n        return this.instance.numberOfChannels;\n    }\n    get sampleRate() {\n        return this.instance.sampleRate;\n    }\n    get audioBuffer() {\n        return this.instance.audioBuffer;\n    }\n    get waveform() {\n        return this.instance.waveform;\n    }\n\n    handleSetAudio = () => {\n        const { cursor, selRange, viewRange } = this.state;\n        const { length, numberOfChannels } = this;\n        if (cursor > length) this.setCursor(length);\n        if (selRange && selRange[1] > length) this.setSelRange(selRange);\n        if (viewRange[1] > length) this.setViewRange(viewRange);\n        if (this.state.enabledChannels.length !== numberOfChannels) {\n            const enabledChannels = new Array(numberOfChannels).fill(true);\n            this.state.enabledChannels.slice(numberOfChannels).forEach((v, i) => enabledChannels[i] = v);\n            this.setState({ enabledChannels });\n            this.emit(\"enabledChannels\", enabledChannels);\n        }\n        this.emit(\"setAudio\");\n    };\n    handlePlayerEnded = (cursor: number) => {\n        const playing: TAudioPlayingState = \"stopped\";\n        this.setState({ playing });\n        this.emit(\"playing\", playing);\n        this.setCursor(cursor);\n    };\n    handleInputChanged = async (deviceId?: string) => {\n        await this.recorder.newSearch(deviceId);\n        if (this.state.monitoring) this.player.startMonitoring();\n    };\n    async init() {\n        if (!this.instance.isReady) {\n            await new Promise<void>((resolve, reject) => {\n                const handleReady = () => {\n                    resolve();\n                    this.instance.off(\"ready\", handleReady);\n                };\n                this.instance.on(\"ready\", handleReady);\n            });\n        }\n        this.setState({\n            viewRange: [0, this.length],\n            enabledChannels: new Array(this.numberOfChannels).fill(true)\n        });\n        this.instance.on(\"setAudio\", this.handleSetAudio);\n        this.on(\"changed\", () => this.instance.emit(\"changed\"));\n        await this.env.taskMgr.newTask(this, \"Initializing Audio Editor...\", async () => {\n            await this.player.init();\n            await this.recorder.init();\n        });\n        this._isReady = true;\n        this.emit(\"ready\");\n        return this;\n    }\n    setState(state: Partial<AudioEditorState>) {\n        Object.assign(this.state, state);\n    }\n    onUiResized() {\n        this.emit(\"uiResized\");\n    }\n    get pluginsState() {\n        const { plugins, pluginsEnabled, pluginsShowing, preFxGain, postFxGain } = this.state;\n        return {\n            plugins: plugins.slice(),\n            pluginsEnabled: plugins.map(p => pluginsEnabled.has(p)),\n            pluginsShowing: plugins.map(p => pluginsShowing.has(p)),\n            preFxGain,\n            postFxGain\n        };\n    }\n    emitPluginsChanged() {\n        this.emit(\"pluginsChanged\", this.pluginsState);\n    }\n    emitUIResized() {\n        this.emit(\"uiResized\");\n    }\n    emitSelRangeToPlay() {\n        this.emit(\"selRangeToPlay\", this.state.selRange);\n    }\n    zoomH(refIn: number, factor: number) { // factor = 1 as zoomIn, -1 as zoomOut\n        const { viewRange } = this.state;\n        const { length } = this;\n        const [viewStart, viewEnd] = viewRange;\n        const viewLength = viewEnd - viewStart;\n        const minRange = Math.min(length, 5);\n        const ref = Math.max(0, Math.min(length, Math.round(refIn)));\n        if (ref < viewStart || ref > viewEnd) {\n            const start = Math.max(0, Math.min(length - viewLength, Math.round(ref - viewLength / 2)));\n            const end = Math.max(viewLength, Math.min(length, Math.round(ref + viewLength / 2)));\n            const range: [number, number] = [start, end];\n            this.setState({ viewRange: range });\n            this.emit(\"viewRange\", range);\n        } else if (factor < 0 || viewLength > minRange) {\n            const multiplier = 1.5 ** -factor;\n            const start = ref - (ref - viewStart) * multiplier;\n            const end = ref + (viewEnd - ref) * multiplier;\n            this.setViewRange([start, end]);\n        }\n    }\n    scrollH(speed: number) { // spped = 1 as one full viewRange\n        const { viewRange } = this.state;\n        const { length } = this;\n        const [viewStart, viewEnd] = viewRange;\n        const viewLength = viewEnd - viewStart;\n        const deltaSamples = viewLength * speed;\n        const start = Math.min(length - viewLength, viewStart + deltaSamples);\n        const end = Math.max(viewLength, viewEnd + deltaSamples);\n        this.setViewRange([start, end]);\n    }\n    setEnabledChannel(channel: number, enabled: boolean) {\n        const enabledChannels = this.state.enabledChannels.slice();\n        enabledChannels[channel] = enabled;\n        this.setState({ enabledChannels });\n        this.emit(\"enabledChannels\", enabledChannels);\n    }\n    setLoop(loop: boolean) {\n        this.setState({ loop });\n        this.emit(\"loop\", loop);\n    }\n    setRecording(recording: boolean) {\n        this.setState({ recording });\n        this.emit(\"recording\", recording);\n    }\n    setCursor(cursorIn: number, fromPlayer?: boolean) {\n        const shouldReplay = !fromPlayer && this.state.playing === \"playing\";\n        if (shouldReplay) this.stop();\n        const { length } = this;\n        const cursor = Math.max(0, Math.min(length, Math.round(cursorIn)));\n        this.setState({ cursor });\n        this.emit(\"cursor\", cursor);\n        if (shouldReplay) this.play();\n    }\n    setSelRange(range: [number, number]) {\n        if (!range) {\n            this.setState({ selRange: null });\n            this.emit(\"selRange\", null);\n            return;\n        }\n        const { length } = this;\n        let [start, end] = range;\n        if (end < start) [start, end] = [end, start];\n        start = Math.max(0, Math.min(length - 1, Math.round(start)));\n        end = Math.max(1, Math.min(length, Math.round(end)));\n        if (start === end) {\n            this.setState({ selRange: null });\n            this.emit(\"selRange\", null);\n            return;\n        }\n        const selRange: [number, number] = [start, end];\n        this.setState({ selRange, cursor: start });\n        this.emit(\"selRange\", selRange);\n        this.emit(\"cursor\", start);\n    }\n    setSelRangeToAll() {\n        const { length } = this;\n        const selRange: [number, number] = [0, length];\n        this.setState({ selRange });\n        this.emit(\"selRange\", selRange);\n        this.emitSelRangeToPlay();\n    }\n    async selectAll() {\n        this.setSelRangeToAll();\n    }\n    async deleteSelected() {\n        this.delete();\n    }\n    setViewRange(range: [number, number]) {\n        const { length } = this;\n        let [start, end] = range;\n        if (end < start) [start, end] = [end, start];\n        const minRange = Math.min(length, 5);\n        start = Math.max(0, Math.min(length - minRange, Math.round(start)));\n        end = Math.max(minRange, Math.min(length, Math.round(end)));\n        const viewRange: [number, number] = [start, end];\n        this.setState({ viewRange });\n        this.emit(\"viewRange\", viewRange);\n    }\n    setViewRangeToAll() {\n        const { length } = this;\n        const viewRange: [number, number] = [0, length];\n        this.setState({ viewRange });\n        this.emit(\"viewRange\", viewRange);\n    }\n\n    async cut() {\n        const { selRange } = this.state;\n        if (!selRange) return;\n        const [selStart, selEnd] = selRange;\n        this.setSelRange(null);\n        this.clipboard = await this.instance.removeFromRange(selStart, selEnd);\n        const oldAudio = this.clipboard;\n        this.emit(\"cutEnd\", { range: [selStart, selEnd], oldAudio });\n    }\n    async copy() {\n        const { selRange } = this.state;\n        if (!selRange) return;\n        const [selStart, selEnd] = selRange;\n        this.clipboard = await this.instance.pick(selStart, selEnd, true);\n    }\n    async paste() {\n        const { clipboard } = this;\n        if (!clipboard) return;\n        const { cursor, selRange } = this.state;\n        if (selRange) {\n            const [selStart, selEnd] = selRange;\n            const oldAudio = await this.instance.pasteToRange(clipboard, selStart, selEnd);\n            this.emit(\"pasted\", { range: [selStart, selEnd], audio: clipboard, oldAudio });\n        } else {\n            this.instance.insertToCursor(clipboard, cursor);\n            this.emit(\"pasted\", { cursor, audio: clipboard });\n        }\n    }\n    async delete() {\n        const { selRange } = this.state;\n        if (!selRange) return;\n        const [selStart, selEnd] = selRange;\n        this.setSelRange(null);\n        const oldAudio = await this.instance.removeFromRange(selStart, selEnd);\n        this.emit(\"deleted\", { range: [selStart, selEnd], oldAudio });\n    }\n    async silence() {\n        const { selRange } = this.state;\n        if (!selRange) return;\n        const silenced = await this.instance.silence(...selRange);\n        if (silenced) this.emit(\"silenced\", silenced);\n    }\n    async insertSilence(length: number) {\n        if (!length) return;\n        const { cursor } = this.state;\n        const inserted = await this.instance.insertSilence(length, cursor);\n        if (inserted) this.emit(\"insertedSilence\", inserted);\n    }\n    async reverse() {\n        const { selRange } = this.state;\n        const [selStart, selEnd] = selRange || [0, this.length];\n        const audio = await this.instance.pick(selStart, selEnd, true);\n        audio.reverse();\n        const oldAudio = await this.instance.pasteToRange(audio, selStart, selEnd);\n        this.emit(\"reversed\", { range: [0, this.length], audio, oldAudio });\n    }\n    async inverse() {\n        const { selRange } = this.state;\n        const [selStart, selEnd] = selRange || [0, this.length];\n        const audio = await this.instance.pick(selStart, selEnd, true);\n        audio.inverse();\n        const oldAudio = await this.instance.pasteToRange(audio, selStart, selEnd);\n        this.emit(\"inversed\", { range: [selStart, selEnd], audio, oldAudio });\n    }\n    async fade(gain: number) {\n        const { selRange, enabledChannels } = this.state;\n        if (!selRange) return;\n        const faded = await this.instance.fade(gain, ...selRange, enabledChannels);\n        if (faded) this.emit(\"faded\", faded);\n    }\n    async fadeIn(length: number, exponent: number) {\n        const { enabledChannels } = this.state;\n        const faded = await this.instance.fadeIn(length, exponent, enabledChannels);\n        if (faded) this.emit(\"fadedIn\", faded);\n    }\n    async fadeOut(length: number, exponent: number) {\n        const { enabledChannels } = this.state;\n        const faded = await this.instance.fadeOut(length, exponent, enabledChannels);\n        if (faded) this.emit(\"fadedOut\", faded);\n    }\n    async resample(to: number) {\n        if (to <= 0) return;\n        const oldAudio = await this.instance.clone();\n        if (oldAudio.sampleRate === to) return;\n        const audio = await this.instance.render(to);\n        this.instance.setAudio(audio);\n        this.emit(\"resampled\", { audio, oldAudio });\n    }\n    async remixChannels(mix: number[][]) {\n        const oldAudio = await this.instance.clone();\n        const audio = await this.instance.render(undefined, mix);\n        this.instance.setAudio(audio);\n        this.emit(\"remixed\", { audio, oldAudio });\n    }\n    async applyPlugins(selected?: boolean) {\n        const { selRange, plugins, pluginsEnabled, preFxGain, postFxGain } = this.state;\n        if (plugins.every(p => !p || !pluginsEnabled.has(p))) return;\n        if (selected && !selRange) return;\n        const oldAudio = selected ? await this.instance.pick(...selRange) : await this.instance.clone();\n        const audio = await oldAudio.render(undefined, undefined, true, { plugins, pluginsEnabled, preFxGain, postFxGain });\n        if (selected) await this.instance.pasteToRange(audio, ...selRange);\n        else this.instance.setAudio(audio);\n        plugins.forEach((p, i) => {\n            if (!p) return;\n            this.setPluginEnabled(i, false);\n        });\n        this.emit(\"pluginsApplied\", { ...(selected ? { range: selRange } : {}), audio, oldAudio });\n    }\n\n    play() {\n        const playing: TAudioPlayingState = \"playing\";\n        this.setState({ playing });\n        this.emit(\"playing\", playing);\n        this.player.play();\n    }\n    pause() {\n        const playing: TAudioPlayingState = \"paused\";\n        this.setState({ playing });\n        this.emit(\"playing\", playing);\n        this.player.stop();\n    }\n    resume() {\n        const playing: TAudioPlayingState = \"playing\";\n        this.setState({ playing });\n        this.emit(\"playing\", playing);\n        this.player.play();\n    }\n    stop() {\n        const playing: TAudioPlayingState = \"stopped\";\n        this.setState({ playing });\n        this.emit(\"playing\", playing);\n        this.player.stop();\n    }\n    startMonitoring() {\n        const monitoring = true;\n        this.setState({ monitoring });\n        this.emit(\"monitoring\", monitoring);\n        this.player.startMonitoring();\n    }\n    stopMonitoring() {\n        const monitoring = false;\n        this.setState({ monitoring });\n        this.emit(\"monitoring\", monitoring);\n        this.player.stopMonitoring();\n    }\n    async startRecord() {\n        this.stop();\n        const started = await this.recorder.start();\n        if (!started) return;\n        this.setState({ recording: true });\n        this.emit(\"recording\", true);\n    }\n    async stopRecord() {\n        await this.recorder.stop();\n        this.setState({ recording: false });\n        this.emit(\"recording\", false);\n    }\n    async addPlugin(url: string, index: number) {\n        return this.env.taskMgr.newTask(this, \"Adding Plugin...\", () => this.player.addPlugin(url, index));\n    }\n    removePlugin(index: number) {\n        this.player.removePlugin(index);\n    }\n    movePlugin(fromIndex: number, toIndex: number) {\n        this.player.movePlugin(fromIndex, toIndex);\n    }\n    setPluginEnabled(index: number, enabled: boolean) {\n        this.player.setPluginEnabled(index, enabled);\n    }\n    setPluginShowing(index: number, showing: boolean) {\n        const { plugins, pluginsShowing } = this.state;\n        const plugin = plugins[index];\n        if (!plugin) return;\n        if (showing) pluginsShowing.add(plugin);\n        else pluginsShowing.delete(plugin);\n        this.emitPluginsChanged();\n    }\n    setPreFxGain(gain: number) {\n        this.state.preFxGain = gain;\n        const { playing, monitoring } = this.state;\n        if (monitoring || playing === \"playing\") this.player.preFxGainNode.gain.setTargetAtTime(dbtoa(gain), (this.env as Env).audioCtx.currentTime, 0.01);\n    }\n    setPostFxGain(gain: number) {\n        this.state.postFxGain = gain;\n        const { playing, monitoring } = this.state;\n        if (monitoring || playing === \"playing\") this.player.postFxGainNode.gain.setTargetAtTime(dbtoa(gain), (this.env as Env).audioCtx.currentTime, 0.01);\n    }\n\n    async destroy() {\n        this._isReady = false;\n        this.instance.off(\"setAudio\", this.handleSetAudio);\n        if (this.state.recording) await this.stopRecord();\n        if (this.state.playing !== \"stopped\") this.stop();\n        for (let i = 0; i < this.state.plugins.length; i++) {\n            this.removePlugin(i);\n        }\n        await this.recorder.destroy();\n        await this.player.destroy();\n        await super.destroy();\n    }\n}\n","import History from \"../file/History\";\nimport AudioEditor, { AudioHistoryEventMap } from \"./AudioEditor\";\n\nexport default class AudioHistory extends History<AudioHistoryEventMap, AudioEditor> {\n    get eventListening(): (keyof AudioHistoryEventMap)[] {\n        return [\"faded\", \"fadedIn\", \"fadedOut\", \"cutEnd\", \"pasted\", \"deleted\", \"silenced\", \"insertedSilence\", \"reversed\", \"inversed\", \"resampled\", \"remixed\", \"recorded\", \"pluginsApplied\"];\n    }\n    async undoOf(editor: AudioEditor, eventName: keyof AudioHistoryEventMap, eventData?: any) {\n        if (eventName === \"faded\") {\n            const e: AudioHistoryEventMap[typeof eventName] = eventData;\n            const { range: [selStart, selEnd], oldAudio } = e;\n            await editor.instance.pasteToRange(oldAudio, selStart, selEnd);\n        } else if (eventName === \"fadedIn\") {\n            const e: AudioHistoryEventMap[typeof eventName] = eventData;\n            const { length, oldAudio } = e;\n            await editor.instance.pasteToRange(oldAudio, 0, length);\n        } else if (eventName === \"fadedOut\") {\n            const e: AudioHistoryEventMap[typeof eventName] = eventData;\n            const { length, oldAudio } = e;\n            const l = editor.instance.audioBuffer.length;\n            await editor.instance.pasteToRange(oldAudio, l - length, l);\n        } else if (eventName === \"cutEnd\") {\n            const e: AudioHistoryEventMap[typeof eventName] = eventData;\n            const { range: [cursor], oldAudio } = e;\n            await editor.instance.insertToCursor(oldAudio, cursor);\n        } else if (eventName === \"pasted\") {\n            const e: AudioHistoryEventMap[typeof eventName] = eventData;\n            const { range, cursor, audio, oldAudio } = e;\n            if (range) {\n                await editor.instance.pasteToRange(oldAudio, range[0], range[0] + audio.length);\n            } else {\n                await editor.instance.removeFromRange(cursor, cursor + audio.length);\n            }\n        } else if (eventName === \"deleted\") {\n            const e: AudioHistoryEventMap[typeof eventName] = eventData;\n            const { range: [cursor], oldAudio } = e;\n            await editor.instance.insertToCursor(oldAudio, cursor);\n        } else if (eventName === \"silenced\") {\n            const e: AudioHistoryEventMap[typeof eventName] = eventData;\n            const { range: [from, to], oldAudio } = e;\n            await editor.instance.pasteToRange(oldAudio, from, to);\n        } else if (eventName === \"insertedSilence\") {\n            const e: AudioHistoryEventMap[typeof eventName] = eventData;\n            const { range: [from, to] } = e;\n            await editor.instance.removeFromRange(from, to);\n        } else if (eventName === \"reversed\") {\n            const e: AudioHistoryEventMap[typeof eventName] = eventData;\n            const { range: [from, to], oldAudio } = e;\n            await editor.instance.pasteToRange(oldAudio, from, to);\n        } else if (eventName === \"inversed\") {\n            const e: AudioHistoryEventMap[typeof eventName] = eventData;\n            const { range: [from, to], oldAudio } = e;\n            await editor.instance.pasteToRange(oldAudio, from, to);\n        } else if (eventName === \"resampled\") {\n            const e: AudioHistoryEventMap[typeof eventName] = eventData;\n            const { oldAudio } = e;\n            editor.instance.setAudio(oldAudio);\n        } else if (eventName === \"remixed\") {\n            const e: AudioHistoryEventMap[typeof eventName] = eventData;\n            const { oldAudio } = e;\n            editor.instance.setAudio(oldAudio);\n        } else if (eventName === \"recorded\") {\n            const e: AudioHistoryEventMap[typeof eventName] = eventData;\n            const { range, cursor, audio, oldAudio } = e;\n            if (range) {\n                await editor.instance.pasteToRange(oldAudio, range[0], range[0] + audio.length);\n            } else {\n                await editor.instance.removeFromRange(cursor, cursor + audio.length);\n            }\n        } else if (eventName === \"pluginsApplied\") {\n            const e: AudioHistoryEventMap[typeof eventName] = eventData;\n            const { range, audio, oldAudio } = e;\n            if (range) {\n                await editor.instance.pasteToRange(oldAudio, range[0], range[0] + audio.length);\n            } else {\n                editor.instance.setAudio(oldAudio);\n            }\n        }\n    }\n    async redoOf(editor: AudioEditor, eventName: keyof AudioHistoryEventMap, eventData?: any) {\n        if (eventName === \"faded\") {\n            const e: AudioHistoryEventMap[typeof eventName] = eventData;\n            const { range: [selStart, selEnd], audio } = e;\n            await editor.instance.pasteToRange(audio, selStart, selEnd);\n        } else if (eventName === \"fadedIn\") {\n            const e: AudioHistoryEventMap[typeof eventName] = eventData;\n            const { length, audio } = e;\n            await editor.instance.pasteToRange(audio, 0, length);\n        } else if (eventName === \"fadedOut\") {\n            const e: AudioHistoryEventMap[typeof eventName] = eventData;\n            const { length, audio } = e;\n            const l = audio.length;\n            await editor.instance.pasteToRange(audio, l - length, l);\n        } else if (eventName === \"cutEnd\") {\n            const e: AudioHistoryEventMap[typeof eventName] = eventData;\n            const { range: [selStart, selEnd] } = e;\n            await editor.instance.removeFromRange(selStart, selEnd);\n        } else if (eventName === \"pasted\") {\n            const e: AudioHistoryEventMap[typeof eventName] = eventData;\n            const { range, cursor, audio, oldAudio } = e;\n            if (range) {\n                await editor.instance.pasteToRange(audio, range[0], range[0] + oldAudio.length);\n            } else {\n                await editor.instance.insertToCursor(audio, cursor);\n            }\n        } else if (eventName === \"deleted\") {\n            const e: AudioHistoryEventMap[typeof eventName] = eventData;\n            const { range: [selStart, selEnd] } = e;\n            await editor.instance.removeFromRange(selStart, selEnd);\n        } else if (eventName === \"silenced\") {\n            const e: AudioHistoryEventMap[typeof eventName] = eventData;\n            const { range: [from, to], audio } = e;\n            await editor.instance.pasteToRange(audio, from, to);\n        } else if (eventName === \"insertedSilence\") {\n            const e: AudioHistoryEventMap[typeof eventName] = eventData;\n            const { range: [cursor], audio } = e;\n            await editor.instance.insertToCursor(audio, cursor);\n        } else if (eventName === \"reversed\") {\n            const e: AudioHistoryEventMap[typeof eventName] = eventData;\n            const { range: [from, to], audio } = e;\n            await editor.instance.pasteToRange(audio, from, to);\n        } else if (eventName === \"inversed\") {\n            const e: AudioHistoryEventMap[typeof eventName] = eventData;\n            const { range: [from, to], audio } = e;\n            await editor.instance.pasteToRange(audio, from, to);\n        } else if (eventName === \"resampled\") {\n            const e: AudioHistoryEventMap[typeof eventName] = eventData;\n            const { audio } = e;\n            editor.instance.setAudio(audio);\n        } else if (eventName === \"remixed\") {\n            const e: AudioHistoryEventMap[typeof eventName] = eventData;\n            const { audio } = e;\n            editor.instance.setAudio(audio);\n        } else if (eventName === \"recorded\") {\n            const e: AudioHistoryEventMap[typeof eventName] = eventData;\n            const { range, cursor, audio, oldAudio } = e;\n            if (range) {\n                await editor.instance.pasteToRange(audio, range[0], range[0] + oldAudio.length);\n            } else {\n                await editor.instance.insertToCursor(audio, cursor);\n            }\n        } else if (eventName === \"pluginsApplied\") {\n            const e: AudioHistoryEventMap[typeof eventName] = eventData;\n            const { range, audio, oldAudio } = e;\n            if (range) {\n                await editor.instance.pasteToRange(audio, range[0], range[0] + oldAudio.length);\n            } else {\n                editor.instance.setAudio(audio);\n            }\n        }\n    }\n}\n","import { WebAudioModule } from \"@webaudiomodules/api\";\nimport TemporalAnalyserNode from \"../worklets/TemporalAnalyser\";\nimport { dbtoa } from \"../../utils/math\";\nimport AudioEditor from \"./AudioEditor\";\n\nexport default class AudioPlayer {\n    readonly editor: AudioEditor;\n    readonly dummyAnalyserNode: AnalyserNode;\n    readonly preFxGainNode: GainNode;\n    readonly postFxGainNode: GainNode;\n    playing: boolean;\n    currentSample: number;\n    currentTime: number;\n    currentChannels: boolean[];\n    bufferSourceNode: AudioBufferSourceNode;\n    splitterNode: ChannelSplitterNode;\n    mergerNode: ChannelMergerNode;\n    postAnalyserNode: TemporalAnalyserNode;\n    monitoring: boolean;\n    mediaStreamSourceNode: MediaStreamAudioSourceNode;\n    offset: number;\n    duration: number;\n    get audioCtx() {\n        return this.editor.audioCtx;\n    }\n    get destination() {\n        return this.audioCtx.destination;\n    }\n    get loop() {\n        return this.bufferSourceNode?.loop;\n    }\n    handleLoopChanged = (loopIn: boolean) => {\n        const { bufferSourceNode, editor } = this;\n        if (!bufferSourceNode) return;\n        const { buffer, loop } = bufferSourceNode;\n        if (loop === loopIn) return;\n        const { sampleRate } = buffer;\n        const selRange = editor.state.selRange;\n        bufferSourceNode.loop = loopIn;\n        if (loopIn) {\n            if (selRange) {\n                bufferSourceNode.loopStart = selRange[0] / sampleRate;\n                bufferSourceNode.loopEnd = selRange[1] / sampleRate;\n            } else {\n                bufferSourceNode.loopStart = 0;\n                bufferSourceNode.loopEnd = 0;\n            }\n            bufferSourceNode.stop(Number.MAX_VALUE);\n        } else {\n            bufferSourceNode.loopStart = 0;\n            bufferSourceNode.loopEnd = 0;\n            if (selRange) bufferSourceNode.stop(this.currentTime + (selRange[1] - this.currentSample) / sampleRate);\n            else bufferSourceNode.stop(Number.MAX_VALUE);\n        }\n    };\n    handleSelRangeChanged = (selRange: [number, number]): void => {\n        const { bufferSourceNode } = this;\n        if (!bufferSourceNode) return;\n        const { buffer, loop } = bufferSourceNode;\n        const { sampleRate } = buffer;\n        if (loop) {\n            if (selRange) {\n                bufferSourceNode.loopStart = selRange[0] / sampleRate;\n                bufferSourceNode.loopEnd = selRange[1] / sampleRate;\n            } else {\n                bufferSourceNode.loopStart = 0;\n                bufferSourceNode.loopEnd = 0;\n            }\n        } else {\n            bufferSourceNode.loopStart = 0;\n            bufferSourceNode.loopEnd = 0;\n            if (selRange) bufferSourceNode.stop(this.currentTime + (selRange[1] - this.currentSample) / sampleRate);\n            else bufferSourceNode.stop(Number.MAX_VALUE);\n        }\n    };\n    handleEnded = () => {\n        const { bufferSourceNode } = this;\n        if (!bufferSourceNode) return;\n        this.editor.handlePlayerEnded(this.getCurrentSample());\n        this.bufferSourceNode.removeEventListener(\"ended\", this.handleEnded);\n        this.bufferSourceNode.disconnect();\n        this.splitterNode.disconnect();\n        this.mergerNode.disconnect();\n        delete this.bufferSourceNode;\n        delete this.splitterNode;\n        delete this.mergerNode;\n    };\n    handleEnabledChannelsChanged = (enabledChannels: boolean[]) => {\n        const { bufferSourceNode } = this;\n        if (!bufferSourceNode) return;\n        this.currentChannels.forEach((enabled, i) => {\n            if (enabledChannels[i] !== enabled) {\n                if (enabledChannels[i]) this.splitterNode.connect(this.mergerNode, i, i);\n                else this.splitterNode.disconnect(this.mergerNode, i, i);\n            }\n        });\n        this.currentChannels = enabledChannels.slice();\n    };\n\n    updateCursorScheduled = false;\n    $updateCursorRaf = -1;\n    updateCursorCallback = () => {\n        this.$updateCursorRaf = -1;\n        this.updateCursorScheduled = false;\n        this.updateCursor();\n    };\n    scheduleUpdateCursor = () => {\n        if (this.updateCursorScheduled) return;\n        if (this.$updateCursorRaf === -1) this.$updateCursorRaf = requestAnimationFrame(this.updateCursorCallback);\n        this.updateCursorScheduled = true;\n    };\n    updateCursor() {\n        if (!this.bufferSourceNode) return;\n        this.editor.setCursor(this.getCurrentSample(), true);\n        this.scheduleUpdateCursor();\n    }\n    constructor(editor: AudioEditor) {\n        this.editor = editor;\n        this.playing = false;\n        this.monitoring = false;\n        // this.destination.channelInterpretation = \"discrete\";\n        this.dummyAnalyserNode = this.audioCtx.createAnalyser();\n        this.preFxGainNode = this.audioCtx.createGain();\n        this.postFxGainNode = this.audioCtx.createGain();\n        this.postFxGainNode.connect(this.destination);\n        this.editor.on(\"loop\", this.handleLoopChanged);\n        this.editor.on(\"selRangeToPlay\", this.handleSelRangeChanged);\n        this.editor.on(\"enabledChannels\", this.handleEnabledChannelsChanged);\n    }\n    async init() {\n        const audioWorklet = this.audioCtx.audioWorklet;\n        await TemporalAnalyserNode.register(audioWorklet);\n        this.postAnalyserNode = new TemporalAnalyserNode(this.audioCtx);\n        this.postFxGainNode.connect(this.postAnalyserNode);\n    }\n    async destroy() {\n        if (this.monitoring) this.stopMonitoring();\n        if (this.playing) this.stop();\n        await this.postAnalyserNode.destroy();\n    }\n    getCurrentSample() {\n        const { buffer } = this.bufferSourceNode;\n        const delta = (this.audioCtx.currentTime - this.currentTime) * buffer.sampleRate;\n        const selRange = this.editor.state?.selRange || [0, buffer.length];\n        this.currentSample += delta;\n        this.currentTime = this.audioCtx.currentTime;\n        if (this.loop) {\n            if (this.currentSample > selRange[1]) this.currentSample = (this.currentSample - selRange[0]) % (selRange[1] - selRange[0]) + selRange[0];\n        } else {\n            if (this.currentSample > selRange[1]) this.currentSample = selRange[1];\n        }\n        return ~~this.currentSample;\n    }\n    play() {\n        this.stop();\n        const audio = this.editor;\n        const { cursor, selRange, enabledChannels, preFxGain, postFxGain, loop } = this.editor.state;\n        const { sampleRate, numberOfChannels, audioBuffer } = audio;\n        const offset = (selRange ? selRange[0] : cursor) / sampleRate;\n        const duration = selRange ? (selRange[1] - selRange[0]) / sampleRate : undefined;\n        const bufferSourceNode = this.audioCtx.createBufferSource();\n        bufferSourceNode.channelCountMode = \"explicit\";\n        bufferSourceNode.channelInterpretation = \"discrete\";\n        bufferSourceNode.channelCount = numberOfChannels;\n        this.currentTime = this.audioCtx.currentTime;\n        this.currentSample = selRange ? selRange[0] : cursor;\n        this.currentChannels = enabledChannels.slice();\n        this.bufferSourceNode = bufferSourceNode;\n        this.splitterNode = this.audioCtx.createChannelSplitter(numberOfChannels);\n        this.mergerNode = this.audioCtx.createChannelMerger(numberOfChannels);\n        this.mergerNode.channelInterpretation = \"discrete\";\n        this.preFxGainNode.gain.value = dbtoa(preFxGain);\n        this.postFxGainNode.gain.value = dbtoa(postFxGain);\n        bufferSourceNode.buffer = audioBuffer;\n        bufferSourceNode.connect(this.dummyAnalyserNode);\n        bufferSourceNode.connect(this.splitterNode);\n        enabledChannels.forEach((enabled, i) => {\n            if (enabled && i < numberOfChannels) this.splitterNode.connect(this.mergerNode, i, i);\n        });\n        this.mergerNode.connect(this.preFxGainNode);\n        if (!this.monitoring) this.connectPlugins();\n        bufferSourceNode.loop = !!loop;\n        bufferSourceNode.addEventListener(\"ended\", this.handleEnded);\n        if (loop) {\n            if (duration) {\n                bufferSourceNode.loopStart = offset;\n                bufferSourceNode.loopEnd = offset + duration;\n            }\n            bufferSourceNode.start(this.currentTime, offset);\n        } else {\n            bufferSourceNode.start(this.currentTime, offset);\n            if (duration) bufferSourceNode.stop(this.currentTime + duration);\n            else bufferSourceNode.stop(Number.MAX_VALUE);\n        }\n        this.playing = true;\n        this.scheduleUpdateCursor();\n    }\n    stop() {\n        if (!this.bufferSourceNode) return;\n        this.bufferSourceNode.stop();\n        this.bufferSourceNode.removeEventListener(\"ended\", this.handleEnded);\n        this.bufferSourceNode.disconnect();\n        this.splitterNode.disconnect();\n        this.mergerNode.disconnect();\n        if (!this.monitoring) this.disconnectPlugins();\n        delete this.bufferSourceNode;\n        delete this.splitterNode;\n        delete this.mergerNode;\n        this.playing = false;\n    }\n    startMonitoring() {\n        this.stopMonitoring();\n        const sourceNode = this.editor.recorder.node;\n        if (!sourceNode) return;\n        this.mediaStreamSourceNode = sourceNode;\n        if (!this.playing) this.connectPlugins();\n        this.mediaStreamSourceNode.connect(this.preFxGainNode);\n        this.monitoring = true;\n    }\n    stopMonitoring() {\n        if (!this.mediaStreamSourceNode) return;\n        this.mediaStreamSourceNode.disconnect(this.preFxGainNode);\n        if (!this.playing) this.disconnectPlugins();\n        delete this.mediaStreamSourceNode;\n        this.monitoring = false;\n    }\n\n    connectPlugins() {\n        const { plugins, pluginsEnabled } = this.editor.state;\n        let firstPluginNode: AudioNode;\n        let lastPluginNode: AudioNode;\n        plugins.forEach((p) => {\n            if (!p) return;\n            if (!pluginsEnabled.has(p)) return;\n            if (!firstPluginNode) firstPluginNode = p.audioNode;\n            lastPluginNode = p.audioNode;\n        });\n        if (firstPluginNode) {\n            this.preFxGainNode.connect(firstPluginNode);\n            lastPluginNode.connect(this.postFxGainNode);\n        } else {\n            this.preFxGainNode.connect(this.postFxGainNode);\n        }\n    }\n    disconnectPlugins() {\n        const { plugins, pluginsEnabled } = this.editor.state;\n        this.preFxGainNode.disconnect();\n        let lastPluginNode: AudioNode;\n        plugins.forEach((p) => {\n            if (!p) return;\n            if (!pluginsEnabled.has(p)) return;\n            lastPluginNode = p.audioNode;\n        });\n        if (lastPluginNode) lastPluginNode.disconnect(this.postFxGainNode);\n    }\n\n    async addPlugin(url: string, indexIn: number) {\n        const { plugins, pluginsEnabled } = this.editor.state;\n        const { default: Plugin }: { default: typeof WebAudioModule } = await import(/* webpackIgnore: true */url);\n        const plugin = await Plugin.createInstance(this.editor.instance.wamGroupId, this.audioCtx);\n        const { audioNode } = plugin;\n        const usingPlugins = this.playing || this.monitoring;\n        let preNode: AudioNode;\n        let postNode: AudioNode;\n        let index = indexIn;\n        while (index >= 0) {\n            index--;\n            if (plugins[index]) {\n                preNode = plugins[index].audioNode;\n                break;\n            }\n        }\n        if (!preNode && usingPlugins) preNode = this.preFxGainNode;\n        index = indexIn;\n        while (index < plugins.length) {\n            if (plugins[index]) {\n                postNode = plugins[index].audioNode;\n                break;\n            }\n            index++;\n        }\n        if (!postNode && usingPlugins) postNode = this.postFxGainNode;\n        audioNode.connect(this.dummyAnalyserNode);\n        if (preNode && postNode) preNode.disconnect(postNode);\n        if (preNode) preNode.connect(audioNode);\n        if (postNode) audioNode.connect(postNode);\n        plugins.splice(indexIn, 0, plugin);\n        pluginsEnabled.add(plugin);\n        this.editor.emitPluginsChanged();\n        return plugin;\n    }\n    removePlugin(indexIn: number) {\n        const { plugins, pluginsEnabled } = this.editor.state;\n        const plugin = plugins[indexIn];\n        if (!plugin) return;\n        const { audioNode } = plugin;\n        const usingPlugins = this.playing || this.monitoring;\n        let preNode: AudioNode;\n        let postNode: AudioNode;\n        let index = indexIn - 1;\n        while (index >= 0) {\n            if (plugins[index]) {\n                preNode = plugins[index].audioNode;\n                break;\n            }\n            index--;\n        }\n        if (!preNode && usingPlugins) preNode = this.preFxGainNode;\n        index = indexIn + 1;\n        while (index < plugins.length) {\n            if (plugins[index]) {\n                postNode = plugins[index].audioNode;\n                break;\n            }\n            index++;\n        }\n        if (!postNode && usingPlugins) postNode = this.postFxGainNode;\n        audioNode.disconnect();\n        if (pluginsEnabled.has(plugin) && preNode) {\n            preNode.disconnect(audioNode);\n            if (postNode) preNode.connect(postNode);\n        }\n        if (plugin.audioNode) plugin.audioNode.destroy();\n        delete plugins[indexIn];\n        plugins.splice(indexIn, 1);\n        if (plugins.length < 10) plugins.push(undefined);\n        this.editor.emitPluginsChanged();\n    }\n    movePlugin(fromIndexIn: number, toIndexIn: number) {\n        const { plugins, pluginsEnabled } = this.editor.state;\n        if (!plugins[fromIndexIn]) return;\n        const plugin = plugins[fromIndexIn];\n        const { audioNode } = plugin;\n        const usingPlugins = this.playing || this.monitoring;\n        const enabled = pluginsEnabled.has(plugin);\n        let preNode: AudioNode;\n        let postNode: AudioNode;\n        let index = fromIndexIn - 1;\n        while (index >= 0) {\n            if (plugins[index]) {\n                preNode = plugins[index].audioNode;\n                break;\n            }\n            index--;\n        }\n        if (!preNode && usingPlugins) preNode = this.preFxGainNode;\n        index = fromIndexIn + 1;\n        while (index < plugins.length) {\n            if (plugins[index]) {\n                postNode = plugins[index].audioNode;\n                break;\n            }\n            index++;\n        }\n        if (!postNode && usingPlugins) postNode = this.postFxGainNode;\n        if (enabled) {\n            if (preNode) preNode.disconnect(audioNode);\n            if (postNode) audioNode.disconnect(postNode);\n            if (preNode && postNode) preNode.connect(postNode);\n        }\n        plugins.splice(fromIndexIn, 1);\n        preNode = undefined;\n        postNode = undefined;\n        index = toIndexIn - 1;\n        while (index >= 0) {\n            if (plugins[index]) {\n                preNode = plugins[index].audioNode;\n                break;\n            }\n            index--;\n        }\n        if (!preNode && usingPlugins) preNode = this.preFxGainNode;\n        index = toIndexIn + 1;\n        while (index < plugins.length) {\n            if (plugins[index]) {\n                postNode = plugins[index].audioNode;\n                break;\n            }\n            index++;\n        }\n        if (!postNode && usingPlugins) postNode = this.postFxGainNode;\n        if (enabled) {\n            if (preNode && postNode) preNode.disconnect(postNode);\n            if (preNode) preNode.connect(audioNode);\n            if (postNode) audioNode.connect(postNode);\n        }\n        plugins.splice(toIndexIn, 0, plugin);\n        this.editor.emitPluginsChanged();\n    }\n    setPluginEnabled(indexIn: number, enabled: boolean) {\n        const { plugins, pluginsEnabled } = this.editor.state;\n        const plugin = plugins[indexIn];\n        if (!plugin) return;\n        if (pluginsEnabled.has(plugin) === enabled) return;\n        let index = indexIn - 1;\n        const { audioNode } = plugins[indexIn];\n        const usingPlugins = this.playing || this.monitoring;\n        let preNode: AudioNode;\n        let postNode: AudioNode;\n        while (index >= 0) {\n            if (plugins[index]) {\n                preNode = plugins[index].audioNode;\n                break;\n            }\n            index--;\n        }\n        if (!preNode && usingPlugins) preNode = this.preFxGainNode;\n        index = indexIn + 1;\n        while (index < plugins.length) {\n            if (plugins[index]) {\n                postNode = plugins[index].audioNode;\n                break;\n            }\n            index++;\n        }\n        if (!postNode && usingPlugins) postNode = this.postFxGainNode;\n        if (enabled) {\n            if (preNode && postNode) preNode.disconnect(postNode);\n            if (preNode) preNode.connect(audioNode);\n            if (postNode) audioNode.connect(postNode);\n        } else {\n            if (preNode) preNode.disconnect(audioNode);\n            if (postNode) audioNode.disconnect(postNode);\n            if (preNode && postNode) preNode.connect(postNode);\n        }\n        if (enabled) pluginsEnabled.add(plugin);\n        else pluginsEnabled.delete(plugin);\n        this.editor.emitPluginsChanged();\n    }\n}\n","import OperableAudioBuffer from \"./OperableAudioBuffer\";\nimport PatcherAudio from \"./PatcherAudio\";\nimport TransmitterNode from \"../worklets/Transmitter\";\nimport type AudioEditor from \"./AudioEditor\";\n\nexport default class AudioRecorder {\n    readonly editor: AudioEditor;\n    device: string;\n    stream: MediaStream;\n    constraints: MediaTrackConstraintSet = { echoCancellation: false, noiseSuppression: false, autoGainControl: false };\n    node: MediaStreamAudioSourceNode;\n    transmitter: TransmitterNode;\n    overwrittenAudio: PatcherAudio;\n    recording = false;\n    $: number;\n    $start: number;\n    $end: number;\n    inPlace: boolean;\n    get audioCtx() {\n        return this.editor.audioCtx;\n    }\n    get audio() {\n        return this.editor;\n    }\n    constructor(editor: AudioEditor) {\n        this.editor = editor;\n        navigator.mediaDevices.addEventListener(\"devicechange\", this.handleDeviceChange);\n    }\n    async init() {\n        await TransmitterNode.register(this.audioCtx.audioWorklet);\n        this.transmitter = new TransmitterNode(this.audioCtx);\n        this.transmitter.handleReceiveBuffer = this.handleReceiveBuffer;\n        await this.newSearch();\n    }\n    async destroy() {\n        navigator.mediaDevices.removeEventListener(\"devicechange\", this.handleDeviceChange);\n        if (this.recording) await this.stop();\n        await this.transmitter.destroy();\n    }\n    handleDeviceChange = async () => {\n        const devices = await navigator.mediaDevices.enumerateDevices();\n        const enums = devices.filter(d => d.kind === \"audioinput\").map(d => d.label || d.deviceId);\n        if (enums.indexOf(this.device) === -1) {\n            this.device = devices.find(d => d.deviceId === \"default\") ? \"default\" : devices.length ? devices[0].deviceId : \"default\";\n            await this.newSearch(this.device);\n        }\n    };\n    handleReceiveBuffer = async (bufferIn: Float32Array[], $total: number) => {\n        if (!this.recording) return;\n        let extended = false;\n        const { $, $start, $end, inPlace, audio, overwrittenAudio } = this;\n        const { length, numberOfChannels, sampleRate } = audio;\n        const $target = $start + $total;\n        const copyLength = (inPlace ? Math.min($target, $end) : $target) - $;\n        if (!inPlace && $target > length) { // extend current buffer\n            const newLength = 2 ** Math.ceil(Math.log(length + sampleRate) / Math.log(2));\n            const newBuffer = new OperableAudioBuffer({ numberOfChannels, length: newLength, sampleRate });\n            for (let i = 0; i < numberOfChannels; i++) {\n                const channel = newBuffer.getChannelData(i);\n                channel.set(audio.audioBuffer.getChannelData(i));\n                if (bufferIn[i]) {\n                    if (overwrittenAudio && $ < $end) {\n                        const overwrittenChannel = overwrittenAudio.audioBuffer.getChannelData(i);\n                        overwrittenChannel.set(channel.subarray($, $end), $ - $start);\n                    }\n                    channel.set(bufferIn[i], $);\n                }\n            }\n            audio.instance.audioBuffer = newBuffer;\n            audio.waveform.update($, newLength);\n            extended = true;\n        } else {\n            for (let i = 0; i < numberOfChannels; i++) {\n                const channel = audio.audioBuffer.getChannelData(i);\n                if (bufferIn[i]) {\n                    if (overwrittenAudio && $ < $end) {\n                        const overwrittenChannel = overwrittenAudio.audioBuffer.getChannelData(i);\n                        overwrittenChannel.set(channel.subarray($, Math.min($ + copyLength, $end)), $ - $start);\n                    }\n                    if (!inPlace || $target <= $end) channel.set(bufferIn[i], $);\n                    else channel.set(bufferIn[i].subarray(0, copyLength), $);\n                }\n            }\n            audio.waveform.update($, $ + copyLength);\n        }\n        this.$ += copyLength;\n        audio.instance.emit(\"setAudio\");\n        this.editor.setCursor(this.$);\n        if (extended) this.editor.setViewRange([this.editor.state.viewRange[0], this.audio.length]);\n        if (inPlace && this.$ === $end) {\n            this.editor.setRecording(false);\n            await this.stop();\n        }\n    };\n    newSearch = async (search?: string) => {\n        if (this.device && this.device === search) return;\n        if (this.stream && (this.recording || this.editor.player.monitoring)) {\n            this.node.disconnect();\n            this.stream.getAudioTracks().forEach(t => t.stop());\n            delete this.node;\n            delete this.stream;\n            delete this.editor.player.mediaStreamSourceNode;\n        }\n        const devices = await navigator.mediaDevices.enumerateDevices();\n        const enums = devices.filter(d => d.kind === \"audioinput\");\n        if (search) {\n            const device = devices.find(d => d.kind === \"audioinput\" && (d.deviceId === search || d.label === search));\n            if (device) this.device = device.deviceId;\n        } else {\n            this.device = enums.length ? enums[0].deviceId : undefined;\n        }\n        this.stream = await navigator.mediaDevices.getUserMedia({ audio: this.getConstraints(this.device) });\n        if (this.stream) {\n            if (this.recording || this.editor.player.monitoring) {\n                this.resetNode();\n                this.node.connect(this.transmitter);\n                if (this.editor.player.monitoring) this.node.connect(this.editor.player.preFxGainNode);\n                else this.node.connect(this.editor.player.postAnalyserNode);\n            } else {\n                this.resetNode();\n            }\n        }\n    };\n    getConstraints(deviceId?: string): MediaTrackConstraintSet {\n        return {\n            deviceId,\n            sampleRate: this.editor.sampleRate || this.audioCtx.sampleRate,\n            channelCount: this.editor.numberOfChannels || undefined,\n            ...this.constraints\n        };\n    }\n    resetNode() {\n        if (this.stream) {\n            this.node = this.audioCtx.createMediaStreamSource(this.stream);\n            this.node.channelInterpretation = \"discrete\";\n        }\n    }\n    async start() {\n        if (!this.node) return false;\n        this.node.connect(this.transmitter);\n        if (!this.editor.player.monitoring) this.node.connect(this.editor.player.postAnalyserNode);\n        const { state, env, project, length, numberOfChannels, sampleRate } = this.editor;\n        const { cursor, selRange } = state;\n        if (selRange) {\n            const [$start, $end] = selRange;\n            this.inPlace = true;\n            this.$start = $start;\n            this.$end = $end;\n            this.$ = $start;\n        } else {\n            this.inPlace = false;\n            this.$start = cursor;\n            this.$end = length;\n            this.$ = cursor;\n        }\n        const overwrittenBufferLength = this.$end - this.$start;\n        if (overwrittenBufferLength) this.overwrittenAudio = await PatcherAudio.fromSilence({ env, project, noRegister: true }, numberOfChannels, overwrittenBufferLength, sampleRate);\n        else this.overwrittenAudio = undefined;\n        this.recording = true;\n        await this.transmitter.reset();\n        await this.transmitter.start();\n        return true;\n    }\n    async stop() {\n        this.recording = false;\n        if (!this.node) return;\n        if (!this.editor.player.monitoring) this.node.disconnect(this.editor.player.postAnalyserNode);\n        await this.transmitter.stop();\n        if (!this.inPlace && this.$ > this.$end && this.$ < this.audio.length) {\n            const [audio] = await this.audio.instance.split(this.$);\n            this.audio.instance.setAudio(audio);\n            if (this.overwrittenAudio) this.overwrittenAudio.waveform.update();\n        } else {\n            if (this.overwrittenAudio) {\n                if (this.$ < this.$end) {\n                    const [audio] = await this.overwrittenAudio.split(this.$ - this.$start);\n                    this.overwrittenAudio.setAudio(audio);\n                }\n                this.overwrittenAudio.waveform.update();\n            }\n        }\n        const audio = await this.audio.instance.pick(this.$start, this.$, true);\n        this.editor.emit(\"recorded\", { range: (this.inPlace || this.overwrittenAudio) ? [this.$start, this.$] : undefined, cursor: (this.inPlace || this.overwrittenAudio) ? undefined : this.$start, audio, oldAudio: this.overwrittenAudio });\n        this.editor.setSelRange([this.$start, this.$]);\n    }\n}\n","export default class OperableAudioBuffer extends AudioBuffer {\n    clone() {\n        const newBuffer = new OperableAudioBuffer(this);\n        for (let i = 0; i < this.numberOfChannels; i++) {\n            const channel = this.getChannelData(i);\n            newBuffer.copyToChannel(channel, i);\n        }\n        return newBuffer;\n    }\n    reverse() {\n        for (let i = 0; i < this.numberOfChannels; i++) {\n            const channel = this.getChannelData(i);\n            channel.reverse();\n        }\n    }\n    inverse() {\n        for (let i = 0; i < this.numberOfChannels; i++) {\n            const channel = this.getChannelData(i);\n            for (let j = 0; j < channel.length; j++) {\n                channel[j] = -channel[j];\n            }\n        }\n    }\n    concat(that: AudioBuffer, numberOfChannels = this.numberOfChannels) {\n        const { sampleRate } = this;\n        const length = this.length + that.length;\n        const buffer = new OperableAudioBuffer({ numberOfChannels, length, sampleRate });\n        const from = this.length;\n        for (let i = 0; i < numberOfChannels; i++) {\n            // const channel = buffer.getChannelData(i);\n            // const channel1 = i < buffer1.numberOfChannels ? buffer1.getChannelData(i) : new Float32Array(buffer1.length);\n            // const channel2 = i < buffer2.numberOfChannels ? buffer2.getChannelData(i) : new Float32Array(buffer2.length);\n            if (i < this.numberOfChannels) buffer.copyToChannel(this.getChannelData(i), i);\n            if (i < that.numberOfChannels) buffer.copyToChannel(that.getChannelData(i), i, from);\n            // channel.set(channel1);\n            // channel.set(channel2, from);\n        }\n        return buffer;\n    }\n    split(from: number): [OperableAudioBuffer, OperableAudioBuffer] {\n        if (from >= this.length || from <= 0) throw new RangeError(\"Split point is out of bound\");\n        // split buffer\n        const { length, sampleRate, numberOfChannels } = this;\n        const buffer1 = new OperableAudioBuffer({ length: from, numberOfChannels, sampleRate });\n        const buffer2 = new OperableAudioBuffer({ length: length - from, numberOfChannels, sampleRate });\n        for (let i = 0; i < numberOfChannels; i++) {\n            // const channel = buffer.getChannelData(i);\n            const channel1 = buffer1.getChannelData(i);\n            const channel2 = buffer2.getChannelData(i);\n            this.copyFromChannel(channel1, i);\n            this.copyFromChannel(channel2, i, from);\n            // channel1.set(channel.subarray(0, from));\n            // channel2.set(channel.subarray(from));\n        }\n        return [buffer1, buffer2];\n    }\n    write(channel: number, index: number, value: number) {\n        if (channel > this.numberOfChannels) throw new Error(`Channel written ${channel} out of range ${this.numberOfChannels}`);\n        if (index > this.length) throw new Error(`Index written ${index} out of range ${this.length}`);\n        this.getChannelData(channel)[index] = value;\n    }\n    toArray(shared = false) {\n        const supportSAB = typeof SharedArrayBuffer !== \"undefined\";\n        const channelData: Float32Array[] = [];\n        const { numberOfChannels, length } = this;\n        for (let i = 0; i < numberOfChannels; i++) {\n            if (shared && supportSAB) {\n                channelData[i] = new Float32Array(new SharedArrayBuffer(length * Float32Array.BYTES_PER_ELEMENT));\n                channelData[i].set(this.getChannelData(i));\n            } else {\n                channelData[i] = this.getChannelData(i);\n            }\n        }\n        return channelData;\n    }\n}\n","import { WebAudioModule, VERSION as wamApiVersion } from \"@webaudiomodules/api\";\nimport { addFunctionModule, initializeWamEnv, initializeWamGroup } from \"@webaudiomodules/sdk\";\nimport { dbtoa, isIdentityMatrix, normExp } from \"../../utils/math\";\nimport AudioEditor from \"./AudioEditor\";\nimport FileInstance from \"../file/FileInstance\";\nimport AudioHistory from \"./AudioHistory\";\nimport OperableAudioBuffer from \"./OperableAudioBuffer\";\nimport Waveform from \"../../utils/Waveform\";\nimport type { Options } from \"../../utils/WavEncoder\";\nimport type PersistentProjectFile from \"../file/PersistentProjectFile\";\nimport type TempAudioFile from \"./TempAudioFile\";\nimport type Env from \"../Env\";\nimport type { IJSPatcherEnv } from \"../Env\";\nimport type Project from \"../Project\";\nimport type { IProject } from \"../Project\";\n\nexport interface PatcherAudioEventMap {\n    \"setAudio\": never;\n    \"selRange\": [number, number];\n    \"cursor\": number;\n    \"postInit\": never;\n}\n\nexport default class PatcherAudio extends FileInstance<PatcherAudioEventMap, PersistentProjectFile | TempAudioFile> {\n    static async fromProjectItem(options: { file: PersistentProjectFile; env: IJSPatcherEnv; project?: IProject; instanceId?: string }) {\n        return new this(options).init(options.file.data.slice(0));\n    }\n    static async fromArrayBuffer(options: ConstructorParameters<typeof PatcherAudio>[0], data: ArrayBuffer) {\n        const audio = new PatcherAudio(options);\n        await audio.init(data.slice(0));\n        return audio;\n    }\n    static async fromNativeAudioBuffer(options: ConstructorParameters<typeof PatcherAudio>[0], bufferIn: AudioBuffer) {\n        const audio = new PatcherAudio(options);\n        const audioBuffer = Object.setPrototypeOf(bufferIn, OperableAudioBuffer.prototype);\n        audio.audioBuffer = audioBuffer;\n        audio.waveform = new Waveform(audio);\n        await audio.waveform.generate();\n        await audio.emit(\"postInit\");\n        audio._isReady = true;\n        await audio.emit(\"ready\");\n        return audio;\n    }\n    static async fromSilence(optionsIn: ConstructorParameters<typeof PatcherAudio>[0], numberOfChannels: number, length: number, sampleRate: number) {\n        const audio = new PatcherAudio(optionsIn);\n        audio.audioBuffer = new OperableAudioBuffer({ length, numberOfChannels, sampleRate });\n        audio.waveform = new Waveform(audio);\n        audio.waveform.generateEmpty(numberOfChannels, length);\n        await audio.emit(\"postInit\");\n        audio._isReady = true;\n        await audio.emit(\"ready\");\n        return audio;\n    }\n    async getEditor() {\n        const editor = new AudioEditor(this);\n        return editor.init();\n    }\n    get audioCtx() {\n        return (this.project as Project)?.audioCtx || (this.env as Env).audioCtx;\n    }\n    audioBuffer: OperableAudioBuffer;\n    waveform: Waveform;\n    _history = new AudioHistory();\n\n    get length() {\n        return this.audioBuffer.length;\n    }\n    get numberOfChannels() {\n        return this.audioBuffer.numberOfChannels;\n    }\n    get sampleRate() {\n        return this.audioBuffer.sampleRate;\n    }\n    get wamGroupId() {\n        return (this.env as Env).wamGroupId;\n    }\n    get wamGroupKey() {\n        return (this.env as Env).wamGroupKey;\n    }\n    async init(data?: ArrayBuffer) {\n        const { audioCtx } = this;\n        await this.env.taskMgr.newTask(this, \"Initializing Audio\", async (onUpdate) => {\n            onUpdate(\"Decoding Audio...\");\n            if (data?.byteLength) {\n                const audioBuffer = await audioCtx.decodeAudioData(data);\n                this.audioBuffer = Object.setPrototypeOf(audioBuffer, OperableAudioBuffer.prototype);\n            } else {\n                this.audioBuffer = new OperableAudioBuffer({ length: 1, numberOfChannels: 1, sampleRate: audioCtx.sampleRate });\n            }\n            onUpdate(\"Generating Waveform...\");\n            this.waveform = new Waveform(this);\n            await this.waveform.generate();\n        });\n        this.on(\"setAudio\", () => this.emit(\"changed\"));\n        await this.emit(\"postInit\");\n        this._isReady = true;\n        await this.emit(\"ready\");\n        return this;\n    }\n    async initWithOptions(options: Partial<AudioBufferOptions>) {\n        const { length = 1, numberOfChannels = 1, sampleRate = this.audioCtx.sampleRate } = options;\n        this.audioBuffer = new OperableAudioBuffer({ length, numberOfChannels, sampleRate });\n        this.waveform = new Waveform(this);\n        await this.waveform.generate();\n        await this.emit(\"postInit\");\n        this._isReady = true;\n        await this.emit(\"ready\");\n    }\n    async initWith(audio: { audioBuffer: OperableAudioBuffer; waveform: Waveform }) {\n        this.setAudio(audio);\n        await this.emit(\"postInit\");\n        this._isReady = true;\n        await this.emit(\"ready\");\n    }\n    async serialize(optionsIn: Omit<Partial<Options>, \"sampleRate\"> = { bitDepth: 32, float: true }) {\n        return this.env.taskMgr.newTask(this, \"Encoding audio WAVE...\", () => {\n            const audioData = this.audioBuffer.toArray(true);\n            const options = { sampleRate: this.audioBuffer.sampleRate, bitDepth: 32, float: true, ...optionsIn };\n            return (this.env as Env).wavEncoderWorker.encode(audioData, options);\n        });\n    }\n    private encodeFFmpegWorker(wav: Uint8Array, inputFileName: string, outputFileName: string, ...args: string[]) {\n        return this.env.taskMgr.newTask(this, `Encoding audio ${outputFileName}...`, async (onUpdate) => {\n            const ffmpegWorker = await (this.env as Env).getFFmpeg();\n            // const handleProgress = (ratio: number) => onUpdate(`Encoding: ${(ratio * 100).toFixed(2)}%`);\n            ffmpegWorker.on(\"ffout\", onUpdate);\n            ffmpegWorker.on(\"fferr\", onUpdate);\n            ffmpegWorker.on(\"info\", onUpdate);\n            // ffmpegWorker.on(\"progress\", handleProgress);\n            try {\n                const result = await ffmpegWorker.run({\n                    data: wav,\n                    input: inputFileName,\n                    output: outputFileName,\n                    args: [\"-i\", inputFileName, ...args, outputFileName]\n                });\n                return result;\n            } finally {\n                ffmpegWorker.off(\"ffout\", onUpdate);\n                ffmpegWorker.off(\"fferr\", onUpdate);\n                ffmpegWorker.off(\"info\", onUpdate);\n                // ffmpegWorker.off(\"progress\", handleProgress);\n            }\n        });\n    }\n    async encodeMp3(bitrate: number) {\n        const wav = new Uint8Array(await this.serialize({ shared: true }));\n        const inputFileName = \"in.wav\";\n        const outputFileName = \"out.mp3\";\n        return this.encodeFFmpegWorker(wav, inputFileName, outputFileName, \"-codec:a\", \"libmp3lame\", \"-b:a\", `${bitrate}k`);\n    }\n    async encodeAac(bitrate: number) {\n        const wav = new Uint8Array(await this.serialize({ shared: true }));\n        const inputFileName = \"in.wav\";\n        const outputFileName = \"out.m4a\";\n        return this.encodeFFmpegWorker(wav, inputFileName, outputFileName, \"-codec:a\", \"aac\", \"-b:a\", `${bitrate}k`);\n    }\n    async clone() {\n        const audio = new PatcherAudio({ env: this.env, project: this.project, noRegister: true });\n        await audio.initWith({\n            audioBuffer: this.audioBuffer.clone(),\n            waveform: this.waveform.clone()\n        });\n        return audio;\n    }\n    setAudio(that: { audioBuffer: OperableAudioBuffer; waveform: Waveform }) {\n        this.audioBuffer = that.audioBuffer;\n        this.waveform = that.waveform;\n        this.waveform.patcherAudio = this;\n        this.emit(\"setAudio\");\n    }\n    async silence(selStart = 0, selEnd = this.length) {\n        const length = selEnd - selStart;\n        const audio = await PatcherAudio.fromSilence({ env: this.env, project: this.project, noRegister: true }, this.numberOfChannels, length, this.sampleRate);\n        const oldAudio = await this.pasteToRange(audio, selStart, selEnd);\n        return { range: [selStart, selEnd] as [number, number], audio, oldAudio };\n    }\n    async insertSilence(length: number, from: number) {\n        if (!length) return null;\n        const audio = await PatcherAudio.fromSilence({ env: this.env, project: this.project, noRegister: true }, this.numberOfChannels, length, this.sampleRate);\n        this.insertToCursor(audio, from);\n        return { range: [from, from + length] as [number, number], audio };\n    }\n    reverse() {\n        this.audioBuffer.reverse();\n        this.waveform.reverse();\n    }\n    inverse() {\n        this.audioBuffer.inverse();\n        this.waveform.inverse();\n    }\n    async concat(that: PatcherAudio, numberOfChannels = this.audioBuffer.numberOfChannels) {\n        const audio = new PatcherAudio({ env: this.env, project: this.project, noRegister: true });\n        const audioBuffer = this.audioBuffer.concat(that.audioBuffer, numberOfChannels);\n        audio.audioBuffer = audioBuffer;\n        const waveform = this.waveform.concat(that.waveform, audio, numberOfChannels);\n        await audio.initWith({ audioBuffer, waveform });\n        return audio;\n    }\n    async split(from: number) {\n        const audio1 = new PatcherAudio({ env: this.env, project: this.project, noRegister: true });\n        const audio2 = new PatcherAudio({ env: this.env, project: this.project, noRegister: true });\n        const [ab1, ab2] = this.audioBuffer.split(from);\n        audio1.audioBuffer = ab1;\n        audio2.audioBuffer = ab2;\n        const [wf1, wf2] = this.waveform.split(from, audio1, audio2);\n        await audio1.initWith({ audioBuffer: ab1, waveform: wf1 });\n        await audio2.initWith({ audioBuffer: ab2, waveform: wf2 });\n        return [audio1, audio2] as [PatcherAudio, PatcherAudio];\n    }\n    async pick(from: number, to: number, clone = false) {\n        let picked: PatcherAudio;\n        let audioBuffer: OperableAudioBuffer;\n        let waveform: Waveform;\n        if (from <= 0 && to >= this.length) {\n            picked = new PatcherAudio({ env: this.env, project: this.project, noRegister: true });\n            if (clone) {\n                audioBuffer = this.audioBuffer.clone();\n                waveform = this.waveform.clone();\n            } else {\n                audioBuffer = this.audioBuffer;\n                waveform = this.waveform;\n            }\n            await picked.initWith({ audioBuffer, waveform });\n            return picked;\n            // eslint-disable-next-line no-else-return\n        } else if (from <= 0) {\n            picked = (await this.split(to))[0];\n        } else if (to >= this.length) {\n            picked = (await this.split(from))[1];\n        } else {\n            const p0 = (await this.split(to))[0];\n            picked = (await p0.split(from))[1];\n        }\n        if (clone) picked.waveform = picked.waveform.clone();\n        return picked;\n    }\n    async removeFromRange(from: number, to: number) {\n        if (from === 0 && to === this.length) {\n            const old = await this.clone();\n            const { numberOfChannels, sampleRate } = this.audioBuffer;\n            const audioBuffer = new OperableAudioBuffer({ length: 1, numberOfChannels, sampleRate });\n            const waveform = new Waveform(this);\n            this.setAudio({ audioBuffer, waveform });\n            this.setCursor(from);\n            return old;\n        // eslint-disable-next-line no-else-return\n        } else if (from === 0) {\n            const [p1, p2] = await this.split(to);\n            this.setAudio(p2);\n            this.setCursor(from);\n            return p1;\n        } else if (to === this.audioBuffer.length) {\n            const [p1, p2] = await this.split(from);\n            this.setAudio(p1);\n            this.setCursor(from);\n            return p2;\n        } else {\n            const [p0, p3] = await this.split(to);\n            const [p1, p2] = await p0.split(from);\n            const concat = await p1.concat(p3);\n            this.setAudio(concat);\n            this.setCursor(from);\n            return p2;\n        }\n    }\n    async pasteToRange(that: PatcherAudio, from: number, to: number) {\n        if (from <= 0 && to >= this.length) {\n            const old = await this.clone();\n            this.setAudio(that);\n            this.setSelRangeToAll();\n            return old;\n        // eslint-disable-next-line no-else-return\n        } else if (from <= 0) {\n            const [p1, p2] = await this.split(to);\n            const concat = await that.concat(p2, p2.numberOfChannels);\n            this.setAudio(concat);\n            this.setSelRange([0, that.length]);\n            return p1;\n        } else if (to >= this.length) {\n            const [p1, p2] = await this.split(from);\n            const concat = await p1.concat(that);\n            this.setAudio(concat);\n            this.setSelRange([from, this.length]);\n            return p2;\n        } else {\n            const [p, p2] = await this.split(to);\n            const [p0, old] = await p.split(from);\n            const p1 = await p0.concat(that);\n            const concat = await p1.concat(p2);\n            this.setAudio(concat);\n            this.setSelRange([from, from + that.length]);\n            return old;\n        }\n    }\n    async insertToCursor(that: PatcherAudio, cursor: number) {\n        if (cursor <= 0) {\n            const concat = await that.concat(this, this.numberOfChannels);\n            this.setAudio(concat);\n            this.setSelRange([0, that.length]);\n        } else if (cursor >= this.length) {\n            const concat = await this.concat(that);\n            this.setAudio(concat);\n            this.setSelRange([cursor, this.length]);\n        } else {\n            const [p0, p2] = await this.split(cursor);\n            const p1 = await p0.concat(that);\n            const concat = await p1.concat(p2);\n            this.setAudio(concat);\n            this.setSelRange([cursor, cursor + that.length]);\n        }\n    }\n    async fade(gain: number, from = 0, to = this.length, enabledChannels: boolean[] = new Array(this.numberOfChannels).fill(true)) {\n        const oldAudio = await this.pick(from, to, true);\n        const factor = dbtoa(gain);\n        for (let c = 0; c < this.numberOfChannels; c++) {\n            if (!enabledChannels[c]) return null;\n            const channel = this.audioBuffer.getChannelData(c);\n            for (let i = from; i < to; i++) {\n                channel[i] *= factor;\n            }\n        }\n        this.waveform.update(from, to);\n        const audio = await this.pick(from, to, true);\n        return { gain, range: [from, to] as [number, number], audio, oldAudio };\n    }\n    async fadeIn(lengthIn: number, exponent = 0, enabledChannels: boolean[] = new Array(this.numberOfChannels).fill(true)) {\n        const length = Math.max(0, Math.min(this.length, ~~lengthIn));\n        if (!length) return null;\n        const oldAudio = await this.pick(0, length, true);\n        for (let c = 0; c < this.numberOfChannels; c++) {\n            if (!enabledChannels[c]) return null;\n            const channel = this.audioBuffer.getChannelData(c);\n            for (let i = 0; i < length; i++) {\n                channel[i] *= normExp(i / length, exponent);\n            }\n        }\n        this.waveform.update(0, length);\n        const audio = await this.pick(0, length, true);\n        return { length, exponent, audio, oldAudio };\n    }\n    async fadeOut(lengthIn: number, exponent = 0, enabledChannels: boolean[] = new Array(this.numberOfChannels).fill(true)) {\n        const l = this.length;\n        const length = Math.max(0, Math.min(l, ~~lengthIn));\n        if (!length) return null;\n        const oldAudio = await this.pick(l - length, l, true);\n        for (let c = 0; c < this.numberOfChannels; c++) {\n            if (!enabledChannels[c]) return null;\n            const channel = this.audioBuffer.getChannelData(c);\n            for (let i = 0; i < length; i++) {\n                channel[l - i] *= normExp(i / length, exponent);\n            }\n        }\n        this.waveform.update(l - length, l);\n        const audio = await this.pick(l - length, l, true);\n        return { length, exponent, audio, oldAudio };\n    }\n    write(channel: number, index: number, value: number) {\n        this.audioBuffer.write(channel, index, value);\n        this.waveform.update(index, index + 1);\n    }\n    async render(sampleRateIn?: number, mix?: number[][], applyPlugins?: boolean, pluginsOptions?: { plugins: WebAudioModule[]; pluginsEnabled: WeakSet<WebAudioModule>; preFxGain: number; postFxGain: number }): Promise<PatcherAudio> {\n        return this.env.taskMgr.newTask(this, \"Rendering audio...\", async () => {\n            let { length } = this;\n            const needResample = sampleRateIn && this.sampleRate !== sampleRateIn;\n            const needRemix = mix && (mix.length !== this.numberOfChannels || !isIdentityMatrix(mix));\n            if (!needResample && !needRemix && !applyPlugins) return this;\n            if (needResample) length = Math.ceil(length * sampleRateIn / this.sampleRate);\n            const numberOfChannels = mix ? mix.length : this.numberOfChannels;\n            const sampleRate = sampleRateIn || this.sampleRate;\n            let mixBuffer: AudioBuffer;\n            if (!needRemix) {\n                mixBuffer = this.audioBuffer;\n            } else {\n                await this.env.taskMgr.newTask(this, \"Remixing audio...\", () => {\n                    mixBuffer = new AudioBuffer({ numberOfChannels, length: this.length, sampleRate: this.sampleRate });\n                    for (let i = 0; i < mixBuffer.numberOfChannels; i++) {\n                        const mixChannel = mixBuffer.getChannelData(i);\n                        for (let j = 0; j < mix[i].length; j++) {\n                            const gain = mix[i][j];\n                            const channel = this.audioBuffer.getChannelData(j);\n                            for (let k = 0; k < mixChannel.length; k++) {\n                                mixChannel[k] += channel[k] * gain;\n                            }\n                        }\n                    }\n                });\n            }\n            if (!applyPlugins && !needResample) return PatcherAudio.fromNativeAudioBuffer({ env: this.env, project: this.project, noRegister: true }, mixBuffer);\n            const offlineAudioCtx = new OfflineAudioContext(numberOfChannels, length, sampleRate);\n            const { audioWorklet } = offlineAudioCtx;\n            await addFunctionModule(audioWorklet, initializeWamEnv, wamApiVersion);\n            await addFunctionModule(audioWorklet, initializeWamGroup, this.wamGroupId, this.wamGroupKey);\n            const source = offlineAudioCtx.createBufferSource();\n            source.buffer = mixBuffer;\n            if (applyPlugins) {\n                await this.env.taskMgr.newTask(this, \"Applying plugins...\", async (onUpdate) => {\n                    const { plugins, pluginsEnabled, preFxGain, postFxGain } = pluginsOptions;\n                    const preFxGainNode = offlineAudioCtx.createGain();\n                    preFxGainNode.gain.value = dbtoa(preFxGain);\n                    const postFxGainNode = offlineAudioCtx.createGain();\n                    postFxGainNode.gain.value = dbtoa(postFxGain);\n                    source.connect(preFxGainNode);\n                    let lastNode: AudioNode = preFxGainNode;\n                    for (const plugin of plugins) {\n                        if (!plugin) continue;\n                        if (!pluginsEnabled.has(plugin)) continue;\n                        onUpdate(plugin.name);\n                        try {\n                            const Plugin = Object.getPrototypeOf(plugin).constructor as typeof WebAudioModule;\n                            const p = await Plugin.createInstance(this.wamGroupId, offlineAudioCtx);\n                            await p.audioNode.setParameterValues(await plugin.audioNode.getParameterValues());\n                            lastNode.connect(p.audioNode);\n                            lastNode = p.audioNode;\n                        } catch (e) {\n                            continue;\n                        }\n                    }\n                    lastNode.connect(postFxGainNode);\n                    postFxGainNode.connect(offlineAudioCtx.destination);\n                });\n            } else {\n                source.connect(offlineAudioCtx.destination);\n            }\n            source.start(0);\n            return this.env.taskMgr.newTask(this, \"Applying plugins...\", async () => {\n                const bufferOut = await offlineAudioCtx.startRendering();\n                return PatcherAudio.fromNativeAudioBuffer({ env: this.env, project: this.project, noRegister: true }, bufferOut);\n            });\n        });\n    }\n    setCursor(cursor: number) {\n        this.emit(\"cursor\", cursor);\n    }\n    setSelRange(range: [number, number]) {\n        this.emit(\"selRange\", range);\n    }\n    setSelRangeToAll() {\n        this.emit(\"selRange\", [0, this.length]);\n    }\n}\n","import { TypedMessageEvent, MessagePortResponse, MessagePortRequest } from \"./TypedAudioWorklet\";\nimport { AudioWorkletProxyNode } from \"./AudioWorkletProxyNode.types\";\n\nconst Node = class AudioWorkletProxyNode extends AudioWorkletNode {\n    static fnNames: string[] = [];\n    _disposed = false;\n    constructor(context: AudioContext, name: string, options?: AudioWorkletNodeOptions) {\n        super(context, name, options);\n        const resolves: Record<number, ((...args: any[]) => any)> = {};\n        const rejects: Record<number, ((...args: any[]) => any)> = {};\n        let messagePortRequestId = 1;\n        const handleDisposed = () => {\n            this.port.removeEventListener(\"message\", handleMessage);\n            this.port.close();\n        };\n        const handleMessage = async (e: TypedMessageEvent<MessagePortResponse & MessagePortRequest>) => {\n            const { id, call, args, value, error } = e.data;\n            if (call) {\n                const r: MessagePortResponse = { id };\n                try {\n                    r.value = await (this as any)[call](...args);\n                } catch (e) {\n                    r.error = e;\n                }\n                this.port.postMessage(r);\n                if (this._disposed) handleDisposed();\n            } else {\n                if (error) {\n                    if (rejects[id]) rejects[id](error);\n                    delete rejects[id];\n                    return;\n                }\n                if (resolves[id]) {\n                    resolves[id](value);\n                    delete resolves[id];\n                }\n            }\n        };\n        // eslint-disable-next-line\n        const call = (call: string, ...args: any[]) => {\n            return new Promise<any>((resolve, reject) => {\n                const id = messagePortRequestId++;\n                resolves[id] = resolve;\n                rejects[id] = reject;\n                this.port.postMessage({ id, call, args });\n            });\n        };\n        const Ctor = (this.constructor as typeof AudioWorkletProxyNode);\n        Ctor.fnNames.forEach(name => (this as any)[name] = (...args: any[]) => call(name, ...args));\n        this.port.start();\n        this.port.addEventListener(\"message\", handleMessage);\n    }\n} as typeof AudioWorkletProxyNode;\n\nexport default Node;\n","export const registeredProcessors: WeakMap<AudioWorklet, Set<string>> = window.jspatcherEnv?.AudioWorkletRegister?.registeredProcessors || new WeakMap();\nexport const registeringProcessors: WeakMap<AudioWorklet, Set<string>> = window.jspatcherEnv?.AudioWorkletRegister?.registeringProcessors || new WeakMap();\nexport const resolves: Record<string, ((value?: void | PromiseLike<void>) => void)[]> = window.jspatcherEnv?.AudioWorkletRegister?.resolves || {};\nexport const rejects: Record<string, ((reason?: any) => void)[]> = window.jspatcherEnv?.AudioWorkletRegister?.rejects || {};\n\nexport default class AudioWorkletRegister {\n    static registeredProcessors = registeredProcessors;\n\n    static registeringProcessors = registeringProcessors;\n\n    static resolves = resolves;\n\n    static rejects = rejects;\n\n    private static async registerProcessor(audioWorklet: AudioWorklet, processorId: string, processor: string | ((id: string, ...injections: any[]) => void), ...injection: any[]) {\n        this.registeringProcessors.get(audioWorklet).add(processorId);\n        try {\n            const url = typeof processor === \"string\" ? processor : URL.createObjectURL(new Blob([`(${processor.toString()})(${[processorId, ...injection].map(JSON.stringify as (arg: any) => string).join(\", \")});`], { type: \"text/javascript\" }));\n            await audioWorklet.addModule(url);\n            this.resolves[processorId].forEach(f => f());\n            this.registeringProcessors.get(audioWorklet).delete(processorId);\n            this.registeredProcessors.get(audioWorklet).add(processorId);\n        } catch (e) {\n            this.rejects[processorId].forEach(f => f(e));\n        }\n        this.rejects[processorId] = [];\n        this.resolves[processorId] = [];\n    }\n\n    static async register(audioWorklet: AudioWorklet, processorId: string, processor: string | ((id: string, ...injections: any[]) => void), ...injection: any[]) {\n        if (!this.resolves[processorId]) this.resolves[processorId] = [];\n        if (!this.rejects[processorId]) this.rejects[processorId] = [];\n        const promise = new Promise<void>((resolve, reject) => {\n            this.resolves[processorId].push(resolve);\n            this.rejects[processorId].push(reject);\n        });\n        if (!this.registeringProcessors.has(audioWorklet)) {\n            this.registeringProcessors.set(audioWorklet, new Set());\n        }\n        if (!this.registeredProcessors.has(audioWorklet)) {\n            this.registeredProcessors.set(audioWorklet, new Set());\n        }\n        const registered = this.registeredProcessors.get(audioWorklet).has(processorId);\n        const registering = this.registeringProcessors.get(audioWorklet).has(processorId);\n        if (registered) return Promise.resolve();\n        if (registering) return promise;\n        if (!registered && audioWorklet) {\n            this.registerProcessor(audioWorklet, processorId, processor, ...injection);\n        }\n        return promise;\n    }\n}\n","import processorURL from \"./TemporalAnalyser.worklet.ts\"; // eslint-disable-line import/extensions\nimport AudioWorkletProxyNode from \"./AudioWorkletProxyNode\";\nimport { ITemporalAnalyserNode, ITemporalAnalyserProcessor, TemporalAnalyserParameters } from \"./TemporalAnalyserWorklet.types\";\nimport AudioWorkletRegister from \"./AudioWorkletRegister\";\n\nexport const processorId = \"__JSPatcher_TemporalAnalyser\";\nexport default class TemporalAnalyserNode extends AudioWorkletProxyNode<ITemporalAnalyserNode, ITemporalAnalyserProcessor, TemporalAnalyserParameters> implements ITemporalAnalyserNode {\n    static processorId = processorId;\n    static register = (audioWorklet: AudioWorklet) => AudioWorkletRegister.register(audioWorklet, processorId, processorURL);\n    static fnNames: (keyof ITemporalAnalyserProcessor)[] = [\"getRms\", \"getAbsMax\", \"getZcr\", \"getEstimatedFreq\", \"getBuffer\", \"gets\", \"destroy\"];\n    constructor(context: BaseAudioContext) {\n        super(context, processorId, { numberOfInputs: 1, numberOfOutputs: 0 });\n        const _destroy = this.destroy;\n        this.destroy = async () => {\n            await _destroy.call(this);\n            this._disposed = true;\n        };\n    }\n}\n","import processorURL from \"./Transmitter.worklet.ts\"; // eslint-disable-line import/extensions\nimport AudioWorkletProxyNode from \"./AudioWorkletProxyNode\";\nimport { ITransmitterNode, ITransmitterProcessor, TransmitterParameters } from \"./TransmitterWorklet.types\";\nimport AudioWorkletRegister from \"./AudioWorkletRegister\";\n\nexport const processorId = \"__JSPatcher_Transmitter\";\nexport default class TransmitterNode extends AudioWorkletProxyNode<ITransmitterNode, ITransmitterProcessor, TransmitterParameters> implements ITransmitterNode {\n    static processorId = processorId;\n    static register = (audioWorklet: AudioWorklet) => AudioWorkletRegister.register(audioWorklet, processorId, processorURL);\n    static fnNames: (keyof ITransmitterProcessor)[] = [\"start\", \"stop\", \"reset\", \"destroy\"];\n    handleReceiveBuffer: (buffer: Float32Array[], $total: number) => any;\n    constructor(context: BaseAudioContext) {\n        super(context, processorId, { numberOfInputs: 1, numberOfOutputs: 0 });\n        const _destroy = this.destroy;\n        this.destroy = async () => {\n            await _destroy.call(this);\n            this._disposed = true;\n        };\n    }\n    setBuffer({ buffer, $total }: { buffer: Float32Array[]; $total: number }) {\n        if (this.handleReceiveBuffer) this.handleReceiveBuffer(buffer, $total);\n    }\n}\n","import type PatcherAudio from \"../core/audio/PatcherAudio\";\nimport type Env from \"../core/Env\";\nimport type WaveformWorker from \"../core/workers/WaveformWorker\";\nimport type { WaveformData, WaveformStepData } from \"../core/types\";\n\nexport default class Waveform implements WaveformData {\n    static stepsFactor = 16;\n    [step: number]: WaveformStepData;\n    private readonly worker: WaveformWorker;\n    private _patcherAudio: PatcherAudio;\n    get patcherAudio() {\n        return this._patcherAudio;\n    }\n    set patcherAudio(audio: PatcherAudio) {\n        this._patcherAudio = audio;\n    }\n    get audioBuffer() {\n        return this.patcherAudio.audioBuffer;\n    }\n    get length() {\n        return this.audioBuffer.length;\n    }\n    get steps() {\n        return Object.keys(this).filter(v => +v).map(v => +v).sort((a, b) => a - b);\n    }\n\n    constructor(patcherAudioIn: PatcherAudio, waveformDataIn?: WaveformData) {\n        this.worker = (patcherAudioIn.env as Env).waveformWorker;\n        this.patcherAudio = patcherAudioIn;\n        if (!waveformDataIn) return;\n        Object.keys(waveformDataIn).filter(v => +v).map(v => +v).forEach((stepLength) => {\n            const stepData = waveformDataIn[stepLength];\n            this[stepLength] = [];\n            const newStepData = this[stepLength];\n            if (stepData.length) newStepData.idx = stepData.idx.slice();\n            for (let c = 0; c < stepData.length; c++) {\n                const { min, max } = stepData[c];\n                newStepData[c] = { min: min.slice(), max: max.slice() };\n            }\n        });\n    }\n    clone() {\n        return new Waveform(this.patcherAudio, this);\n    }\n    async generate() {\n        const audioChannelData = this.audioBuffer.toArray(true);\n        const data = await this.worker.generate(audioChannelData, Waveform.stepsFactor);\n        for (const key in data) {\n            this[key] = data[key];\n        }\n    }\n    generateEmpty(numberOfChannels: number, l: number) {\n        const { stepsFactor } = Waveform;\n        for (let stepLength = stepsFactor; stepLength <= l / stepsFactor; stepLength *= stepsFactor) {\n            const stepData: WaveformStepData = [];\n            this[stepLength] = stepData;\n            const stepsCount = Math.ceil(l / stepLength);\n            const idxData = new Int32Array(stepsCount);\n            for (let i = 0; i < idxData.length; i++) {\n                idxData[i] = i * stepLength;\n            }\n            stepData.idx = idxData;\n            for (let c = 0; c < numberOfChannels; c++) {\n                const minData = new Float32Array(stepsCount);\n                const maxData = new Float32Array(stepsCount);\n                stepData[c] = { min: minData, max: maxData };\n            }\n        }\n    }\n    generateStep(stepLength: number) {\n        const { stepsFactor } = Waveform;\n        const { audioBuffer: buffer } = this;\n        if (!this[stepLength]) this[stepLength] = [];\n        const l = buffer.length;\n        let maxInStep;\n        let minInStep;\n        if (stepLength === stepsFactor) { // recalculate from samples\n            const stepsCount = Math.ceil(l / stepLength);\n            const idxData = new Int32Array(stepsCount);\n            for (let i = 0; i < idxData.length; i++) {\n                idxData[i] = i * stepLength;\n            }\n            this[stepLength].idx = idxData;\n            for (let c = 0; c < buffer.numberOfChannels; c++) {\n                const minData = new Float32Array(stepsCount);\n                const maxData = new Float32Array(stepsCount);\n                const channel = buffer.getChannelData(c);\n                for (let i = 0; i < idxData.length; i++) {\n                    const $0 = idxData[i];\n                    const $1 = i === idxData.length - 1 ? l : idxData[i + 1];\n                    for (let j = $0; j < $1; j++) {\n                        const samp = channel[j];\n                        if (j === $0) {\n                            maxInStep = samp;\n                            minInStep = samp;\n                        } else {\n                            if (samp > maxInStep) maxInStep = samp;\n                            if (samp < minInStep) minInStep = samp;\n                        }\n                    }\n                    minData[i] = minInStep;\n                    maxData[i] = maxInStep;\n                }\n                this[stepLength][c] = { min: minData, max: maxData };\n            }\n        } else { // calculate from lower level\n            const { idx: prevIdx } = this[stepLength / stepsFactor];\n            const stepsCount = Math.ceil(prevIdx.length / 16);\n            const idxData = new Int32Array(stepsCount);\n            for (let i = 0; i < idxData.length; i++) {\n                idxData[i] = prevIdx[i * stepsFactor];\n            }\n            this[stepLength].idx = idxData;\n            for (let c = 0; c < buffer.numberOfChannels; c++) {\n                const minData = new Float32Array(stepsCount);\n                const maxData = new Float32Array(stepsCount);\n                const { min: prevMin, max: prevMax } = this[stepLength / stepsFactor][c];\n                for (let i = 0; i < idxData.length; i++) {\n                    const $prev0 = i * stepsFactor;\n                    const $prev1 = i === idxData.length - 1 ? prevIdx.length : ((i + 1) * stepsFactor);\n                    for (let j = $prev0; j < $prev1; j++) {\n                        const sampMax = prevMax[j];\n                        const sampMin = prevMin[j];\n                        if (j === $prev0) {\n                            maxInStep = sampMax;\n                            minInStep = sampMin;\n                        } else {\n                            if (sampMax > maxInStep) maxInStep = sampMax;\n                            if (sampMin < minInStep) minInStep = sampMin;\n                        }\n                    }\n                    minData[i] = minInStep;\n                    maxData[i] = maxInStep;\n                }\n                this[stepLength][c] = { min: minData, max: maxData };\n            }\n        }\n        return this[stepLength];\n    }\n    update(from = 0, to = this.audioBuffer.length) {\n        const { stepsFactor } = Waveform;\n        const { audioBuffer: buffer } = this;\n        const l = buffer.length;\n        for (let stepLength = stepsFactor; stepLength <= l / stepsFactor; stepLength *= stepsFactor) {\n            let stepData: WaveformStepData;\n            if (this[stepLength]) {\n                stepData = this[stepLength];\n                let { idx: idxData } = stepData;\n                // check if need expansion\n                let expand = 0;\n                const oldLength = idxData[idxData.length - 1] + stepLength;\n                if (l > oldLength) {\n                    expand = Math.ceil((l - oldLength) / stepLength);\n                    const newLength = idxData.length + expand;\n                    const newIdxData = new Int32Array(newLength);\n                    newIdxData.set(idxData);\n                    for (let i = idxData.length, j = oldLength; i < newIdxData.length; i++, j += stepLength) {\n                        newIdxData[i] = j;\n                    }\n                    idxData = newIdxData;\n                }\n                stepData.idx = idxData;\n                for (let c = 0; c < buffer.numberOfChannels; c++) {\n                    const samples = buffer.getChannelData(c);\n                    let { min: minData, max: maxData } = stepData[c];\n                    if (expand) {\n                        const min = new Float32Array(idxData.length);\n                        const max = new Float32Array(idxData.length);\n                        min.set(minData);\n                        max.set(maxData);\n                        minData = min;\n                        maxData = max;\n                        stepData[c] = { min: minData, max: maxData };\n                    }\n                    // index range to rebuild data\n                    let $from: number;\n                    let $to: number;\n                    for (let i = 1; i <= idxData.length; i++) {\n                        const $ = i === idxData.length ? l : idxData[i];\n                        if (typeof $from === \"undefined\" && $ > from) {\n                            $from = i - 1;\n                        }\n                        if (typeof $to === \"undefined\" && $ >= to) {\n                            $to = i;\n                            break;\n                        }\n                    }\n                    let maxInStep;\n                    let minInStep;\n                    if (stepLength === stepsFactor) { // recalculate from samples\n                        for (let i = $from; i < $to; i++) {\n                            const $0 = idxData[i];\n                            const $1 = i === idxData.length - 1 ? l : idxData[i + 1];\n                            for (let j = $0; j < $1; j++) {\n                                const samp = samples[j];\n                                if (j === $0) {\n                                    maxInStep = samp;\n                                    minInStep = samp;\n                                } else {\n                                    if (samp > maxInStep) maxInStep = samp;\n                                    if (samp < minInStep) minInStep = samp;\n                                }\n                            }\n                            minData[i] = minInStep;\n                            maxData[i] = maxInStep;\n                        }\n                    } else {\n                        const { idx: prevIdx } = this[stepLength / stepsFactor];\n                        const { min: prevMin, max: prevMax } = this[stepLength / stepsFactor][c];\n                        for (let i = $from; i < $to; i++) {\n                            let $prev0 = Math.min(prevIdx.length - 1, i * stepsFactor);\n                            const idx0 = idxData[i];\n                            if (prevIdx[$prev0] < idx0) {\n                                do {\n                                    $prev0++;\n                                } while ($prev0 < prevIdx.length - 1 && prevIdx[$prev0] < idx0);\n                            } else if (prevIdx[$prev0] > idx0) {\n                                do {\n                                    $prev0--;\n                                } while ($prev0 > 0 && prevIdx[$prev0] > idx0);\n                            }\n                            let $prev1;\n                            if (i === idxData.length - 1) {\n                                $prev1 = prevIdx.length;\n                            } else {\n                                $prev1 = Math.min(prevIdx.length, (i + 1) * stepsFactor);\n                                const idx1 = idxData[i + 1];\n                                if (prevIdx[$prev1] < idx1) {\n                                    do {\n                                        $prev1++;\n                                    } while ($prev1 < prevIdx.length && prevIdx[$prev1] < idx1);\n                                } else if (prevIdx[$prev1] > idx1) {\n                                    do {\n                                        $prev1--;\n                                    } while ($prev1 > 1 && prevIdx[$prev1] > idx1);\n                                }\n                            }\n                            for (let j = $prev0; j < $prev1; j++) {\n                                const sampMin = prevMin[j];\n                                const sampMax = prevMax[j];\n                                if (j === $prev0) {\n                                    maxInStep = sampMax;\n                                    minInStep = sampMin;\n                                } else {\n                                    if (sampMax > maxInStep) maxInStep = sampMax;\n                                    if (sampMin < minInStep) minInStep = sampMin;\n                                }\n                            }\n                            minData[i] = minInStep;\n                            maxData[i] = maxInStep;\n                        }\n                    }\n                }\n            } else {\n                this.generateStep(stepLength);\n            }\n        }\n    }\n    inverse() {\n        this.steps.forEach((stepLength) => {\n            const stepData = this[stepLength];\n            for (let c = 0; c < stepData.length; c++) {\n                const { min, max } = stepData[c];\n                for (let i = 0; i < min.length; i++) {\n                    const $max = -min[i];\n                    const $min = -max[i];\n                    min[i] = $min;\n                    max[i] = $max;\n                }\n            }\n        });\n    }\n    reverse() {\n        this.steps.forEach((stepLength) => {\n            const stepData = this[stepLength];\n            if (stepData.length) {\n                const { idx } = stepData;\n                idx.reverse();\n                for (let i = 0; i < idx.length; i++) {\n                    idx[i] = length - idx[i];\n                }\n                idx.set(idx.subarray(0, -1), 1);\n                idx[0] = 0;\n            }\n            for (let c = 0; c < stepData.length; c++) {\n                const { min, max } = stepData[c];\n                min.reverse();\n                max.reverse();\n            }\n        });\n    }\n    /**\n     * Returns a new Waveform instance concatenating this and another waveform\n     *\n     * @param {Waveform} that waveform to concat\n     * @param {PatcherAudio} patcherAudio result PatcherAudio\n     * @param {number} [numberOfChannels=patcherAudio.audioBuffer.numberOfChannels] number of channels\n     */\n    concat(that: Waveform, patcherAudio: PatcherAudio, numberOfChannels: number = patcherAudio.audioBuffer.numberOfChannels) {\n        const { stepsFactor } = Waveform;\n        const { length: l } = patcherAudio.audioBuffer;\n        const from = this.length;\n        const waveform = new Waveform(patcherAudio);\n        for (let stepLength = stepsFactor; stepLength <= l / stepsFactor; stepLength *= stepsFactor) {\n            const stepData: WaveformStepData = [];\n            let stepData1 = this[stepLength];\n            let stepData2 = that[stepLength];\n            waveform[stepLength] = stepData;\n            if (!stepData1) { // recalculate data1\n                stepData1 = this.generateStep(stepLength);\n            }\n            if (!stepData2) { // recalculate data2\n                stepData2 = that.generateStep(stepLength);\n            }\n            const { idx: idxData1 } = stepData1;\n            const { idx: idxData2 } = stepData2;\n            const idxData = new Int32Array(idxData1.length + idxData2.length);\n            idxData.set(idxData1);\n            idxData.set(idxData2, idxData1.length);\n            for (let j = idxData1.length; j < idxData.length; j++) {\n                idxData[j] += from;\n            }\n            stepData.idx = idxData;\n            for (let c = 0; c < numberOfChannels; c++) {\n                const { min: minData1, max: maxData1 } = stepData1[c] || {};\n                const { min: minData2, max: maxData2 } = stepData2[c] || {};\n                const minData = new Float32Array(idxData1.length + idxData2.length);\n                const maxData = new Float32Array(idxData1.length + idxData2.length);\n                if (minData1) minData.set(minData1);\n                if (minData2) minData.set(minData2, idxData1.length);\n                if (maxData1) maxData.set(maxData1);\n                if (maxData2) maxData.set(maxData2, idxData1.length);\n                stepData[c] = { min: minData, max: maxData };\n            }\n        }\n        return waveform;\n    }\n    /**\n     * Split this Waveform into two instances.\n     *\n     * @param {number} from Split point in sample\n     * @param {PatcherAudio} patcherAudio1 Splitted PatcherAudio 1\n     * @param {PatcherAudio} patcherAudio2 Splitted PatcherAudio 2\n     * @returns {[Waveform, Waveform]} Splitted Waveforms\n     */\n    split(from: number, patcherAudio1: PatcherAudio, patcherAudio2: PatcherAudio): [Waveform, Waveform] {\n        const { audioBuffer: buffer } = this;\n        const l = buffer.length;\n        if (from >= l || from <= 0) throw new RangeError(\"Split point is out of bound\");\n        const { audioBuffer: audioBuffer1 } = patcherAudio1;\n        const { audioBuffer: audioBuffer2 } = patcherAudio2;\n        // split waveform\n        const waveform1 = new Waveform(patcherAudio1);\n        const waveform2 = new Waveform(patcherAudio2);\n        const waveformKeys = this.steps;\n        for (let i = 0; i < waveformKeys.length; i++) {\n            const stepLength = waveformKeys[i];\n            const stepData = this[stepLength];\n            const stepData1: WaveformStepData = [];\n            const stepData2: WaveformStepData = [];\n            waveform1[stepLength] = stepData1;\n            waveform2[stepLength] = stepData2;\n            const { idx } = stepData;\n            let $data: number; // index of data to split from, next buffer index if split between\n            let splitBetween = false;\n            for (let i = 1; i <= idx.length; i++) {\n                const $ = i === idx.length ? l : idx[i];\n                if ($ >= from) {\n                    splitBetween = $ !== from;\n                    $data = i;\n                    break;\n                }\n            }\n            // split index data for every channel\n            let idxData1 = idx.slice();\n            let idxData2 = idx.slice();\n            if ($data !== idx.length) {\n                idxData1 = idxData1.subarray(0, $data);\n            }\n            if ($data - 1 !== 0) {\n                idxData2 = idxData2.subarray($data - +splitBetween);\n                for (let j = 0; j < idxData2.length; j++) {\n                    idxData2[j] = j === 0 ? 0 : idxData2[j] - from;\n                }\n            }\n            stepData1.idx = idxData1;\n            stepData2.idx = idxData2;\n            for (let c = 0; c < buffer.numberOfChannels; c++) {\n                // split data\n                let { min: minData1, max: maxData1 } = stepData[c];\n                if ($data !== idx.length) {\n                    minData1 = minData1.subarray(0, $data);\n                    maxData1 = maxData1.subarray(0, $data);\n                }\n                stepData1[c] = { min: minData1, max: maxData1 };\n                let { min: minData2, max: maxData2 } = stepData[c];\n                if ($data - 1 !== 0) {\n                    minData2 = minData2.subarray($data - +splitBetween);\n                    maxData2 = maxData2.subarray($data - +splitBetween);\n                }\n                stepData2[c] = { min: minData2, max: maxData2 };\n                // recalculate\n                if (splitBetween) {\n                    let maxInStep;\n                    let minInStep;\n                    if (i === 0) { // calculate from samples\n                        // ending of first part\n                        const channel1 = audioBuffer1.getChannelData(c);\n                        for (let j = idxData1[idxData1.length - 1]; j < from; j++) {\n                            const samp = channel1[j];\n                            if (j === 0) {\n                                maxInStep = samp;\n                                minInStep = samp;\n                            } else {\n                                if (samp > maxInStep) maxInStep = samp;\n                                if (samp < minInStep) minInStep = samp;\n                            }\n                        }\n                        minData1[idxData1.length - 1] = minInStep;\n                        maxData1[idxData1.length - 1] = maxInStep;\n                        // starting of second part\n                        const channel2 = audioBuffer2.getChannelData(c);\n                        for (let j = 0; j < (idxData2.length === 1 ? audioBuffer2.length : idxData2[1]); j++) {\n                            const samp = channel2[j];\n                            if (j === 0) {\n                                maxInStep = samp;\n                                minInStep = samp;\n                            } else {\n                                if (samp > maxInStep) maxInStep = samp;\n                                if (samp < minInStep) minInStep = samp;\n                            }\n                        }\n                        minData2[0] = minInStep;\n                        maxData2[0] = maxInStep;\n                    } else { // calculate from lower level\n                        const { idx: prevIdx1 } = waveform1[waveformKeys[i - 1]];\n                        const { min: prevMin1, max: prevMax1 } = waveform1[waveformKeys[i - 1]][c];\n                        // ending of first part\n                        let $prev1 = prevIdx1.length - 1;\n                        const idx1 = idxData1[idxData1.length - 1];\n                        while (prevIdx1[$prev1] > idx1) {\n                            $prev1--;\n                        }\n                        for (let k = $prev1; k < prevIdx1.length; k++) {\n                            const sampMax = prevMax1[k];\n                            const sampMin = prevMin1[k];\n                            if (k === $prev1) {\n                                maxInStep = sampMax;\n                                minInStep = sampMin;\n                            } else {\n                                if (sampMax > maxInStep) maxInStep = sampMax;\n                                if (sampMin < minInStep) minInStep = sampMin;\n                            }\n                        }\n                        minData1[idxData1.length - 1] = minInStep;\n                        maxData1[idxData1.length - 1] = maxInStep;\n                        const { idx: prevIdx2 } = waveform2[waveformKeys[i - 1]];\n                        const { min: prevMin2, max: prevMax2 } = waveform2[waveformKeys[i - 1]][c];\n                        // starting of second part\n                        let $prev2 = 1;\n                        if (idxData2.length > 1) {\n                            const idx2 = idxData2[1];\n                            while (prevIdx2[$prev2] < idx2) {\n                                $prev2++;\n                            }\n                        }\n                        for (let k = 0; k < $prev2; k++) {\n                            const sampMax = prevMax2[k];\n                            const sampMin = prevMin2[k];\n                            if (k === $prev2) {\n                                maxInStep = sampMax;\n                                minInStep = sampMin;\n                            } else {\n                                if (sampMax > maxInStep) maxInStep = sampMax;\n                                if (sampMin < minInStep) minInStep = sampMin;\n                            }\n                        }\n                        minData2[0] = minInStep;\n                        maxData2[0] = maxInStep;\n                    }\n                }\n            }\n        }\n        return [waveform1, waveform2];\n    }\n    /**\n     * Find an existing waveform with a precision (could be samples per pixel)\n     * returning a waveform that is sufficient to the precision.\n     * (step is the largest value smaller than the precision)\n     */\n    findStep(precision: number) {\n        const key = this.steps.reduce<number>((acc, cur) => (cur < precision && cur > (acc || 0) ? cur : acc), undefined);\n        if (!key) return null;\n        return this[key];\n    }\n}\n","module.exports = __webpack_public_path__ + \"js/f756c9045e64f89e98fe.worklet.js\";","module.exports = __webpack_public_path__ + \"js/f2448b5f421c9b32104a.worklet.js\";","// src/AbstractWamEnv.js\nvar getWamEnv = (apiVersion) => {\n  class WamEnv {\n    get apiVersion() {\n      throw new Error(\"Not Implemented.\");\n      return null;\n    }\n    getModuleScope(moduleId) {\n      throw new Error(\"Not Implemented.\");\n      return null;\n    }\n    getGroup(groupId, groupKey) {\n      throw new Error(\"Not Implemented.\");\n      return null;\n    }\n    addGroup(group) {\n      throw new Error(\"Not Implemented.\");\n      return null;\n    }\n    removeGroup(group) {\n      throw new Error(\"Not Implemented.\");\n      return null;\n    }\n    addWam(wam) {\n      throw new Error(\"Not Implemented.\");\n      return null;\n    }\n    removeWam(wam) {\n      throw new Error(\"Not Implemented.\");\n      return null;\n    }\n    connectEvents(groupId, fromId, toId, output) {\n      throw new Error(\"Not Implemented.\");\n      return null;\n    }\n    disconnectEvents(groupId, fromId, toId, output) {\n      throw new Error(\"Not Implemented.\");\n      return null;\n    }\n    emitEvents(from, ...events) {\n      throw new Error(\"Not Implemented.\");\n      return null;\n    }\n  }\n  return WamEnv;\n};\nvar AbstractWamEnv_default = getWamEnv;\n\n// src/AbstractWamGroup.js\nvar initializeWamGroup = (groupId, groupKey) => {\n  class WamGroup {\n    get groupId() {\n      throw new Error(\"Not Implemented.\");\n      return null;\n    }\n    validate(groupKey2) {\n      throw new Error(\"Not Implemented.\");\n      return null;\n    }\n    addWam(wam) {\n      throw new Error(\"Not Implemented.\");\n      return null;\n    }\n    removeWam(wam) {\n      throw new Error(\"Not Implemented.\");\n      return null;\n    }\n    connectEvents(fromId, toId, output) {\n      throw new Error(\"Not Implemented.\");\n      return null;\n    }\n    disconnectEvents(fromId, toId, output) {\n      throw new Error(\"Not Implemented.\");\n      return null;\n    }\n    emitEvents(from, ...events) {\n      throw new Error(\"Not Implemented.\");\n      return null;\n    }\n  }\n  return WamGroup;\n};\nvar AbstractWamGroup_default = initializeWamGroup;\n\n// src/AbstractWamNode.js\nvar WamNode = class extends AudioWorkletNode {\n  constructor(module, options) {\n    super(module.audioContext, module.moduleId, options);\n  }\n  get groupId() {\n    throw new Error(\"Not Implemented.\");\n    return null;\n  }\n  get moduleId() {\n    throw new Error(\"Not Implemented.\");\n    return null;\n  }\n  get instanceId() {\n    throw new Error(\"Not Implemented.\");\n    return null;\n  }\n  get module() {\n    throw new Error(\"Not Implemented.\");\n    return null;\n  }\n  async getCompensationDelay() {\n    throw new Error(\"Not Implemented.\");\n    return null;\n  }\n  async getParameterInfo(...parameterIdQuery) {\n    throw new Error(\"Not Implemented.\");\n    return null;\n  }\n  async getParameterValues(normalized, ...parameterIdQuery) {\n    throw new Error(\"Not Implemented.\");\n    return null;\n  }\n  async setParameterValues(parameterValues) {\n    throw new Error(\"Not Implemented.\");\n  }\n  async getState() {\n    throw new Error(\"Not Implemented.\");\n    return null;\n  }\n  async setState(state) {\n    throw new Error(\"Not Implemented.\");\n  }\n  scheduleEvents(...events) {\n    throw new Error(\"Not Implemented.\");\n  }\n  async clearEvents() {\n    throw new Error(\"Not Implemented.\");\n  }\n  connectEvents(toId, output) {\n    throw new Error(\"Not Implemented.\");\n  }\n  disconnectEvents(toId, output) {\n    throw new Error(\"Not Implemented.\");\n  }\n  destroy() {\n    throw new Error(\"Not Implemented.\");\n  }\n};\n\n// src/AbstractWamParameter.js\nvar WamParameter = class {\n  constructor(info) {\n  }\n  get info() {\n    throw new Error(\"Not Implemented.\");\n    return null;\n  }\n  get value() {\n    throw new Error(\"Not Implemented.\");\n    return null;\n  }\n  set value(value) {\n    throw new Error(\"Not Implemented.\");\n  }\n  get normalizedValue() {\n    throw new Error(\"Not Implemented.\");\n    return null;\n  }\n  set normalizedValue(normalizedValue) {\n    throw new Error(\"Not Implemented.\");\n  }\n};\n\n// src/AbstractWamParameterInfo.js\nvar WamParameterInfo = class {\n  constructor(id, config) {\n  }\n  get id() {\n    throw new Error(\"Not Implemented.\");\n    return null;\n  }\n  get label() {\n    throw new Error(\"Not Implemented.\");\n    return null;\n  }\n  get type() {\n    throw new Error(\"Not Implemented.\");\n    return null;\n  }\n  get defaultValue() {\n    throw new Error(\"Not Implemented.\");\n    return null;\n  }\n  get minValue() {\n    throw new Error(\"Not Implemented.\");\n    return null;\n  }\n  get maxValue() {\n    throw new Error(\"Not Implemented.\");\n    return null;\n  }\n  get discreteStep() {\n    throw new Error(\"Not Implemented.\");\n    return null;\n  }\n  get exponent() {\n    throw new Error(\"Not Implemented.\");\n    return null;\n  }\n  get choices() {\n    throw new Error(\"Not Implemented.\");\n    return null;\n  }\n  get units() {\n    throw new Error(\"Not Implemented.\");\n    return null;\n  }\n  normalize(value) {\n    throw new Error(\"Not Implemented.\");\n    return null;\n  }\n  denormalize(value) {\n    throw new Error(\"Not Implemented.\");\n    return null;\n  }\n  valueString(value) {\n    throw new Error(\"Not Implemented.\");\n    return null;\n  }\n};\n\n// src/AbstractWamProcessor.js\nvar getWamProcessor = (moduleId) => {\n  const { AudioWorkletProcessor } = globalThis;\n  class WamProcessor extends AudioWorkletProcessor {\n    get groupId() {\n      throw new Error(\"Not Implemented.\");\n      return null;\n    }\n    get moduleId() {\n      throw new Error(\"Not Implemented.\");\n      return null;\n    }\n    get instanceId() {\n      throw new Error(\"Not Implemented.\");\n      return null;\n    }\n    getCompensationDelay() {\n      throw new Error(\"Not Implemented.\");\n      return null;\n    }\n    scheduleEvents(...events) {\n      throw new Error(\"Not Implemented.\");\n    }\n    emitEvents(...events) {\n      throw new Error(\"Not Implemented.\");\n    }\n    clearEvents() {\n      throw new Error(\"Not Implemented.\");\n    }\n    destroy() {\n      throw new Error(\"Not Implemented.\");\n    }\n  }\n  return WamProcessor;\n};\nvar AbstractWamProcessor_default = getWamProcessor;\n\n// src/AbstractWebAudioModule.js\nvar WebAudioModule = class {\n  static get isWebAudioModuleConstructor() {\n    throw new Error(\"Not Implemented.\");\n    return null;\n  }\n  static async createInstance(groupId, audioContext, initialState) {\n    throw new Error(\"Not Implemented.\");\n    return null;\n  }\n  constructor(groupId, audioContext) {\n  }\n  get isWebAudioModule() {\n    throw new Error(\"Not Implemented.\");\n    return null;\n  }\n  get audioContext() {\n    throw new Error(\"Not Implemented.\");\n    return null;\n  }\n  set audioContext(audioContext) {\n    throw new Error(\"Not Implemented.\");\n  }\n  get audioNode() {\n    throw new Error(\"Not Implemented.\");\n    return null;\n  }\n  set audioNode(audioNode) {\n    throw new Error(\"Not Implemented.\");\n  }\n  get initialized() {\n    throw new Error(\"Not Implemented.\");\n    return null;\n  }\n  set initialized(initialized) {\n    throw new Error(\"Not Implemented.\");\n  }\n  get groupId() {\n    throw new Error(\"Not Implemented.\");\n    return null;\n  }\n  get moduleId() {\n    throw new Error(\"Not Implemented.\");\n    return null;\n  }\n  get instanceId() {\n    throw new Error(\"Not Implemented.\");\n    return null;\n  }\n  set instanceId(instanceId) {\n    throw new Error(\"Not Implemented.\");\n  }\n  get descriptor() {\n    throw new Error(\"Not Implemented.\");\n    return null;\n  }\n  get name() {\n    throw new Error(\"Not Implemented.\");\n    return null;\n  }\n  get vendor() {\n    throw new Error(\"Not Implemented.\");\n    return null;\n  }\n  async initialize(state) {\n    throw new Error(\"Not Implemented.\");\n    return null;\n  }\n  async createAudioNode(initialState) {\n    throw new Error(\"Not Implemented.\");\n    return null;\n  }\n  async createGui() {\n    throw new Error(\"Not Implemented.\");\n    return null;\n  }\n  destroyGui(gui) {\n    throw new Error(\"Not Implemented.\");\n  }\n};\n\n// src/version.js\nvar version_default = \"2.0.0-alpha.3\";\nexport {\n  WamNode as AbstractWamNode,\n  WamParameter as AbstractWamParameter,\n  WamParameterInfo as AbstractWamParameterInfo,\n  WebAudioModule as AbstractWebAudioModule,\n  version_default as VERSION,\n  AbstractWamEnv_default as getAbstractWamEnv,\n  AbstractWamGroup_default as getAbstractWamGroup,\n  AbstractWamProcessor_default as getAbstractWamProcessor\n};\n//# sourceMappingURL=index.js.map\n","// src/WebAudioModule.js\nvar WebAudioModule = class {\n  static get isWebAudioModuleConstructor() {\n    return true;\n  }\n  static createInstance(groupId, audioContext, initialState) {\n    return new this(groupId, audioContext).initialize(initialState);\n  }\n  constructor(groupId, audioContext) {\n    this._groupId = groupId;\n    this._audioContext = audioContext;\n    this._initialized = false;\n    this._audioNode = void 0;\n    this._timestamp = performance.now();\n    this._guiModuleUrl = void 0;\n    this._descriptorUrl = \"./descriptor.json\";\n    this._descriptor = {\n      name: `WebAudioModule_${this.constructor.name}`,\n      vendor: \"WebAudioModuleVendor\",\n      description: \"\",\n      version: \"0.0.0\",\n      apiVersion: \"2.0.0\",\n      thumbnail: \"\",\n      keywords: [],\n      isInstrument: false,\n      website: \"\",\n      hasAudioInput: true,\n      hasAudioOutput: true,\n      hasAutomationInput: true,\n      hasAutomationOutput: true,\n      hasMidiInput: true,\n      hasMidiOutput: true,\n      hasMpeInput: true,\n      hasMpeOutput: true,\n      hasOscInput: true,\n      hasOscOutput: true,\n      hasSysexInput: true,\n      hasSysexOutput: true\n    };\n  }\n  get isWebAudioModule() {\n    return true;\n  }\n  get groupId() {\n    return this._groupId;\n  }\n  get moduleId() {\n    return this.vendor + this.name;\n  }\n  get instanceId() {\n    return this.moduleId + this._timestamp;\n  }\n  get descriptor() {\n    return this._descriptor;\n  }\n  get name() {\n    return this.descriptor.name;\n  }\n  get vendor() {\n    return this.descriptor.vendor;\n  }\n  get audioContext() {\n    return this._audioContext;\n  }\n  get audioNode() {\n    if (!this.initialized)\n      console.warn(\"WAM should be initialized before getting the audioNode\");\n    return this._audioNode;\n  }\n  set audioNode(node) {\n    this._audioNode = node;\n  }\n  get initialized() {\n    return this._initialized;\n  }\n  set initialized(value) {\n    this._initialized = value;\n  }\n  async createAudioNode(initialState) {\n    throw new TypeError(\"createAudioNode() not provided\");\n  }\n  async initialize(state) {\n    if (!this._audioNode)\n      this.audioNode = await this.createAudioNode();\n    this.initialized = true;\n    return this;\n  }\n  async _loadGui() {\n    const url = this._guiModuleUrl;\n    if (!url)\n      throw new TypeError(\"Gui module not found\");\n    return import(\n      /* webpackIgnore: true */\n      url\n    );\n  }\n  async _loadDescriptor() {\n    const url = this._descriptorUrl;\n    if (!url)\n      throw new TypeError(\"Descriptor not found\");\n    const response = await fetch(url);\n    const descriptor = await response.json();\n    Object.assign(this._descriptor, descriptor);\n    return this._descriptor;\n  }\n  async createGui() {\n    if (!this.initialized)\n      console.warn(\"Plugin should be initialized before getting the gui\");\n    if (!this._guiModuleUrl)\n      return void 0;\n    const { createElement } = await this._loadGui();\n    return createElement(this);\n  }\n  destroyGui() {\n  }\n};\nvar WebAudioModule_default = WebAudioModule;\n\n// src/RingBuffer.js\nvar getRingBuffer = (moduleId) => {\n  const audioWorkletGlobalScope = globalThis;\n  class RingBuffer2 {\n    static getStorageForCapacity(capacity, Type) {\n      if (!Type.BYTES_PER_ELEMENT) {\n        throw new Error(\"Pass in a ArrayBuffer subclass\");\n      }\n      const bytes = 8 + (capacity + 1) * Type.BYTES_PER_ELEMENT;\n      return new SharedArrayBuffer(bytes);\n    }\n    constructor(sab, Type) {\n      if (!Type.BYTES_PER_ELEMENT) {\n        throw new Error(\"Pass a concrete typed array class as second argument\");\n      }\n      this._Type = Type;\n      this._capacity = (sab.byteLength - 8) / Type.BYTES_PER_ELEMENT;\n      this.buf = sab;\n      this.write_ptr = new Uint32Array(this.buf, 0, 1);\n      this.read_ptr = new Uint32Array(this.buf, 4, 1);\n      this.storage = new Type(this.buf, 8, this._capacity);\n    }\n    get type() {\n      return this._Type.name;\n    }\n    push(elements) {\n      const rd = Atomics.load(this.read_ptr, 0);\n      const wr = Atomics.load(this.write_ptr, 0);\n      if ((wr + 1) % this._storageCapacity() === rd) {\n        return 0;\n      }\n      const toWrite = Math.min(this._availableWrite(rd, wr), elements.length);\n      const firstPart = Math.min(this._storageCapacity() - wr, toWrite);\n      const secondPart = toWrite - firstPart;\n      this._copy(elements, 0, this.storage, wr, firstPart);\n      this._copy(elements, firstPart, this.storage, 0, secondPart);\n      Atomics.store(this.write_ptr, 0, (wr + toWrite) % this._storageCapacity());\n      return toWrite;\n    }\n    pop(elements) {\n      const rd = Atomics.load(this.read_ptr, 0);\n      const wr = Atomics.load(this.write_ptr, 0);\n      if (wr === rd) {\n        return 0;\n      }\n      const isArray = !Number.isInteger(elements);\n      const toRead = Math.min(this._availableRead(rd, wr), isArray ? elements.length : elements);\n      if (isArray) {\n        const firstPart = Math.min(this._storageCapacity() - rd, toRead);\n        const secondPart = toRead - firstPart;\n        this._copy(this.storage, rd, elements, 0, firstPart);\n        this._copy(this.storage, 0, elements, firstPart, secondPart);\n      }\n      Atomics.store(this.read_ptr, 0, (rd + toRead) % this._storageCapacity());\n      return toRead;\n    }\n    get empty() {\n      const rd = Atomics.load(this.read_ptr, 0);\n      const wr = Atomics.load(this.write_ptr, 0);\n      return wr === rd;\n    }\n    get full() {\n      const rd = Atomics.load(this.read_ptr, 0);\n      const wr = Atomics.load(this.write_ptr, 0);\n      return (wr + 1) % this._capacity !== rd;\n    }\n    get capacity() {\n      return this._capacity - 1;\n    }\n    get availableRead() {\n      const rd = Atomics.load(this.read_ptr, 0);\n      const wr = Atomics.load(this.write_ptr, 0);\n      return this._availableRead(rd, wr);\n    }\n    get availableWrite() {\n      const rd = Atomics.load(this.read_ptr, 0);\n      const wr = Atomics.load(this.write_ptr, 0);\n      return this._availableWrite(rd, wr);\n    }\n    _availableRead(rd, wr) {\n      if (wr > rd) {\n        return wr - rd;\n      }\n      return wr + this._storageCapacity() - rd;\n    }\n    _availableWrite(rd, wr) {\n      let rv = rd - wr - 1;\n      if (wr >= rd) {\n        rv += this._storageCapacity();\n      }\n      return rv;\n    }\n    _storageCapacity() {\n      return this._capacity;\n    }\n    _copy(input, offsetInput, output, offsetOutput, size) {\n      for (let i = 0; i < size; i++) {\n        output[offsetOutput + i] = input[offsetInput + i];\n      }\n    }\n  }\n  if (audioWorkletGlobalScope.AudioWorkletProcessor) {\n    const ModuleScope = audioWorkletGlobalScope.webAudioModules.getModuleScope(moduleId);\n    if (!ModuleScope.RingBuffer)\n      ModuleScope.RingBuffer = RingBuffer2;\n  }\n  return RingBuffer2;\n};\nvar RingBuffer_default = getRingBuffer;\n\n// src/WamArrayRingBuffer.js\nvar getWamArrayRingBuffer = (moduleId) => {\n  const audioWorkletGlobalScope = globalThis;\n  class WamArrayRingBuffer {\n    static DefaultArrayCapacity = 2;\n    static getStorageForEventCapacity(RingBuffer2, arrayLength, arrayType, maxArrayCapacity = void 0) {\n      if (maxArrayCapacity === void 0)\n        maxArrayCapacity = WamArrayRingBuffer.DefaultArrayCapacity;\n      else\n        maxArrayCapacity = Math.max(maxArrayCapacity, WamArrayRingBuffer.DefaultArrayCapacity);\n      if (!arrayType.BYTES_PER_ELEMENT) {\n        throw new Error(\"Pass in a ArrayBuffer subclass\");\n      }\n      const capacity = arrayLength * maxArrayCapacity;\n      return RingBuffer2.getStorageForCapacity(capacity, arrayType);\n    }\n    constructor(RingBuffer2, sab, arrayLength, arrayType, maxArrayCapacity = void 0) {\n      if (!arrayType.BYTES_PER_ELEMENT) {\n        throw new Error(\"Pass in a ArrayBuffer subclass\");\n      }\n      this._arrayLength = arrayLength;\n      this._arrayType = arrayType;\n      this._arrayElementSizeBytes = arrayType.BYTES_PER_ELEMENT;\n      this._arraySizeBytes = this._arrayLength * this._arrayElementSizeBytes;\n      this._sab = sab;\n      if (maxArrayCapacity === void 0)\n        maxArrayCapacity = WamArrayRingBuffer.DefaultArrayCapacity;\n      else\n        maxArrayCapacity = Math.max(maxArrayCapacity, WamArrayRingBuffer.DefaultArrayCapacity);\n      this._arrayArray = new arrayType(this._arrayLength);\n      this._rb = new RingBuffer2(this._sab, arrayType);\n    }\n    write(array) {\n      if (array.length !== this._arrayLength)\n        return false;\n      const elementsAvailable = this._rb.availableWrite;\n      if (elementsAvailable < this._arrayLength)\n        return false;\n      let success = true;\n      const elementsWritten = this._rb.push(array);\n      if (elementsWritten != this._arrayLength)\n        success = false;\n      return success;\n    }\n    read(array, newest) {\n      if (array.length !== this._arrayLength)\n        return false;\n      const elementsAvailable = this._rb.availableRead;\n      if (elementsAvailable < this._arrayLength)\n        return false;\n      if (newest && elementsAvailable > this._arrayLength)\n        this._rb.pop(elementsAvailable - this._arrayLength);\n      let success = false;\n      const elementsRead = this._rb.pop(array);\n      if (elementsRead === this._arrayLength)\n        success = true;\n      return success;\n    }\n  }\n  if (audioWorkletGlobalScope.AudioWorkletProcessor) {\n    const ModuleScope = audioWorkletGlobalScope.webAudioModules.getModuleScope(moduleId);\n    if (!ModuleScope.WamArrayRingBuffer)\n      ModuleScope.WamArrayRingBuffer = WamArrayRingBuffer;\n  }\n  return WamArrayRingBuffer;\n};\nvar WamArrayRingBuffer_default = getWamArrayRingBuffer;\n\n// src/WamEnv.js\nvar initializeWamEnv = (apiVersion) => {\n  const audioWorkletGlobalScope = globalThis;\n  if (audioWorkletGlobalScope.AudioWorkletProcessor && audioWorkletGlobalScope.webAudioModules)\n    return;\n  const moduleScopes = /* @__PURE__ */ new Map();\n  const groups = /* @__PURE__ */ new Map();\n  class WamEnv {\n    constructor() {\n    }\n    get apiVersion() {\n      return apiVersion;\n    }\n    getModuleScope(moduleId) {\n      if (!moduleScopes.has(moduleId))\n        moduleScopes.set(moduleId, {});\n      return moduleScopes.get(moduleId);\n    }\n    getGroup(groupId, groupKey) {\n      const group = groups.get(groupId);\n      if (group.validate(groupKey))\n        return group;\n      else\n        throw \"Invalid key\";\n    }\n    addGroup(group) {\n      if (!groups.has(group.groupId))\n        groups.set(group.groupId, group);\n    }\n    removeGroup(group) {\n      groups.delete(group.groupId);\n    }\n    addWam(wam) {\n      const group = groups.get(wam.groupId);\n      group.addWam(wam);\n    }\n    removeWam(wam) {\n      const group = groups.get(wam.groupId);\n      group.removeWam(wam);\n    }\n    connectEvents(groupId, fromId, toId, output = 0) {\n      const group = groups.get(groupId);\n      group.connectEvents(fromId, toId, output);\n    }\n    disconnectEvents(groupId, fromId, toId, output) {\n      const group = groups.get(groupId);\n      group.disconnectEvents(fromId, toId, output);\n    }\n    emitEvents(from, ...events) {\n      const group = groups.get(from.groupId);\n      group.emitEvents(from, ...events);\n    }\n  }\n  if (audioWorkletGlobalScope.AudioWorkletProcessor) {\n    if (!audioWorkletGlobalScope.webAudioModules)\n      audioWorkletGlobalScope.webAudioModules = new WamEnv();\n  }\n};\nvar WamEnv_default = initializeWamEnv;\n\n// src/WamGroup.js\nvar initializeWamGroup = (groupId, groupKey) => {\n  const audioWorkletGlobalScope = globalThis;\n  class WamGroup {\n    constructor(groupId2, groupKey2) {\n      this._groupId = groupId2;\n      this._validate = (key) => {\n        return key == groupKey2;\n      };\n      this._processors = /* @__PURE__ */ new Map();\n      this._eventGraph = /* @__PURE__ */ new Map();\n    }\n    get groupId() {\n      return this._groupId;\n    }\n    get processors() {\n      return this._processors;\n    }\n    get eventGraph() {\n      return this._eventGraph;\n    }\n    validate(groupKey2) {\n      return this._validate(groupKey2);\n    }\n    addWam(wam) {\n      this._processors.set(wam.instanceId, wam);\n    }\n    removeWam(wam) {\n      if (this._eventGraph.has(wam))\n        this._eventGraph.delete(wam);\n      this._eventGraph.forEach((outputMap) => {\n        outputMap.forEach((set) => {\n          if (set && set.has(wam))\n            set.delete(wam);\n        });\n      });\n      this._processors.delete(wam.instanceId);\n    }\n    connectEvents(fromId, toId, output) {\n      const from = this._processors.get(fromId);\n      const to = this._processors.get(toId);\n      let outputMap;\n      if (this._eventGraph.has(from)) {\n        outputMap = this._eventGraph.get(from);\n      } else {\n        outputMap = [];\n        this._eventGraph.set(from, outputMap);\n      }\n      if (outputMap[output]) {\n        outputMap[output].add(to);\n      } else {\n        const set = /* @__PURE__ */ new Set();\n        set.add(to);\n        outputMap[output] = set;\n      }\n    }\n    disconnectEvents(fromId, toId, output) {\n      const from = this._processors.get(fromId);\n      if (!this._eventGraph.has(from))\n        return;\n      const outputMap = this._eventGraph.get(from);\n      if (typeof toId === \"undefined\") {\n        outputMap.forEach((set) => {\n          if (set)\n            set.clear();\n        });\n        return;\n      }\n      const to = this._processors.get(toId);\n      if (typeof output === \"undefined\") {\n        outputMap.forEach((set) => {\n          if (set)\n            set.delete(to);\n        });\n        return;\n      }\n      if (!outputMap[output])\n        return;\n      outputMap[output].delete(to);\n    }\n    emitEvents(from, ...events) {\n      if (!this._eventGraph.has(from))\n        return;\n      const downstream = this._eventGraph.get(from);\n      downstream.forEach((set) => {\n        if (set)\n          set.forEach((wam) => wam.scheduleEvents(...events));\n      });\n    }\n  }\n  if (audioWorkletGlobalScope.AudioWorkletProcessor) {\n    audioWorkletGlobalScope.webAudioModules.addGroup(new WamGroup(groupId, groupKey));\n  }\n};\nvar WamGroup_default = initializeWamGroup;\n\n// src/WamEventRingBuffer.js\nvar getWamEventRingBuffer = (moduleId) => {\n  const audioWorkletGlobalScope = globalThis;\n  class WamEventRingBuffer2 {\n    static DefaultExtraBytesPerEvent = 64;\n    static WamEventBaseBytes = 4 + 1 + 8;\n    static WamAutomationEventBytes = WamEventRingBuffer2.WamEventBaseBytes + 2 + 8 + 1;\n    static WamTransportEventBytes = WamEventRingBuffer2.WamEventBaseBytes + 4 + 8 + 8 + 1 + 1 + 1;\n    static WamMidiEventBytes = WamEventRingBuffer2.WamEventBaseBytes + 1 + 1 + 1;\n    static WamBinaryEventBytes = WamEventRingBuffer2.WamEventBaseBytes + 4;\n    static getStorageForEventCapacity(RingBuffer2, eventCapacity, maxBytesPerEvent = void 0) {\n      if (maxBytesPerEvent === void 0)\n        maxBytesPerEvent = WamEventRingBuffer2.DefaultExtraBytesPerEvent;\n      else\n        maxBytesPerEvent = Math.max(maxBytesPerEvent, WamEventRingBuffer2.DefaultExtraBytesPerEvent);\n      const capacity = (Math.max(WamEventRingBuffer2.WamAutomationEventBytes, WamEventRingBuffer2.WamTransportEventBytes, WamEventRingBuffer2.WamMidiEventBytes, WamEventRingBuffer2.WamBinaryEventBytes) + maxBytesPerEvent) * eventCapacity;\n      return RingBuffer2.getStorageForCapacity(capacity, Uint8Array);\n    }\n    constructor(RingBuffer2, sab, parameterIds, maxBytesPerEvent = void 0) {\n      this._eventSizeBytes = {};\n      this._encodeEventType = {};\n      this._decodeEventType = {};\n      const wamEventTypes = [\"wam-automation\", \"wam-transport\", \"wam-midi\", \"wam-sysex\", \"wam-mpe\", \"wam-osc\", \"wam-info\"];\n      wamEventTypes.forEach((type, encodedType) => {\n        let byteSize = 0;\n        switch (type) {\n          case \"wam-automation\":\n            byteSize = WamEventRingBuffer2.WamAutomationEventBytes;\n            break;\n          case \"wam-transport\":\n            byteSize = WamEventRingBuffer2.WamTransportEventBytes;\n            break;\n          case \"wam-mpe\":\n          case \"wam-midi\":\n            byteSize = WamEventRingBuffer2.WamMidiEventBytes;\n            break;\n          case \"wam-osc\":\n          case \"wam-sysex\":\n          case \"wam-info\":\n            byteSize = WamEventRingBuffer2.WamBinaryEventBytes;\n            break;\n          default:\n            break;\n        }\n        this._eventSizeBytes[type] = byteSize;\n        this._encodeEventType[type] = encodedType;\n        this._decodeEventType[encodedType] = type;\n      });\n      this._parameterCode = 0;\n      this._parameterCodes = {};\n      this._encodeParameterId = {};\n      this._decodeParameterId = {};\n      this.setParameterIds(parameterIds);\n      this._sab = sab;\n      if (maxBytesPerEvent === void 0)\n        maxBytesPerEvent = WamEventRingBuffer2.DefaultExtraBytesPerEvent;\n      else\n        maxBytesPerEvent = Math.max(maxBytesPerEvent, WamEventRingBuffer2.DefaultExtraBytesPerEvent);\n      this._eventBytesAvailable = Math.max(WamEventRingBuffer2.WamAutomationEventBytes, WamEventRingBuffer2.WamTransportEventBytes, WamEventRingBuffer2.WamMidiEventBytes, WamEventRingBuffer2.WamBinaryEventBytes) + maxBytesPerEvent;\n      this._eventBytes = new ArrayBuffer(this._eventBytesAvailable);\n      this._eventBytesView = new DataView(this._eventBytes);\n      this._rb = new RingBuffer2(this._sab, Uint8Array);\n      this._eventSizeArray = new Uint8Array(this._eventBytes, 0, 4);\n      this._eventSizeView = new DataView(this._eventBytes, 0, 4);\n    }\n    _writeHeader(byteSize, type, time) {\n      let byteOffset = 0;\n      this._eventBytesView.setUint32(byteOffset, byteSize);\n      byteOffset += 4;\n      this._eventBytesView.setUint8(byteOffset, this._encodeEventType[type]);\n      byteOffset += 1;\n      this._eventBytesView.setFloat64(byteOffset, Number.isFinite(time) ? time : -1);\n      byteOffset += 8;\n      return byteOffset;\n    }\n    _encode(event) {\n      let byteOffset = 0;\n      const { type, time } = event;\n      switch (event.type) {\n        case \"wam-automation\":\n          {\n            if (!(event.data.id in this._encodeParameterId))\n              break;\n            const byteSize = this._eventSizeBytes[type];\n            byteOffset = this._writeHeader(byteSize, type, time);\n            const { data } = event;\n            const encodedParameterId = this._encodeParameterId[data.id];\n            const { value, normalized } = data;\n            this._eventBytesView.setUint16(byteOffset, encodedParameterId);\n            byteOffset += 2;\n            this._eventBytesView.setFloat64(byteOffset, value);\n            byteOffset += 8;\n            this._eventBytesView.setUint8(byteOffset, normalized ? 1 : 0);\n            byteOffset += 1;\n          }\n          break;\n        case \"wam-transport\":\n          {\n            const byteSize = this._eventSizeBytes[type];\n            byteOffset = this._writeHeader(byteSize, type, time);\n            const { data } = event;\n            const {\n              currentBar,\n              currentBarStarted,\n              tempo,\n              timeSigNumerator,\n              timeSigDenominator,\n              playing\n            } = data;\n            this._eventBytesView.setUint32(byteOffset, currentBar);\n            byteOffset += 4;\n            this._eventBytesView.setFloat64(byteOffset, currentBarStarted);\n            byteOffset += 8;\n            this._eventBytesView.setFloat64(byteOffset, tempo);\n            byteOffset += 8;\n            this._eventBytesView.setUint8(byteOffset, timeSigNumerator);\n            byteOffset += 1;\n            this._eventBytesView.setUint8(byteOffset, timeSigDenominator);\n            byteOffset += 1;\n            this._eventBytesView.setUint8(byteOffset, playing ? 1 : 0);\n            byteOffset += 1;\n          }\n          break;\n        case \"wam-mpe\":\n        case \"wam-midi\":\n          {\n            const byteSize = this._eventSizeBytes[type];\n            byteOffset = this._writeHeader(byteSize, type, time);\n            const { data } = event;\n            const { bytes } = data;\n            let b = 0;\n            while (b < 3) {\n              this._eventBytesView.setUint8(byteOffset, bytes[b]);\n              byteOffset += 1;\n              b++;\n            }\n          }\n          break;\n        case \"wam-osc\":\n        case \"wam-sysex\":\n        case \"wam-info\":\n          {\n            let bytes = null;\n            if (event.type === \"wam-info\") {\n              const { data } = event;\n              bytes = new TextEncoder().encode(data.instanceId);\n            } else {\n              const { data } = event;\n              bytes = data.bytes;\n            }\n            const numBytes = bytes.length;\n            const byteSize = this._eventSizeBytes[type];\n            byteOffset = this._writeHeader(byteSize + numBytes, type, time);\n            this._eventBytesView.setUint32(byteOffset, numBytes);\n            byteOffset += 4;\n            const bytesRequired = byteOffset + numBytes;\n            if (bytesRequired > this._eventBytesAvailable)\n              console.error(`Event requires ${bytesRequired} bytes but only ${this._eventBytesAvailable} have been allocated!`);\n            const buffer = new Uint8Array(this._eventBytes, byteOffset, numBytes);\n            buffer.set(bytes);\n            byteOffset += numBytes;\n          }\n          break;\n        default:\n          break;\n      }\n      return new Uint8Array(this._eventBytes, 0, byteOffset);\n    }\n    _decode() {\n      let byteOffset = 0;\n      const type = this._decodeEventType[this._eventBytesView.getUint8(byteOffset)];\n      byteOffset += 1;\n      let time = this._eventBytesView.getFloat64(byteOffset);\n      if (time === -1)\n        time = void 0;\n      byteOffset += 8;\n      switch (type) {\n        case \"wam-automation\": {\n          const encodedParameterId = this._eventBytesView.getUint16(byteOffset);\n          byteOffset += 2;\n          const value = this._eventBytesView.getFloat64(byteOffset);\n          byteOffset += 8;\n          const normalized = !!this._eventBytesView.getUint8(byteOffset);\n          byteOffset += 1;\n          if (!(encodedParameterId in this._decodeParameterId))\n            break;\n          const id = this._decodeParameterId[encodedParameterId];\n          const event = {\n            type,\n            time,\n            data: {\n              id,\n              value,\n              normalized\n            }\n          };\n          return event;\n        }\n        case \"wam-transport\": {\n          const currentBar = this._eventBytesView.getUint32(byteOffset);\n          byteOffset += 4;\n          const currentBarStarted = this._eventBytesView.getFloat64(byteOffset);\n          byteOffset += 8;\n          const tempo = this._eventBytesView.getFloat64(byteOffset);\n          byteOffset += 8;\n          const timeSigNumerator = this._eventBytesView.getUint8(byteOffset);\n          byteOffset += 1;\n          const timeSigDenominator = this._eventBytesView.getUint8(byteOffset);\n          byteOffset += 1;\n          const playing = this._eventBytesView.getUint8(byteOffset) == 1;\n          byteOffset += 1;\n          const event = {\n            type,\n            time,\n            data: {\n              currentBar,\n              currentBarStarted,\n              tempo,\n              timeSigNumerator,\n              timeSigDenominator,\n              playing\n            }\n          };\n          return event;\n        }\n        case \"wam-mpe\":\n        case \"wam-midi\": {\n          const bytes = [0, 0, 0];\n          let b = 0;\n          while (b < 3) {\n            bytes[b] = this._eventBytesView.getUint8(byteOffset);\n            byteOffset += 1;\n            b++;\n          }\n          const event = {\n            type,\n            time,\n            data: { bytes }\n          };\n          return event;\n        }\n        case \"wam-osc\":\n        case \"wam-sysex\":\n        case \"wam-info\": {\n          const numBytes = this._eventBytesView.getUint32(byteOffset);\n          byteOffset += 4;\n          const bytes = new Uint8Array(numBytes);\n          bytes.set(new Uint8Array(this._eventBytes, byteOffset, numBytes));\n          byteOffset += numBytes;\n          if (type === \"wam-info\") {\n            const instanceId = new TextDecoder().decode(bytes);\n            const data = { instanceId };\n            return { type, time, data };\n          } else {\n            const data = { bytes };\n            return { type, time, data };\n          }\n        }\n        default:\n          break;\n      }\n      return false;\n    }\n    write(...events) {\n      const numEvents = events.length;\n      let bytesAvailable = this._rb.availableWrite;\n      let numSkipped = 0;\n      let i = 0;\n      while (i < numEvents) {\n        const event = events[i];\n        const bytes = this._encode(event);\n        const eventSizeBytes = bytes.byteLength;\n        let bytesWritten = 0;\n        if (bytesAvailable >= eventSizeBytes) {\n          if (eventSizeBytes === 0)\n            numSkipped++;\n          else\n            bytesWritten = this._rb.push(bytes);\n        } else\n          break;\n        bytesAvailable -= bytesWritten;\n        i++;\n      }\n      return i - numSkipped;\n    }\n    read() {\n      if (this._rb.empty)\n        return [];\n      const events = [];\n      let bytesAvailable = this._rb.availableRead;\n      let bytesRead = 0;\n      while (bytesAvailable > 0) {\n        bytesRead = this._rb.pop(this._eventSizeArray);\n        bytesAvailable -= bytesRead;\n        const eventSizeBytes = this._eventSizeView.getUint32(0);\n        const eventBytes = new Uint8Array(this._eventBytes, 0, eventSizeBytes - 4);\n        bytesRead = this._rb.pop(eventBytes);\n        bytesAvailable -= bytesRead;\n        const decodedEvent = this._decode();\n        if (decodedEvent)\n          events.push(decodedEvent);\n      }\n      return events;\n    }\n    setParameterIds(parameterIds) {\n      this._encodeParameterId = {};\n      this._decodeParameterId = {};\n      parameterIds.forEach((parameterId) => {\n        let parameterCode = -1;\n        if (parameterId in this._parameterCodes)\n          parameterCode = this._parameterCodes[parameterId];\n        else {\n          parameterCode = this._generateParameterCode();\n          this._parameterCodes[parameterId] = parameterCode;\n        }\n        this._encodeParameterId[parameterId] = parameterCode;\n        this._decodeParameterId[parameterCode] = parameterId;\n      });\n    }\n    _generateParameterCode() {\n      if (this._parameterCode > 65535)\n        throw Error(\"Too many parameters have been registered!\");\n      return this._parameterCode++;\n    }\n  }\n  if (audioWorkletGlobalScope.AudioWorkletProcessor) {\n    const ModuleScope = audioWorkletGlobalScope.webAudioModules.getModuleScope(moduleId);\n    if (!ModuleScope.WamEventRingBuffer)\n      ModuleScope.WamEventRingBuffer = WamEventRingBuffer2;\n  }\n  return WamEventRingBuffer2;\n};\nvar WamEventRingBuffer_default = getWamEventRingBuffer;\n\n// src/addFunctionModule.js\nvar addFunctionModule = (audioWorklet, processorFunction, ...injection) => {\n  const text = `(${processorFunction.toString()})(${injection.map((s) => JSON.stringify(s)).join(\", \")});`;\n  const url = URL.createObjectURL(new Blob([text], { type: \"text/javascript\" }));\n  return audioWorklet.addModule(url);\n};\nvar addFunctionModule_default = addFunctionModule;\n\n// src/WamParameter.js\nvar getWamParameter = (moduleId) => {\n  const audioWorkletGlobalScope = globalThis;\n  class WamParameter {\n    constructor(info) {\n      this.info = info;\n      this._value = info.defaultValue;\n    }\n    set value(value) {\n      this._value = value;\n    }\n    get value() {\n      return this._value;\n    }\n    set normalizedValue(valueNorm) {\n      this.value = this.info.denormalize(valueNorm);\n    }\n    get normalizedValue() {\n      return this.info.normalize(this.value);\n    }\n  }\n  if (audioWorkletGlobalScope.AudioWorkletProcessor) {\n    const ModuleScope = audioWorkletGlobalScope.webAudioModules.getModuleScope(moduleId);\n    if (!ModuleScope.WamParameter)\n      ModuleScope.WamParameter = WamParameter;\n  }\n  return WamParameter;\n};\nvar WamParameter_default = getWamParameter;\n\n// src/WamParameterInfo.js\nvar getWamParameterInfo = (moduleId) => {\n  const audioWorkletGlobalScope = globalThis;\n  const normExp = (x, e) => e === 0 ? x : x ** 1.5 ** -e;\n  const denormExp = (x, e) => e === 0 ? x : x ** 1.5 ** e;\n  const normalize = (x, min, max, e = 0) => min === 0 && max === 1 ? normExp(x, e) : normExp((x - min) / (max - min) || 0, e);\n  const denormalize = (x, min, max, e = 0) => min === 0 && max === 1 ? denormExp(x, e) : denormExp(x, e) * (max - min) + min;\n  const inRange = (x, min, max) => x >= min && x <= max;\n  class WamParameterInfo {\n    constructor(id, config = {}) {\n      let {\n        type,\n        label,\n        defaultValue,\n        minValue,\n        maxValue,\n        discreteStep,\n        exponent,\n        choices,\n        units\n      } = config;\n      if (type === void 0)\n        type = \"float\";\n      if (label === void 0)\n        label = \"\";\n      if (defaultValue === void 0)\n        defaultValue = 0;\n      if (choices === void 0)\n        choices = [];\n      if (type === \"boolean\" || type === \"choice\") {\n        discreteStep = 1;\n        minValue = 0;\n        if (choices.length)\n          maxValue = choices.length - 1;\n        else\n          maxValue = 1;\n      } else {\n        if (minValue === void 0)\n          minValue = 0;\n        if (maxValue === void 0)\n          maxValue = 1;\n        if (discreteStep === void 0)\n          discreteStep = 0;\n        if (exponent === void 0)\n          exponent = 0;\n        if (units === void 0)\n          units = \"\";\n      }\n      const errBase = `Param config error | ${id}: `;\n      if (minValue >= maxValue)\n        throw Error(errBase.concat(\"minValue must be less than maxValue\"));\n      if (!inRange(defaultValue, minValue, maxValue))\n        throw Error(errBase.concat(\"defaultValue out of range\"));\n      if (discreteStep % 1 || discreteStep < 0) {\n        throw Error(errBase.concat(\"discreteStep must be a non-negative integer\"));\n      } else if (discreteStep > 0 && (minValue % 1 || maxValue % 1 || defaultValue % 1)) {\n        throw Error(errBase.concat(\"non-zero discreteStep requires integer minValue, maxValue, and defaultValue\"));\n      }\n      if (type === \"choice\" && !choices.length) {\n        throw Error(errBase.concat(\"choice type parameter requires list of strings in choices\"));\n      }\n      this.id = id;\n      this.label = label;\n      this.type = type;\n      this.defaultValue = defaultValue;\n      this.minValue = minValue;\n      this.maxValue = maxValue;\n      this.discreteStep = discreteStep;\n      this.exponent = exponent;\n      this.choices = choices;\n      this.units = units;\n    }\n    normalize(value) {\n      return normalize(value, this.minValue, this.maxValue, this.exponent);\n    }\n    denormalize(valueNorm) {\n      return denormalize(valueNorm, this.minValue, this.maxValue, this.exponent);\n    }\n    valueString(value) {\n      if (this.choices)\n        return this.choices[value];\n      if (this.units !== \"\")\n        return `${value} ${this.units}`;\n      return `${value}`;\n    }\n  }\n  if (audioWorkletGlobalScope.AudioWorkletProcessor) {\n    const ModuleScope = audioWorkletGlobalScope.webAudioModules.getModuleScope(moduleId);\n    if (!ModuleScope.WamParameterInfo)\n      ModuleScope.WamParameterInfo = WamParameterInfo;\n  }\n  return WamParameterInfo;\n};\nvar WamParameterInfo_default = getWamParameterInfo;\n\n// src/WamParameterInterpolator.js\nvar getWamParameterInterpolator = (moduleId) => {\n  const audioWorkletGlobalScope = globalThis;\n  const samplesPerQuantum = 128;\n  const nullTableKey = \"0_0\";\n  class WamParameterInterpolator {\n    static _tables;\n    static _tableReferences;\n    constructor(info, samplesPerInterpolation, skew = 0) {\n      if (!WamParameterInterpolator._tables) {\n        WamParameterInterpolator._tables = { nullTableKey: new Float32Array(0) };\n        WamParameterInterpolator._tableReferences = { nullTableKey: [] };\n      }\n      this.info = info;\n      this.values = new Float32Array(samplesPerQuantum);\n      this._tableKey = nullTableKey;\n      this._table = WamParameterInterpolator._tables[this._tableKey];\n      this._skew = 2;\n      const { discreteStep } = info;\n      this._discrete = !!discreteStep;\n      this._N = this._discrete ? 0 : samplesPerInterpolation;\n      this._n = 0;\n      this._startValue = info.defaultValue;\n      this._endValue = info.defaultValue;\n      this._currentValue = info.defaultValue;\n      this._deltaValue = 0;\n      this._inverted = false;\n      this._changed = true;\n      this._filled = 0;\n      if (!this._discrete)\n        this.setSkew(skew);\n      else\n        this._skew = 0;\n      this.setStartValue(this._startValue);\n    }\n    _removeTableReference(oldKey) {\n      if (oldKey === nullTableKey)\n        return;\n      const { id } = this.info;\n      const references = WamParameterInterpolator._tableReferences[oldKey];\n      if (references) {\n        const index = references.indexOf(id);\n        if (index !== -1)\n          references.splice(index, 1);\n        if (references.length === 0) {\n          delete WamParameterInterpolator._tables[oldKey];\n          delete WamParameterInterpolator._tableReferences[oldKey];\n        }\n      }\n    }\n    setSkew(skew) {\n      if (this._skew === skew || this._discrete)\n        return;\n      if (skew < -1 || skew > 1)\n        throw Error(\"skew must be in range [-1.0, 1.0]\");\n      const newKey = [this._N, skew].join(\"_\");\n      const oldKey = this._tableKey;\n      const { id } = this.info;\n      if (newKey === oldKey)\n        return;\n      if (WamParameterInterpolator._tables[newKey]) {\n        const references = WamParameterInterpolator._tableReferences[newKey];\n        if (references)\n          references.push(id);\n        else\n          WamParameterInterpolator._tableReferences[newKey] = [id];\n      } else {\n        let e = Math.abs(skew);\n        e = Math.pow(3 - e, e * (e + 2));\n        const linear = e === 1;\n        const N = this._N;\n        const table = new Float32Array(N + 1);\n        if (linear)\n          for (let n = 0; n <= N; ++n)\n            table[n] = n / N;\n        else\n          for (let n = 0; n <= N; ++n)\n            table[n] = (n / N) ** e;\n        WamParameterInterpolator._tables[newKey] = table;\n        WamParameterInterpolator._tableReferences[newKey] = [id];\n      }\n      this._removeTableReference(oldKey);\n      this._skew = skew;\n      this._tableKey = newKey;\n      this._table = WamParameterInterpolator._tables[this._tableKey];\n    }\n    setStartValue(value, fill = true) {\n      this._n = this._N;\n      this._startValue = value;\n      this._endValue = value;\n      this._currentValue = value;\n      this._deltaValue = 0;\n      this._inverted = false;\n      if (fill) {\n        this.values.fill(value);\n        this._changed = true;\n        this._filled = this.values.length;\n      } else {\n        this._changed = false;\n        this._filled = 0;\n      }\n    }\n    setEndValue(value) {\n      if (value === this._endValue)\n        return;\n      this._n = 0;\n      this._startValue = this._currentValue;\n      this._endValue = value;\n      this._deltaValue = this._endValue - this._startValue;\n      this._inverted = this._deltaValue > 0 && this._skew >= 0 || this._deltaValue <= 0 && this._skew < 0;\n      this._changed = false;\n      this._filled = 0;\n    }\n    process(startSample, endSample) {\n      if (this.done)\n        return;\n      const length = endSample - startSample;\n      let fill = 0;\n      const change = this._N - this._n;\n      if (this._discrete || !change)\n        fill = length;\n      else {\n        if (change < length) {\n          fill = Math.min(length - change, samplesPerQuantum);\n          endSample -= fill;\n        }\n        if (endSample > startSample) {\n          if (this._inverted) {\n            for (let i = startSample; i < endSample; ++i) {\n              const tableValue = 1 - this._table[this._N - ++this._n];\n              this.values[i] = this._startValue + tableValue * this._deltaValue;\n            }\n          } else {\n            for (let i = startSample; i < endSample; ++i) {\n              const tableValue = this._table[++this._n];\n              this.values[i] = this._startValue + tableValue * this._deltaValue;\n            }\n          }\n        }\n        if (fill > 0) {\n          startSample = endSample;\n          endSample += fill;\n        }\n      }\n      if (fill > 0) {\n        this.values.fill(this._endValue, startSample, endSample);\n        this._filled += fill;\n      }\n      this._currentValue = this.values[endSample - 1];\n      if (this._n === this._N) {\n        if (!this._changed)\n          this._changed = true;\n        else if (this._filled >= this.values.length) {\n          this.setStartValue(this._endValue, false);\n          this._changed = true;\n          this._filled = this.values.length;\n        }\n      }\n    }\n    get done() {\n      return this._changed && this._filled === this.values.length;\n    }\n    is(value) {\n      return this._endValue === value && this.done;\n    }\n    destroy() {\n      this._removeTableReference(this._tableKey);\n    }\n  }\n  if (audioWorkletGlobalScope.AudioWorkletProcessor) {\n    const ModuleScope = audioWorkletGlobalScope.webAudioModules.getModuleScope(moduleId);\n    if (!ModuleScope.WamParameterInterpolator)\n      ModuleScope.WamParameterInterpolator = WamParameterInterpolator;\n  }\n  return WamParameterInterpolator;\n};\nvar WamParameterInterpolator_default = getWamParameterInterpolator;\n\n// src/WamProcessor.js\nvar getWamProcessor = (moduleId) => {\n  const audioWorkletGlobalScope = globalThis;\n  const {\n    AudioWorkletProcessor,\n    webAudioModules\n  } = audioWorkletGlobalScope;\n  const ModuleScope = audioWorkletGlobalScope.webAudioModules.getModuleScope(moduleId);\n  const {\n    RingBuffer: RingBuffer2,\n    WamEventRingBuffer: WamEventRingBuffer2,\n    WamParameter,\n    WamParameterInterpolator\n  } = ModuleScope;\n  class WamProcessor extends AudioWorkletProcessor {\n    constructor(options) {\n      super(options);\n      const {\n        groupId,\n        moduleId: moduleId2,\n        instanceId,\n        useSab\n      } = options.processorOptions;\n      if (!moduleId2)\n        throw Error(\"must provide moduleId argument in processorOptions!\");\n      if (!instanceId)\n        throw Error(\"must provide instanceId argument in processorOptions!\");\n      this.groupId = groupId;\n      this.moduleId = moduleId2;\n      this.instanceId = instanceId;\n      this._samplesPerQuantum = 128;\n      this._compensationDelay = 0;\n      this._parameterInfo = {};\n      this._parameterState = {};\n      this._parameterInterpolators = {};\n      this._eventQueue = [];\n      this._pendingResponses = {};\n      this._useSab = !!useSab && !!globalThis.SharedArrayBuffer;\n      this._eventSabReady = false;\n      this._audioToMainEventSab = null;\n      this._mainToAudioEventSab = null;\n      this._eventWriter = null;\n      this._eventReader = null;\n      this._initialized = false;\n      this._destroyed = false;\n      webAudioModules.addWam(this);\n      this.port.onmessage = this._onMessage.bind(this);\n      if (this._useSab)\n        this._configureSab();\n    }\n    getCompensationDelay() {\n      return this._compensationDelay;\n    }\n    scheduleEvents(...events) {\n      let i = 0;\n      while (i < events.length) {\n        this._eventQueue.push({ id: 0, event: events[i] });\n        i++;\n      }\n    }\n    emitEvents(...events) {\n      webAudioModules.emitEvents(this, ...events);\n    }\n    clearEvents() {\n      this._eventQueue = [];\n    }\n    process(inputs, outputs, parameters) {\n      if (!this._initialized)\n        return true;\n      if (this._destroyed)\n        return false;\n      if (this._eventSabReady)\n        this.scheduleEvents(...this._eventReader.read());\n      const processingSlices = this._getProcessingSlices();\n      let i = 0;\n      while (i < processingSlices.length) {\n        const { range, events } = processingSlices[i];\n        const [startSample, endSample] = range;\n        let j = 0;\n        while (j < events.length) {\n          this._processEvent(events[j]);\n          j++;\n        }\n        this._interpolateParameterValues(startSample, endSample);\n        this._process(startSample, endSample, inputs, outputs, parameters);\n        i++;\n      }\n      return true;\n    }\n    destroy() {\n      this._destroyed = true;\n      this.port.close();\n      webAudioModules.removeWam(this);\n    }\n    _generateWamParameterInfo() {\n      return {};\n    }\n    _initialize() {\n      this._parameterState = {};\n      this._parameterInterpolators = {};\n      this._parameterInfo = this._generateWamParameterInfo();\n      Object.keys(this._parameterInfo).forEach((parameterId) => {\n        const info = this._parameterInfo[parameterId];\n        this._parameterState[parameterId] = new WamParameter(this._parameterInfo[parameterId]);\n        this._parameterInterpolators[parameterId] = new WamParameterInterpolator(info, 256);\n      });\n    }\n    _configureSab() {\n      const eventCapacity = 2 ** 10;\n      const parameterIds = Object.keys(this._parameterInfo);\n      if (this._eventSabReady) {\n        this._eventWriter.setParameterIds(parameterIds);\n        this._eventReader.setParameterIds(parameterIds);\n      }\n      this.port.postMessage({ eventSab: { eventCapacity, parameterIds } });\n    }\n    async _onMessage(message) {\n      if (message.data.request) {\n        const {\n          id,\n          request,\n          content\n        } = message.data;\n        const response = { id, response: request };\n        const requestComponents = request.split(\"/\");\n        const verb = requestComponents[0];\n        const noun = requestComponents[1];\n        response.content = \"error\";\n        if (verb === \"get\") {\n          if (noun === \"parameterInfo\") {\n            let { parameterIds } = content;\n            if (!parameterIds.length)\n              parameterIds = Object.keys(this._parameterInfo);\n            const parameterInfo = {};\n            let i = 0;\n            while (i < parameterIds.length) {\n              const parameterId = parameterIds[i];\n              parameterInfo[parameterId] = this._parameterInfo[parameterId];\n              i++;\n            }\n            response.content = parameterInfo;\n          } else if (noun === \"parameterValues\") {\n            let { normalized, parameterIds } = content;\n            response.content = this._getParameterValues(normalized, parameterIds);\n          } else if (noun === \"state\") {\n            response.content = this._getState();\n          } else if (noun === \"compensationDelay\") {\n            response.content = this.getCompensationDelay();\n          }\n        } else if (verb === \"set\") {\n          if (noun === \"parameterValues\") {\n            const { parameterValues } = content;\n            this._setParameterValues(parameterValues, true);\n            delete response.content;\n          } else if (noun === \"state\") {\n            const { state } = content;\n            this._setState(state);\n            delete response.content;\n          }\n        } else if (verb === \"add\") {\n          if (noun === \"event\") {\n            const { event } = content;\n            this._eventQueue.push({ id, event });\n            return;\n          }\n        } else if (verb === \"remove\") {\n          if (noun === \"events\") {\n            const ids = this._eventQueue.map((queued) => queued.id);\n            this.clearEvents();\n            response.content = ids;\n          }\n        } else if (verb === \"connect\") {\n          if (noun === \"events\") {\n            const { wamInstanceId, output } = content;\n            this._connectEvents(wamInstanceId, output);\n            delete response.content;\n          }\n        } else if (verb === \"disconnect\") {\n          if (noun === \"events\") {\n            const { wamInstanceId, output } = content;\n            this._disconnectEvents(wamInstanceId, output);\n            delete response.content;\n          }\n        } else if (verb === \"initialize\") {\n          if (noun === \"processor\") {\n            this._initialize();\n            this._initialized = true;\n            delete response.content;\n          } else if (noun === \"eventSab\") {\n            const { mainToAudioEventSab, audioToMainEventSab } = content;\n            this._audioToMainEventSab = audioToMainEventSab;\n            this._mainToAudioEventSab = mainToAudioEventSab;\n            const parameterIds = Object.keys(this._parameterInfo);\n            this._eventWriter = new WamEventRingBuffer2(RingBuffer2, this._audioToMainEventSab, parameterIds);\n            this._eventReader = new WamEventRingBuffer2(RingBuffer2, this._mainToAudioEventSab, parameterIds);\n            this._eventSabReady = true;\n            delete response.content;\n          }\n        }\n        this.port.postMessage(response);\n      } else if (message.data.destroy) {\n        this.destroy();\n      }\n    }\n    _onTransport(transportData) {\n      console.error(\"_onTransport not implemented!\");\n    }\n    _onMidi(midiData) {\n      console.error(\"_onMidi not implemented!\");\n    }\n    _onSysex(sysexData) {\n      console.error(\"_onMidi not implemented!\");\n    }\n    _onMpe(mpeData) {\n      console.error(\"_onMpe not implemented!\");\n    }\n    _onOsc(oscData) {\n      console.error(\"_onOsc not implemented!\");\n    }\n    _setState(state) {\n      if (state.parameterValues)\n        this._setParameterValues(state.parameterValues, false);\n    }\n    _getState() {\n      return { parameterValues: this._getParameterValues(false) };\n    }\n    _getParameterValues(normalized, parameterIds) {\n      const parameterValues = {};\n      if (!parameterIds || !parameterIds.length)\n        parameterIds = Object.keys(this._parameterState);\n      let i = 0;\n      while (i < parameterIds.length) {\n        const id = parameterIds[i];\n        const parameter = this._parameterState[id];\n        parameterValues[id] = {\n          id,\n          value: normalized ? parameter.normalizedValue : parameter.value,\n          normalized\n        };\n        i++;\n      }\n      return parameterValues;\n    }\n    _setParameterValues(parameterUpdates, interpolate) {\n      const parameterIds = Object.keys(parameterUpdates);\n      let i = 0;\n      while (i < parameterIds.length) {\n        this._setParameterValue(parameterUpdates[parameterIds[i]], interpolate);\n        i++;\n      }\n    }\n    _setParameterValue(parameterUpdate, interpolate) {\n      const { id, value, normalized } = parameterUpdate;\n      const parameter = this._parameterState[id];\n      if (!parameter)\n        return;\n      if (!normalized)\n        parameter.value = value;\n      else\n        parameter.normalizedValue = value;\n      const interpolator = this._parameterInterpolators[id];\n      if (interpolate)\n        interpolator.setEndValue(parameter.value);\n      else\n        interpolator.setStartValue(parameter.value);\n    }\n    _interpolateParameterValues(startIndex, endIndex) {\n      const parameterIds = Object.keys(this._parameterInterpolators);\n      let i = 0;\n      while (i < parameterIds.length) {\n        this._parameterInterpolators[parameterIds[i]].process(startIndex, endIndex);\n        i++;\n      }\n    }\n    _connectEvents(wamInstanceId, output) {\n      webAudioModules.connectEvents(this.groupId, this.instanceId, wamInstanceId, output);\n    }\n    _disconnectEvents(wamInstanceId, output) {\n      if (typeof wamInstanceId === \"undefined\") {\n        webAudioModules.disconnectEvents(this.groupId, this.instanceId);\n        return;\n      }\n      webAudioModules.disconnectEvents(this.groupId, this.instanceId, wamInstanceId, output);\n    }\n    _getProcessingSlices() {\n      const response = \"add/event\";\n      const { currentTime, sampleRate } = audioWorkletGlobalScope;\n      const eventsBySampleIndex = {};\n      let i = 0;\n      while (i < this._eventQueue.length) {\n        const { id, event } = this._eventQueue[i];\n        const offsetSec = event.time - currentTime;\n        const sampleIndex = offsetSec > 0 ? Math.round(offsetSec * sampleRate) : 0;\n        if (sampleIndex < this._samplesPerQuantum) {\n          if (eventsBySampleIndex[sampleIndex])\n            eventsBySampleIndex[sampleIndex].push(event);\n          else\n            eventsBySampleIndex[sampleIndex] = [event];\n          if (id)\n            this.port.postMessage({ id, response });\n          else if (this._eventSabReady)\n            this._eventWriter.write(event);\n          else\n            this.port.postMessage({ event });\n          this._eventQueue.shift();\n          i = -1;\n        } else\n          break;\n        i++;\n      }\n      const processingSlices = [];\n      const keys = Object.keys(eventsBySampleIndex);\n      if (keys[0] !== \"0\") {\n        keys.unshift(\"0\");\n        eventsBySampleIndex[\"0\"] = [];\n      }\n      const lastIndex = keys.length - 1;\n      i = 0;\n      while (i < keys.length) {\n        const key = keys[i];\n        const startSample = parseInt(key);\n        const endSample = i < lastIndex ? parseInt(keys[i + 1]) : this._samplesPerQuantum;\n        processingSlices.push({ range: [startSample, endSample], events: eventsBySampleIndex[key] });\n        i++;\n      }\n      return processingSlices;\n    }\n    _processEvent(event) {\n      switch (event.type) {\n        case \"wam-automation\":\n          this._setParameterValue(event.data, true);\n          break;\n        case \"wam-transport\":\n          this._onTransport(event.data);\n          break;\n        case \"wam-midi\":\n          this._onMidi(event.data);\n          break;\n        case \"wam-sysex\":\n          this._onSysex(event.data);\n          break;\n        case \"wam-mpe\":\n          this._onMpe(event.data);\n          break;\n        case \"wam-osc\":\n          this._onOsc(event.data);\n          break;\n        default:\n          break;\n      }\n    }\n    _process(startSample, endSample, inputs, outputs, parameters) {\n      console.error(\"_process not implemented!\");\n    }\n  }\n  if (audioWorkletGlobalScope.AudioWorkletProcessor) {\n    if (!ModuleScope.WamProcessor)\n      ModuleScope.WamProcessor = WamProcessor;\n  }\n  return WamProcessor;\n};\nvar WamProcessor_default = getWamProcessor;\n\n// src/WamNode.js\nvar RingBuffer = RingBuffer_default();\nvar WamEventRingBuffer = WamEventRingBuffer_default();\nvar WamNode = class extends AudioWorkletNode {\n  static async addModules(audioContext, moduleId) {\n    const { audioWorklet } = audioContext;\n    await addFunctionModule_default(audioWorklet, RingBuffer_default, moduleId);\n    await addFunctionModule_default(audioWorklet, WamEventRingBuffer_default, moduleId);\n    await addFunctionModule_default(audioWorklet, WamArrayRingBuffer_default, moduleId);\n    await addFunctionModule_default(audioWorklet, WamParameter_default, moduleId);\n    await addFunctionModule_default(audioWorklet, WamParameterInfo_default, moduleId);\n    await addFunctionModule_default(audioWorklet, WamParameterInterpolator_default, moduleId);\n    await addFunctionModule_default(audioWorklet, WamProcessor_default, moduleId);\n  }\n  constructor(module, options) {\n    const { audioContext, groupId, moduleId, instanceId } = module;\n    options.processorOptions = {\n      groupId,\n      moduleId,\n      instanceId,\n      ...options.processorOptions\n    };\n    super(audioContext, moduleId, options);\n    this.module = module;\n    this._supportedEventTypes = /* @__PURE__ */ new Set([\"wam-automation\", \"wam-transport\", \"wam-midi\", \"wam-sysex\", \"wam-mpe\", \"wam-osc\"]);\n    this._messageId = 1;\n    this._pendingResponses = {};\n    this._pendingEvents = {};\n    this._useSab = false;\n    this._eventSabReady = false;\n    this._destroyed = false;\n    this.port.onmessage = this._onMessage.bind(this);\n  }\n  get groupId() {\n    return this.module.groupId;\n  }\n  get moduleId() {\n    return this.module.moduleId;\n  }\n  get instanceId() {\n    return this.module.instanceId;\n  }\n  async getParameterInfo(...parameterIds) {\n    const request = \"get/parameterInfo\";\n    const id = this._generateMessageId();\n    return new Promise((resolve) => {\n      this._pendingResponses[id] = resolve;\n      this.port.postMessage({\n        id,\n        request,\n        content: { parameterIds }\n      });\n    });\n  }\n  async getParameterValues(normalized, ...parameterIds) {\n    const request = \"get/parameterValues\";\n    const id = this._generateMessageId();\n    return new Promise((resolve) => {\n      this._pendingResponses[id] = resolve;\n      this.port.postMessage({\n        id,\n        request,\n        content: { normalized, parameterIds }\n      });\n    });\n  }\n  async setParameterValues(parameterValues) {\n    const request = \"set/parameterValues\";\n    const id = this._generateMessageId();\n    return new Promise((resolve) => {\n      this._pendingResponses[id] = resolve;\n      this.port.postMessage({\n        id,\n        request,\n        content: { parameterValues }\n      });\n    });\n  }\n  async getState() {\n    const request = \"get/state\";\n    const id = this._generateMessageId();\n    return new Promise((resolve) => {\n      this._pendingResponses[id] = resolve;\n      this.port.postMessage({ id, request });\n    });\n  }\n  async setState(state) {\n    const request = \"set/state\";\n    const id = this._generateMessageId();\n    return new Promise((resolve) => {\n      this._pendingResponses[id] = resolve;\n      this.port.postMessage({\n        id,\n        request,\n        content: { state }\n      });\n    });\n  }\n  async getCompensationDelay() {\n    const request = \"get/compensationDelay\";\n    const id = this._generateMessageId();\n    return new Promise((resolve) => {\n      this._pendingResponses[id] = resolve;\n      this.port.postMessage({ id, request });\n    });\n  }\n  addEventListener(type, callback, options) {\n    if (this._supportedEventTypes.has(type))\n      super.addEventListener(type, callback, options);\n  }\n  removeEventListener(type, callback, options) {\n    if (this._supportedEventTypes.has(type))\n      super.removeEventListener(type, callback, options);\n  }\n  scheduleEvents(...events) {\n    let i = 0;\n    const numEvents = events.length;\n    if (this._eventSabReady) {\n      i = this._eventWriter.write(...events);\n    }\n    while (i < numEvents) {\n      const event = events[i];\n      const request = \"add/event\";\n      const id = this._generateMessageId();\n      let processed = false;\n      new Promise((resolve, reject) => {\n        this._pendingResponses[id] = resolve;\n        this._pendingEvents[id] = () => {\n          if (!processed)\n            reject();\n        };\n        this.port.postMessage({\n          id,\n          request,\n          content: { event }\n        });\n      }).then((resolved) => {\n        processed = true;\n        delete this._pendingEvents[id];\n        this._onEvent(event);\n      }).catch((rejected) => {\n        delete this._pendingResponses[id];\n      });\n      i++;\n    }\n  }\n  async clearEvents() {\n    const request = \"remove/events\";\n    const id = this._generateMessageId();\n    return new Promise((resolve) => {\n      const ids = Object.keys(this._pendingEvents);\n      if (ids.length) {\n        this._pendingResponses[id] = resolve;\n        this.port.postMessage({ id, request });\n      }\n    }).then((clearedIds) => {\n      clearedIds.forEach((clearedId) => {\n        this._pendingEvents[clearedId]();\n        delete this._pendingEvents[clearedId];\n      });\n    });\n  }\n  connectEvents(toId, output) {\n    const request = \"connect/events\";\n    const id = this._generateMessageId();\n    new Promise((resolve, reject) => {\n      this._pendingResponses[id] = resolve;\n      this.port.postMessage({\n        id,\n        request,\n        content: { wamInstanceId: toId, output }\n      });\n    });\n  }\n  disconnectEvents(toId, output) {\n    const request = \"disconnect/events\";\n    const id = this._generateMessageId();\n    new Promise((resolve, reject) => {\n      this._pendingResponses[id] = resolve;\n      this.port.postMessage({\n        id,\n        request,\n        content: { wamInstanceId: toId, output }\n      });\n    });\n  }\n  destroy() {\n    if (this._audioToMainInterval)\n      clearInterval(this._audioToMainInterval);\n    this.port.postMessage({ destroy: true });\n    this.port.close();\n    this.disconnect();\n    this._destroyed = true;\n  }\n  _generateMessageId() {\n    return this._messageId++;\n  }\n  async _initialize() {\n    const request = \"initialize/processor\";\n    const id = this._generateMessageId();\n    return new Promise((resolve) => {\n      this._pendingResponses[id] = resolve;\n      this.port.postMessage({ id, request });\n    });\n  }\n  _onMessage(message) {\n    const { data } = message;\n    const { response, event, eventSab } = data;\n    if (response) {\n      const { id, content } = data;\n      const resolvePendingResponse = this._pendingResponses[id];\n      if (resolvePendingResponse) {\n        delete this._pendingResponses[id];\n        resolvePendingResponse(content);\n      }\n    } else if (eventSab) {\n      this._useSab = true;\n      const { eventCapacity, parameterIds } = eventSab;\n      if (this._eventSabReady) {\n        this._eventWriter.setParameterIds(parameterIds);\n        this._eventReader.setParameterIds(parameterIds);\n        return;\n      }\n      this._mainToAudioEventSab = WamEventRingBuffer.getStorageForEventCapacity(RingBuffer, eventCapacity);\n      this._audioToMainEventSab = WamEventRingBuffer.getStorageForEventCapacity(RingBuffer, eventCapacity);\n      this._eventWriter = new WamEventRingBuffer(RingBuffer, this._mainToAudioEventSab, parameterIds);\n      this._eventReader = new WamEventRingBuffer(RingBuffer, this._audioToMainEventSab, parameterIds);\n      const request = \"initialize/eventSab\";\n      const id = this._generateMessageId();\n      new Promise((resolve, reject) => {\n        this._pendingResponses[id] = resolve;\n        this.port.postMessage({\n          id,\n          request,\n          content: {\n            mainToAudioEventSab: this._mainToAudioEventSab,\n            audioToMainEventSab: this._audioToMainEventSab\n          }\n        });\n      }).then((resolved) => {\n        this._eventSabReady = true;\n        this._audioToMainInterval = setInterval(() => {\n          const events = this._eventReader.read();\n          events.forEach((e) => {\n            this._onEvent(e);\n          });\n        }, 100);\n      });\n    } else if (event)\n      this._onEvent(event);\n  }\n  _onEvent(event) {\n    const { type } = event;\n    this.dispatchEvent(new CustomEvent(type, {\n      bubbles: true,\n      detail: event\n    }));\n  }\n};\n\n// src/apiVersion.js\nvar apiVersion_default = \"2.0.0-alpha.3\";\n\n// src/initializeWamHost.js\nvar initializeWamHost = async (audioContext, hostGroupId = `wam-host-${performance.now().toString()}`, hostGroupKey = performance.now().toString()) => {\n  await addFunctionModule_default(audioContext.audioWorklet, WamEnv_default, apiVersion_default);\n  await addFunctionModule_default(audioContext.audioWorklet, WamGroup_default, hostGroupId, hostGroupKey);\n  return [hostGroupId, hostGroupKey];\n};\nvar initializeWamHost_default = initializeWamHost;\nexport {\n  WamNode,\n  WebAudioModule_default as WebAudioModule,\n  addFunctionModule_default as addFunctionModule,\n  apiVersion_default as apiVersion,\n  RingBuffer_default as getRingBuffer,\n  WamArrayRingBuffer_default as getWamArrayRingBuffer,\n  WamEventRingBuffer_default as getWamEventRingBuffer,\n  WamParameter_default as getWamParameter,\n  WamParameterInfo_default as getWamParameterInfo,\n  WamParameterInterpolator_default as getWamParameterInterpolator,\n  WamProcessor_default as getWamProcessor,\n  WamEnv_default as initializeWamEnv,\n  WamGroup_default as initializeWamGroup,\n  initializeWamHost_default as initializeWamHost\n};\n//# sourceMappingURL=index.js.map\n"],"names":[],"sourceRoot":""}