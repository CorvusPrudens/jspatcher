{"version":3,"file":"js/0aa8a692bd71da49dd36.worklet.js","mappings":"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","sources":["webpack://JSPatcher/./src/core/PackageManager.ts","webpack://JSPatcher/./src/core/Project.ts","webpack://JSPatcher/./src/core/TaskMgr.ts","webpack://JSPatcher/./src/core/WorkletGlobalPackageManager.ts","webpack://JSPatcher/./src/core/WorkletSDK.ts","webpack://JSPatcher/./src/core/audio/TempAudioFile.ts","webpack://JSPatcher/./src/core/file/AbstractProjectFile.ts","webpack://JSPatcher/./src/core/file/AbstractProjectFolder.ts","webpack://JSPatcher/./src/core/file/AbstractProjectItem.ts","webpack://JSPatcher/./src/core/file/AbstractProjectItemManager.ts","webpack://JSPatcher/./src/core/file/FileEditor.ts","webpack://JSPatcher/./src/core/file/FileInstance.ts","webpack://JSPatcher/./src/core/file/History.ts","webpack://JSPatcher/./src/core/file/PersistentProjectFile.ts","webpack://JSPatcher/./src/core/file/PersistentProjectFolder.ts","webpack://JSPatcher/./src/core/file/TempData.ts","webpack://JSPatcher/./src/core/file/TemporaryProjectFile.ts","webpack://JSPatcher/./src/core/file/TemporaryProjectFolder.ts","webpack://JSPatcher/./src/core/file/TemporaryProjectItemManager.ts","webpack://JSPatcher/./src/core/file/WorkletProjectItemManager.ts","webpack://JSPatcher/./src/core/objects/base/AbstractObject.ts","webpack://JSPatcher/./src/core/objects/base/Bang.ts","webpack://JSPatcher/./src/core/objects/base/BaseObject.ts","webpack://JSPatcher/./src/core/objects/base/Comment.ts","webpack://JSPatcher/./src/core/objects/base/generateRemotedObject.ts","webpack://JSPatcher/./src/core/objects/base/index.jsdsppkg.aw.ts","webpack://JSPatcher/./src/core/objects/globalThis/index.jsdsppkg.ts","webpack://JSPatcher/./src/core/objects/importer/Func.tsx","webpack://JSPatcher/./src/core/objects/importer/Getter.ts","webpack://JSPatcher/./src/core/objects/importer/ImportedObject.tsx","webpack://JSPatcher/./src/core/objects/importer/Importer.ts","webpack://JSPatcher/./src/core/objects/importer/Method.ts","webpack://JSPatcher/./src/core/objects/importer/New.tsx","webpack://JSPatcher/./src/core/objects/importer/Property.ts","webpack://JSPatcher/./src/core/objects/importer/RemotedImporter.ts","webpack://JSPatcher/./src/core/objects/importer/Setter.ts","webpack://JSPatcher/./src/core/objects/importer/SetterGetter.ts","webpack://JSPatcher/./src/core/objects/importer/StaticGetter.ts","webpack://JSPatcher/./src/core/objects/importer/StaticMethod.ts","webpack://JSPatcher/./src/core/objects/importer/StaticProperty.ts","webpack://JSPatcher/./src/core/objects/importer/StaticSetter.ts","webpack://JSPatcher/./src/core/objects/importer/StaticSetterGetter.ts","webpack://JSPatcher/./src/core/objects/jsaw/AudioIn.ts","webpack://JSPatcher/./src/core/objects/jsaw/AudioOut.ts","webpack://JSPatcher/./src/core/objects/jsaw/In.ts","webpack://JSPatcher/./src/core/objects/jsaw/Out.ts","webpack://JSPatcher/./src/core/objects/jsaw/Param.ts","webpack://JSPatcher/./src/core/objects/jsaw/index.jsdsppkg.aw.ts","webpack://JSPatcher/./src/core/patcher/Box.ts","webpack://JSPatcher/./src/core/patcher/FaustPatcherAnalyser.ts","webpack://JSPatcher/./src/core/patcher/Line.ts","webpack://JSPatcher/./src/core/patcher/Patcher.ts","webpack://JSPatcher/./src/core/patcher/PatcherEditor.ts","webpack://JSPatcher/./src/core/patcher/PatcherHistory.ts","webpack://JSPatcher/./src/core/patcher/TempPatcherFile.ts","webpack://JSPatcher/./src/core/text/TempTextFile.ts","webpack://JSPatcher/./src/core/worklets/AudioWorkletProxyProcessor.ts","webpack://JSPatcher/./src/utils/TypedEventEmitter.ts","webpack://JSPatcher/./src/utils/buffer.ts","webpack://JSPatcher/./src/utils/math.ts","webpack://JSPatcher/./src/utils/symbols.ts","webpack://JSPatcher/./src/utils/utils.ts","webpack://JSPatcher/./src/version.ts","webpack://JSPatcher/webpack/bootstrap","webpack://JSPatcher/webpack/runtime/compat get default export","webpack://JSPatcher/webpack/runtime/define property getters","webpack://JSPatcher/webpack/runtime/ensure chunk","webpack://JSPatcher/webpack/runtime/hasOwnProperty shorthand","webpack://JSPatcher/webpack/runtime/make namespace object","webpack://JSPatcher/webpack/runtime/publicPath","webpack://JSPatcher/./src/core/worklets/WorkletEnv.worklet.ts"],"sourcesContent":["import TypedEventEmitter from \"../utils/TypedEventEmitter\";\nimport { ImporterDirSelfObject } from \"../utils/symbols\";\nimport { isJSPatcherObjectConstructor, IJSPatcherObject } from \"./objects/base/AbstractObject\";\nimport type { TFlatPackage, TPackage } from \"./types\";\nimport type Patcher from \"./patcher/Patcher\";\n\nexport interface PackageManagerEventMap {\n    \"pathDuplicated\": string;\n}\nexport interface PackageInfo {\n    id: string;\n    url: string;\n    enabled: boolean;\n    isBuiltIn: boolean;\n}\n\nexport interface IPackageManager extends TypedEventEmitter<PackageManagerEventMap> {\n    pkg: TPackage;\n    lib: TFlatPackage;\n    readonly packagesInfo: PackageInfo[];\n    init(): Promise<void>;\n    importFromURL(url: string, id: string): Promise<void>;\n    searchInPkg(query: string, limit: number, staticMethodOnly: boolean, pkg: TPackage, path?: string[]): { path: string[]; object?: typeof IJSPatcherObject | TPackage }[];\n    searchInLib(query: string, limit: number, staticMethodOnly: boolean, lib: TFlatPackage): { key: string; object: typeof IJSPatcherObject }[];\n    getFromPath(pathIn: (string | symbol)[], pkg: TPackage): TPackage | typeof IJSPatcherObject;\n}\n\nexport default class PackageManager extends TypedEventEmitter<PackageManagerEventMap> implements IPackageManager {\n    private readonly patcher: Patcher;\n    pkg: TPackage;\n    lib: TFlatPackage;\n    get global() {\n        return this.patcher.env.pkgMgr;\n    }\n    get mode() {\n        return this.patcher.props.mode;\n    }\n    get patcherDependencies() {\n        return this.patcher.props.dependencies;\n    }\n    get patcherDependenciesNames() {\n        return this.patcher.props.dependencies.map(t => t[0]);\n    }\n    get packagesInfo() {\n        return Object.keys(this.global[this.mode]).map(id => ({\n            id,\n            isBuiltIn: this.global.builtInPackagesNames.indexOf(id) !== -1,\n            url: this.global.importedPackages.find(p => p.name === id)?.baseUrl,\n            enabled: id in this.pkg\n        } as PackageInfo));\n    }\n    constructor(patcher: Patcher) {\n        super();\n        this.patcher = patcher;\n    }\n    async init() {\n        await this.loadPatcherDependencies();\n        this.pkg = {};\n        for (const pkgName of Object.keys(this.global[this.mode]).sort((a, b) => (b === \"globalThis\" ? -1 : 1))) {\n            if (this.global.builtInPackagesNames.indexOf(pkgName) !== -1) {\n                const pkg = this.global[this.mode][pkgName];\n                if (pkg) this.pkg[pkgName] = pkg;\n            }\n        }\n        for (const pkgName of this.patcherDependenciesNames) {\n            const pkg = this.global[this.mode][pkgName];\n            if (pkg) this.pkg[pkgName] = pkg;\n        }\n        this.lib = this.packageRegister(this.pkg);\n        this.emitLibChanged();\n    }\n    async loadPatcherDependencies() {\n        try {\n            await this.patcher.env.taskMgr.newTask(this, `${this.patcher.file?.name || \"\"} Loading dependencies`, async (onUpdate: (newMsg: string) => any) => {\n                for (let i = 0; i < this.patcherDependencies.length; i++) {\n                    const [name, url] = this.patcherDependencies[i];\n                    onUpdate(`${name} from ${url}`);\n                    if (this.global[this.mode][name]) continue;\n                    try {\n                        await this.global.importFromURL?.(url, name);\n                    } catch (e) {\n                        throw new Error(`Loading dependency: ${name} from ${url} failed`);\n                    }\n                }\n            });\n        } catch (error) {\n            this.patcher.error((error as Error).message);\n        }\n    }\n    async importFromURL(url: string, id: string) {\n        if (!this.global.importFromURL) throw new Error(\"Cannot import from this context\");\n        await this.global.importFromURL(url, id);\n        this.init();\n        this.emitLibChanged();\n    }\n    emitLibChanged() {\n        this.patcher.emit(\"libChanged\", { pkg: this.pkg, lib: this.lib });\n    }\n    packageRegister(pkg: TPackage, libOut: TFlatPackage = {}, rootifyDepth = Infinity, pathIn?: string[]) {\n        const path = pathIn ? pathIn.slice() : [];\n        if (path.length && ImporterDirSelfObject in pkg) {\n            const el = pkg[ImporterDirSelfObject as any];\n            if (isJSPatcherObjectConstructor(el)) {\n                const full = path.join(\".\");\n                if (full in libOut) this.emit(\"pathDuplicated\", full);\n                // this.patcher.newLog(\"warn\", \"Patcher\", \"Path duplicated, cannot register \" + full, this);\n                else libOut[full] = el as typeof IJSPatcherObject;\n                const p = path.slice();\n                while (p.length && path.length - p.length < rootifyDepth) {\n                    if (!p[0]) {\n                        p.shift();\n                        continue;\n                    }\n                    const k = p.join(\".\");\n                    if (!(k in libOut)) libOut[k] = el as typeof IJSPatcherObject;\n                    p.shift();\n                }\n            }\n        }\n        const pkgKeys = Object.keys(pkg);\n        if (this.pkg === pkg) {\n            pkgKeys.sort((a, b) => {\n                const $a = this.global.builtInPackagesNames.indexOf(a);\n                const $b = this.global.builtInPackagesNames.indexOf(b);\n                return ($a === -1 ? Infinity : $a) - ($b === -1 ? Infinity : $b);\n            });\n        }\n        for (const key of pkgKeys) {\n            const el = pkg[key];\n            if (typeof el === \"object\") {\n                this.packageRegister(el, libOut, rootifyDepth, [...path, key]);\n            } else if (isJSPatcherObjectConstructor(el)) {\n                const full = [...path, key].join(\".\");\n                if (full in libOut) this.emit(\"pathDuplicated\", full);\n                // this.patcher.newLog(\"warn\", \"Patcher\", \"Path duplicated, cannot register \" + full, this);\n                else libOut[full] = el;\n                const p = [...path, key];\n                while (p.length && path.length + 1 - p.length < rootifyDepth) {\n                    if (!p[0]) {\n                        p.shift();\n                        continue;\n                    }\n                    const k = p.join(\".\");\n                    if (!(k in libOut)) libOut[k] = el;\n                    p.shift();\n                }\n            }\n        }\n        return libOut;\n    }\n    searchInLib(query: string, limit = Infinity, staticMethodOnly = false, lib: TFlatPackage) {\n        const keys = Object.keys(lib).sort();\n        const items: { key: string; object: typeof IJSPatcherObject }[] = [];\n        for (let i = 0; i < keys.length; i++) {\n            if (items.length >= limit) break;\n            const key = keys[i];\n            if (key.startsWith(query)) {\n                const o = lib[key];\n                if (staticMethodOnly) {\n                    if (o[ImporterDirSelfObject as unknown as keyof typeof IJSPatcherObject]) {\n                        items.push({ key, object: o });\n                    }\n                } else {\n                    items.push({ key, object: o });\n                }\n            }\n        }\n        return items;\n    }\n    searchInPkg(query: string, limit = Infinity, staticMethodOnly = false, pkg: TPackage, path: string[] = []): { path: string[]; object?: typeof IJSPatcherObject | TPackage }[] {\n        const outs: { path: string[]; object?: typeof IJSPatcherObject | TPackage }[] = [];\n        for (const key in pkg) {\n            if (outs.length >= limit) break;\n            const o = pkg[key];\n            if (typeof o === \"object\") {\n                if (key.indexOf(query) !== -1) outs.push({ path: [...path, key], object: o });\n                else outs.push(...this.searchInPkg(query, limit, staticMethodOnly, o, [...path, key]));\n            } else {\n                if (key.indexOf(query) !== -1) outs.push({ path: [...path, key], object: o });\n            }\n        }\n        return outs;\n    }\n    getFromPath(pathIn: (string | symbol)[], pkg: TPackage) {\n        const path = pathIn.slice();\n        let o: TPackage | typeof IJSPatcherObject = pkg;\n        while (path.length) {\n            const key = path.shift() as any;\n            o = (o as TPackage)[key];\n            if (!o) return null;\n            if (typeof o !== \"object\" && !isJSPatcherObjectConstructor(o)) return null;\n        }\n        return o;\n    }\n}\n","import TypedEventEmitter from \"../utils/TypedEventEmitter\";\nimport { ab2str, str2ab } from \"../utils/utils\";\nimport VERSION from \"../version\";\nimport type Env from \"./Env\";\nimport type FileInstance from \"./file/FileInstance\";\nimport type PersistentProjectFile from \"./file/PersistentProjectFile\";\nimport type { IJSPatcherEnv } from \"./Env\";\nimport type { IPropsMeta } from \"./objects/base/AbstractObject\";\n\nexport interface ProjectEventMap {\n    \"propsChanged\": Partial<ProjectProps>;\n    \"save\": never;\n    \"unload\": never;\n}\nexport interface ProjectProps {\n    name: string;\n    author: string;\n    version: string;\n    systemVersion: string;\n}\n\nexport interface IProject extends TypedEventEmitter<ProjectEventMap> {\n}\n\nexport default class Project extends TypedEventEmitter<ProjectEventMap> {\n    static props: IPropsMeta<ProjectProps> = {\n        name: {\n            type: \"string\",\n            description: \"Project name\",\n            default: \"Untitled\"\n        },\n        author: {\n            type: \"string\",\n            description: \"Author\",\n            default: \"Anonymous\"\n        },\n        version: {\n            type: \"string\",\n            description: \"Current version\",\n            default: \"0.0.0\"\n        },\n        systemVersion: {\n            type: \"string\",\n            description: \"System version\",\n            default: VERSION\n        }\n    };\n    readonly projectFilename = \".jspatproj\";\n    readonly env: IJSPatcherEnv;\n    readonly instances: FileInstance[];\n    readonly props: ProjectProps = {\n        name: Project.props.name.default,\n        author: Project.props.author.default,\n        version: Project.props.version.default,\n        systemVersion: Project.props.systemVersion.default\n    };\n    ready = false;\n    get audioCtx() {\n        return (this.env as Env).audioCtx;\n    }\n    constructor(envIn: IJSPatcherEnv, props?: Partial<ProjectProps>) {\n        super();\n        this.env = envIn;\n        if (props) this.setProps(props);\n    }\n    async setProps(props: Partial<ProjectProps>) {\n        let changed = false;\n        for (const keyIn in props) {\n            const key = keyIn as keyof ProjectProps;\n            if (this.props[key] === props[key]) continue;\n            changed = true;\n            (this.props as any)[key] = props[key];\n        }\n        if (this.ready && changed) {\n            this.emit(\"propsChanged\", props);\n            await this.saveProps();\n        }\n    }\n    async saveProps() {\n        const data = str2ab(JSON.stringify(this.props));\n        if (await this.env.fileMgr.exists(`/project/${this.projectFilename}`)) {\n            const item = this.env.fileMgr.getProjectItemFromPath(`./${this.projectFilename}`) as PersistentProjectFile;\n            await item.save(data, this);\n        } else {\n            await this.env.fileMgr.projectRoot.addFile(this.projectFilename, data);\n        }\n    }\n    async save() {\n        await this.emit(\"save\");\n    }\n    async load(clean = false) {\n        await this.env.fileMgr.init(clean);\n        await this.init();\n    }\n    async init() {\n        if (await this.env.fileMgr.exists(`/project/${this.projectFilename}`)) {\n            const item = this.env.fileMgr.getProjectItemFromPath(`./${this.projectFilename}`) as PersistentProjectFile;\n            const props = JSON.parse(ab2str(item.data)) as ProjectProps;\n            for (const keyIn in props) {\n                const key = keyIn as keyof ProjectProps;\n                if (this.props[key] === props[key]) continue;\n                (this.props as any)[key] = props[key];\n            }\n        } else {\n            const data = str2ab(JSON.stringify(this.props));\n            await this.env.fileMgr.projectRoot.addFile(this.projectFilename, data);\n        }\n        this.ready = true;\n    }\n    async unload() {\n        for (const i of this.env.instances) {\n            if (i.project === this) await i.destroy();\n        }\n        await this.emit(\"unload\");\n    }\n}\n","import TypedEventEmitter from \"../utils/TypedEventEmitter\";\n\nexport interface Task {\n    /** thread + numberId */\n    id: string;\n    timestamp: number;\n    thread: string;\n    emitter: Object | string;\n    message: string;\n    callback: (onUpdate?: (newMsg: string) => any) => any | Promise<any>;\n}\n\nexport interface TaskError {\n    id: string;\n    timestamp: number;\n    thread: string;\n    emitter: Object | string;\n    message: string;\n    error: Error;\n}\n\nexport interface TaskManagerEventMap {\n    \"taskBegin\": Task;\n    \"taskUpdate\": Task;\n    \"taskEnd\": Task;\n    \"taskError\": TaskError;\n    \"tasks\": Task[];\n    \"errors\": TaskError[];\n}\n\nexport default class TaskManager extends TypedEventEmitter<TaskManagerEventMap> {\n    _id = 0;\n    _tasks: { [thread: string]: Task[] } = {};\n    _errors: { [thread: string]: TaskError[] } = {};\n    get tasks() {\n        const tasks: Task[] = [];\n        for (const key in this._tasks) {\n            tasks.push(...this._tasks[key].filter(e => !!e));\n        }\n        return tasks;\n    }\n    get errors() {\n        const errors: TaskError[] = [];\n        for (const key in this._errors) {\n            errors.push(...this._errors[key].filter(e => !!e));\n        }\n        return errors;\n    }\n    async newTask<T extends Task[\"callback\"] = Task[\"callback\"]>(emitter: string | Object, message: string, callback: T) {\n        const thread = globalThis.constructor.name;\n        const timestamp = Date.now();\n        const id = thread + this._id++;\n        const task: Task = { id, thread, timestamp, emitter, message, callback };\n        if (!(thread in this._tasks)) this._tasks[thread] = [];\n        const $ = this._tasks[thread].push(task) - 1;\n        this.emit(\"tasks\", this.tasks);\n        this.emit(\"taskBegin\", task);\n        let returnValue: ReturnType<T> extends Promise<infer R> ? R : ReturnType<T>;\n        const handleUpdate = (msg: string) => {\n            const task: Task = { id, thread, timestamp, emitter, message: `${message}: ${msg}`, callback };\n            this._tasks[thread][$] = task;\n            this.emit(\"tasks\", this.tasks);\n            this.emit(\"taskUpdate\", task);\n        };\n        try {\n            returnValue = await callback(handleUpdate);\n        } catch (error) {\n            const taskError: TaskError = { id, thread, timestamp, emitter, message, error };\n            if (!(thread in this._errors)) this._errors[thread] = [];\n            this._errors[thread].push(taskError);\n            this.emit(\"errors\", this.errors);\n            this.emit(\"taskError\", taskError);\n            throw error;\n        } finally {\n            this._tasks[thread][$] = null;\n            this.emit(\"tasks\", this.tasks);\n            this.emit(\"taskEnd\", task);\n        }\n        return returnValue;\n    }\n    get lastError(): TaskError {\n        return this.errors.sort(((a, b) => b.timestamp - a.timestamp))[0];\n    }\n    get lastTask(): Task {\n        return this.tasks.sort(((a, b) => b.timestamp - a.timestamp))[0];\n    }\n    getTasksFromEmitter(emitter: string | Object) {\n        return this.tasks.filter(task => task.emitter === emitter);\n    }\n    getErrorsFromEmitter(emitter: string | Object) {\n        return this.errors.filter(error => error.emitter === emitter);\n    }\n    dismissLastError() {\n        const { lastError } = this;\n        if (!lastError) return;\n        const $ = this._errors[lastError.thread].indexOf(lastError);\n        this._errors[lastError.thread][$] = null;\n        this.emit(\"errors\", this.errors);\n    }\n    dismissAllErrors() {\n        this._errors = {};\n        this.emit(\"errors\", this.errors);\n    }\n}\n","import { ImporterDirSelfObject } from \"../utils/symbols\";\nimport { isJSPatcherObjectConstructor } from \"./objects/base/AbstractObject\";\nimport getBase from \"./objects/base/index.jsdsppkg.aw\";\nimport getGlobalThis from \"./objects/globalThis/index.jsdsppkg\";\nimport type { TPackage, PatcherMode, ObjectDescriptor, TAbstractPackage } from \"./types\";\nimport type { AnyImportedObject } from \"./objects/importer/ImportedObject\";\nimport type WorkletEnvProcessor from \"./worklets/WorkletEnv.worklet\";\nimport type { IExternalPackage, PackageGetter } from \"./GlobalPackageManager\";\n\nexport default class WorkletGlobalPackageManager {\n    js: TPackage;\n    jsaw: TPackage;\n    faust: TPackage;\n    max: TPackage;\n    gen: TPackage;\n    private readonly env: WorkletEnvProcessor;\n    externals = new Map<string, Record<string, any>>();\n    readonly importedPackages: IExternalPackage[] = [];\n    get builtInPackagesNames() {\n        return [...this.importedPackages.filter(p => p.isBuiltIn).map(p => p.name), \"Base\", \"globalThis\"];\n    }\n    get externalPackagesNames() {\n        return this.importedPackages.filter(p => !p.isBuiltIn).map(p => p.name);\n    }\n    constructor(envIn: WorkletEnvProcessor) {\n        this.env = envIn;\n    }\n    async init() {\n        this.jsaw = {\n            Base: await getBase(),\n            globalThis: await getGlobalThis()\n        };\n        await this.env.addObjects(this.getDescriptors(this.jsaw.globalThis, \"globalThis\"), \"globalThis\");\n    }\n    toDescriptor(O: typeof AnyImportedObject, pkgName: string): ObjectDescriptor {\n        const { path } = O;\n        return {\n            isObjectDescriptor: true as const,\n            ctor: O.importedObjectType,\n            path,\n            name: path[path.length - 1] || pkgName\n        };\n    }\n    getDescriptors(pkgIn = this.jsaw.globalThis, pkgName = \"globalThis\") {\n        const $self = \"__JSPatcher_Importer_ImporterDirSelfObject\";\n        const pkg = Object.entries(pkgIn).reduce((acc, [k, v]) => {\n            if (typeof v === \"function\") {\n                const descriptor = this.toDescriptor(v, pkgName);\n                if (k as any === ImporterDirSelfObject) acc[$self] = descriptor;\n                else acc[k] = descriptor;\n            } else {\n                acc[k] = this.getDescriptors(v, pkgName);\n            }\n            return acc;\n        }, {} as TAbstractPackage);\n        if (ImporterDirSelfObject in pkgIn) pkg[$self] = this.toDescriptor((pkgIn as any)[ImporterDirSelfObject], pkgName);\n        return pkg;\n    }\n    add(pkgIn: TPackage, lib: PatcherMode, pathIn: string[] = []) {\n        const path = pathIn.slice();\n        let pkg = this[lib];\n        while (path.length) {\n            const key = path.shift();\n            if (!pkg[key]) pkg[key] = {};\n            else if (isJSPatcherObjectConstructor(pkg[key])) pkg[key] = { [ImporterDirSelfObject]: pkg[key] };\n            pkg = pkg[key] as TPackage;\n        }\n        Object.assign(pkg, pkgIn);\n    }\n    async fetchModule(url: string) {\n        const toExport = {};\n        globalThis.exports = toExport;\n        globalThis.module = { exports: toExport } as any;\n        await this.env.addWorkletModule(url);\n        const exported = globalThis.module.exports;\n        delete globalThis.exports;\n        delete globalThis.module;\n        return exported;\n    }\n    async importPackage(url: string, pkgInfo: IExternalPackage) {\n        if (this.importedPackages.find(p => p.name === pkgInfo.name)) return;\n        const getter: PackageGetter = (await this.fetchModule(url)).default;\n        this.add(await getter(this.env), \"jsaw\", [pkgInfo.name]);\n        this.importedPackages.push(pkgInfo);\n    }\n}\n","import BaseObject from \"./objects/base/BaseObject\";\nimport Patcher from \"./patcher/Patcher\";\nimport Box from \"./patcher/Box\";\nimport Line from \"./patcher/Line\";\nimport generateRemotedObject from \"./objects/base/generateRemotedObject\";\nimport Bang, { isBang } from \"./objects/base/Bang\";\nimport * as MathUtils from \"../utils/math\";\nimport * as BufferUtils from \"../utils/buffer\";\nimport * as Utils from \"../utils/utils\";\nimport Importer from \"./objects/importer/Importer\";\nimport RemotedImporter from \"./objects/importer/RemotedImporter\";\nimport type { IJSPatcherSDK } from \"./SDK\";\n\nexport default class JSPatcherWorkletSDK implements IJSPatcherSDK {\n    readonly Patcher = Patcher;\n    readonly Box = Box;\n    readonly Line = Line;\n    readonly BaseObject = BaseObject;\n    readonly generateRemotedObject = generateRemotedObject;\n    readonly Bang = Bang;\n    readonly isBang = isBang;\n    readonly MathUtils = MathUtils;\n    readonly BufferUtils = BufferUtils;\n    readonly Utils = Utils;\n    readonly Importer = Importer;\n    readonly RemotedImporter = RemotedImporter;\n}\n","import TemporaryProjectFile from \"../file/TemporaryProjectFile\";\nimport type PatcherAudio from \"./PatcherAudio\";\nimport type { IJSPatcherEnv } from \"../Env\";\nimport type { IProject } from \"../Project\";\n\nexport default class TempAudioFile extends TemporaryProjectFile<PatcherAudio> {\n    get type() {\n        return \"audio\" as const;\n    }\n    async instantiate() {\n        return this.data;\n    }\n    async instantiateEditor({ env, project, instanceId }: { env: IJSPatcherEnv; project?: IProject; instanceId?: string }) {\n        const AudioEditor = (await import(\"./AudioEditor\")).default;\n        return AudioEditor.fromProjectItem({ file: this, env, project, instanceId });\n    }\n}\n","import type { IJSPatcherEnv } from \"../Env\";\nimport type { IProject } from \"../Project\";\nimport type { ProjectItemType } from \"../types\";\nimport type { IProjectItemManager } from \"./AbstractProjectItemManager\";\nimport type { IFileEditor } from \"./FileEditor\";\nimport type { IFileInstance } from \"./FileInstance\";\nimport type { IProjectFolder } from \"./AbstractProjectFolder\";\nimport AbstractProjectItem, { IProjectItem, ProjectItemEventMap } from \"./AbstractProjectItem\";\n\nexport interface ProjectFileEventMap extends ProjectItemEventMap {\n    \"saved\": any; // here emit with the object who performed the saving\n}\n\nexport interface IProjectFile<Data = any, Manager extends IProjectItemManager = IProjectItemManager> extends IProjectItem<ProjectFileEventMap, Manager> {\n    readonly type: Exclude<ProjectItemType, \"folder\">;\n    readonly isFolder: false;\n    readonly data: Data;\n    readonly fileExtension: string;\n    clone(parentIn?: IProjectFolder, nameIn?: string, dataIn?: Data): IProjectFile<Data>;\n    /**\n     * This method calls default instantiation (from the file manager).\n     * Please use `FileInstance.fromProjectItem(item)` for a better instantiation.\n     */\n    instantiate(options: { env: IJSPatcherEnv; project?: IProject; instanceId?: string }): Promise<IFileInstance>;\n    instantiateEditor(options: { env: IJSPatcherEnv; project?: IProject; instanceId?: string }): Promise<IFileEditor>;\n    /**\n     * Save the data to the file manager\n     *\n     * @param newDataIn new data to save\n     * @param by the editor who performs the save\n     */\n    save(newDataIn: Data, by: any): Promise<void>;\n    /** Save the data to a new file, not modifying the current file, nor point current editing file to the new one. */\n    saveAsCopy(parentIn: IProjectFolder, nameIn: string, newDataIn: any, manager?: IProjectItemManager): Promise<IProjectFile>;\n    /**\n     * Not modifying the current file, save to a new file and point current editing file to the new one.\n     *\n     * @param to the folder that will contain the new file to save\n     * @param newNameIn new file name to save\n     * @param newDataIn new data to save\n     * @param by the editor who performs the save\n     */\n    saveAs(to: IProjectFolder, newNameIn: string, newDataIn: any, by: any, manager?: IProjectItemManager): Promise<IProjectFile>;\n}\n\nexport default abstract class AbstractProjectFile<Data = ArrayBuffer, Manager extends IProjectItemManager<any> = IProjectItemManager> extends AbstractProjectItem<ProjectFileEventMap, Manager> implements IProjectFile<Data, Manager> {\n    get type() {\n        return this.fileMgr.getTypeFromFileName(this.name) as Exclude<ProjectItemType, \"folder\">;\n    }\n    readonly isFolder = false;\n    protected _data: Data;\n    get data() {\n        return this._data;\n    }\n    set data(dataIn: Data) {\n        this._data = dataIn;\n    }\n    get fileExtension() {\n        const splitted = this.name.split(\".\");\n        return splitted[splitted.length - 1];\n    }\n    constructor(fileMgrIn: Manager, parentIn: IProjectFolder, nameIn: string, dataIn?: Data) {\n        super(fileMgrIn, parentIn, nameIn);\n        if (typeof dataIn !== \"undefined\") this._data = dataIn;\n        this.onAny((eventName, eventData) => {\n            const { id, isFolder, type, path, data } = this;\n            this.fileMgr.emit(\"itemChanged\", { id, isFolder, type, path, data, eventName, eventData });\n        });\n    }\n    abstract clone(parentIn?: IProjectFolder, nameIn?: string, dataIn?: Data): IProjectFile<Data>;\n    abstract instantiate(options: { env: IJSPatcherEnv; project?: IProject; instanceId?: string }): Promise<IFileInstance>;\n    abstract instantiateEditor(options: { env: IJSPatcherEnv; project?: IProject; instanceId?: string }): Promise<IFileEditor>;\n    async save(newData: Data, by: any) {\n        this._data = newData;\n        await this.emit(\"saved\", by);\n        await this.fileMgr.emitChanged();\n    }\n    async saveAsCopy(parent: IProjectFolder, name: string, newData: any, manager?: IProjectItemManager): Promise<IProjectFile> {\n        const item = this.clone(parent, name, newData);\n        parent.items.add(item);\n        await this.emitTreeChanged();\n        await this.fileMgr.emitChanged();\n        return item;\n    }\n    async saveAs(to: IProjectFolder, newName: string, newData: any, by: any, manager?: IProjectItemManager): Promise<IProjectFile> {\n        const { parent, name, data } = this;\n        const from = parent;\n        this._data = newData;\n        await this.move(to, newName);\n        const item = this.clone(parent, name, data);\n        parent.items.add(item);\n        await parent.emitTreeChanged();\n        await this.emitTreeChanged();\n        await this.emit(\"pathChanged\", { from: from.path, to: to.path });\n        await this.emit(\"saved\", by);\n        await this.fileMgr.emitChanged();\n        return item;\n    }\n}\n","import type { RawProjectItem } from \"../types\";\nimport type { IProjectItemManager } from \"./AbstractProjectItemManager\";\nimport AbstractProjectItem, { IProjectFileOrFolder, IProjectItem } from \"./AbstractProjectItem\";\n\nexport interface IProjectFolder<Manager extends IProjectItemManager = IProjectItemManager> extends IProjectItem<{}, Manager> {\n    readonly type: \"folder\";\n    readonly isFolder: true;\n    readonly items: Set<IProjectFileOrFolder>;\n    clone(parentIn?: IProjectFolder, nameIn?: string): IProjectFolder;\n    createProjectItem(nameIn: string, isFolder: boolean, dataIn?: any): IProjectFileOrFolder;\n    findItem(itemIn: string): IProjectFileOrFolder;\n    existItem(itemIn: IProjectFileOrFolder | string): boolean;\n    uniqueName(nameIn: string): string;\n    addFile(nameIn: string, dataIn?: any): Promise<IProjectFileOrFolder>;\n    addFolder(nameIn: string): Promise<IProjectFolder>;\n    empty(): Promise<void>;\n    getTree(): RawProjectItem<\"folder\">;\n    getDescendantFiles(): IProjectFileOrFolder[];\n    isParentOf(itemIn: IProjectItem): boolean;\n    getOrderedItems(): IProjectFileOrFolder[];\n    emitTreeChanged(): Promise<void>;\n}\n\nexport default abstract class AbstractProjectFolder<Manager extends IProjectItemManager = IProjectItemManager> extends AbstractProjectItem<{}, Manager> implements IProjectFolder<Manager> {\n    get type(): \"folder\" {\n        return \"folder\";\n    }\n    readonly isFolder = true;\n    items: Set<IProjectFileOrFolder> = new Set();\n    get isDirty() {\n        return !this.getDescendantFiles().every(f => !f.isDirty);\n    }\n    constructor(fileMgrIn: Manager, parentIn: IProjectFolder, nameIn: string) {\n        super(fileMgrIn, parentIn, nameIn);\n        this.onAny((eventName, eventData) => {\n            const { id, isFolder, type, path } = this;\n            this.fileMgr.emit(\"itemChanged\", { id, isFolder, type, path, eventName, eventData });\n        });\n    }\n    abstract clone(parentIn?: IProjectFolder, nameIn?: string): IProjectFolder;\n    abstract createProjectItem(nameIn: string, isFolder: boolean, dataIn?: any): IProjectFileOrFolder;\n    findItem(itemIn: string) {\n        return Array.from(this.items).find(item => item.name === itemIn);\n    }\n    existItem(itemIn: IProjectFileOrFolder | string) {\n        return typeof itemIn === \"string\" ? !!this.findItem(itemIn) : this.items.has(itemIn);\n    }\n    uniqueName(nameIn: string) {\n        if (!this.existItem(nameIn)) return nameIn;\n        const splitted = nameIn.split(\".\");\n        const name0 = splitted[0];\n        let i = 0;\n        do {\n            i++;\n            splitted[0] = `${name0}_${i}`;\n        } while (this.existItem(splitted.join(\".\")));\n        return splitted.join(\".\");\n    }\n    abstract addFile(nameIn: string, dataIn?: any): Promise<IProjectFileOrFolder>;\n    abstract addFolder(nameIn: string): Promise<IProjectFolder>;\n    async empty() {\n        for (const item of this.items) {\n            await item.destroy();\n        }\n    }\n    getTree(): RawProjectItem<\"folder\"> {\n        return {\n            type: \"folder\",\n            id: this.id,\n            isFolder: true,\n            name: this.name,\n            items: Array.from(this.items).map((item) => {\n                if (item.isFolder === false) {\n                    const { id, isFolder, type, name, data } = item;\n                    return { id, isFolder, type, name, data };\n                }\n                return item.getTree();\n            })\n        };\n    }\n    getDescendantFiles() {\n        return Array.from(this.items).reduce((acc, cur) => {\n            if (cur.isFolder === false) acc.push(cur);\n            else acc.push(...cur.getDescendantFiles());\n            return acc;\n        }, [] as IProjectFileOrFolder[]);\n    }\n    isParentOf(itemIn: IProjectFileOrFolder) {\n        let { parent } = itemIn;\n        while (parent !== this) {\n            if (!parent) return false;\n            parent = parent.parent;\n        }\n        return true;\n    }\n    getOrderedItems() {\n        const items = Array.from(this.items);\n        const folders = items.filter(i => i.isFolder).sort((a, b) => a.name.localeCompare(b.name));\n        const files = items.filter(i => !i.isFolder).sort((a, b) => a.name.localeCompare(b.name));\n        return [...folders, ...files];\n    }\n}\n","import TypedEventEmitter, { ITypedEventEmitter } from \"../../utils/TypedEventEmitter\";\nimport type { IObservee, ProjectItemType } from \"../types\";\nimport type { IProjectItemManager } from \"./AbstractProjectItemManager\";\nimport type { IProjectFile } from \"./AbstractProjectFile\";\nimport type { IProjectFolder } from \"./AbstractProjectFolder\";\n\nexport type IProjectFileOrFolder = IProjectFolder | IProjectFile;\n\nexport interface ProjectItemEventMap {\n    \"ready\": never;\n    \"nameChanged\": { oldName: string; newName: string };\n    \"pathChanged\": { from: string; to: string };\n    \"treeChanged\": never;\n    \"destroyed\": never;\n    \"observers\": Set<string>;\n    \"dirty\": boolean;\n}\n\nexport interface IProjectItem<EventMap extends Record<string, any> = {}, Manager extends IProjectItemManager = IProjectItemManager> extends ITypedEventEmitter<ProjectItemEventMap & EventMap>, IObservee<string> {\n    readonly id: string;\n    readonly fileMgr: Manager;\n    readonly isFolder: boolean;\n    readonly type: ProjectItemType;\n    readonly name: string;\n    /** path used by the file manager */\n    readonly path: string;\n    /** parent path used by the file manager */\n    readonly parentPath: string;\n    /** path relative to the project root */\n    readonly projectPath: string;\n    /** Is the file is editing by some editor and modified (without saving the data), isDirty is true. */\n    readonly isDirty: boolean;\n    parent: IProjectFolder;\n    /** Load data */\n    init(): Promise<void>;\n    /** Clone with optional modifications */\n    clone(parentIn?: IProjectFolder, nameIn?: string): IProjectItem;\n    rename(newNameIn: string): Promise<void>;\n    move(to: IProjectFolder, newNameIn?: string): Promise<void>;\n    /** Delete current file from file manager and the parent folder. */\n    destroy(): Promise<void>;\n}\n\nexport default abstract class AbstractProjectItem<EventMap extends Partial<ProjectItemEventMap> & Record<string, any> = {}, Manager extends IProjectItemManager = IProjectItemManager> extends TypedEventEmitter<ProjectItemEventMap & EventMap> implements IProjectItem<EventMap, Manager> {\n    id: string;\n    get type(): ProjectItemType {\n        return \"unknown\";\n    }\n    readonly isFolder: boolean;\n    protected readonly _fileMgr;\n    get fileMgr() {\n        return this._fileMgr;\n    }\n    protected _name: string;\n    get name() {\n        return this._name;\n    }\n    parent: IProjectFolder;\n    private _isDirty = false;\n    get isDirty() {\n        return this._isDirty;\n    }\n    get path(): string {\n        return this.parent ? `${this.parentPath}/${this._name}` : \"\";\n    }\n    get parentPath() {\n        return this.parent?.path;\n    }\n    get projectPath() {\n        return this.path.replace(new RegExp(`^/${this._fileMgr.projectFolderName}`), \"\");\n    }\n    protected readonly _observers = new Set<string>();\n    async addObserver(observer: string) {\n        this._observers.add(observer);\n        await this.emit(\"observers\", this._observers);\n        await this.fileMgr.emitChanged();\n    }\n    async removeObserver(observer: string) {\n        this._observers.delete(observer);\n        await this.emit(\"observers\", this._observers);\n        if (this._observers.size === 0) this.emit(\"dirty\", false);\n        await this.fileMgr.emitChanged();\n    }\n    constructor(fileMgrIn: Manager, parentIn: IProjectFolder, nameIn: string) {\n        super();\n        this._fileMgr = fileMgrIn;\n        this.parent = parentIn;\n        this._name = nameIn;\n        this.on(\"dirty\", dirty => this._isDirty = dirty);\n    }\n    abstract rename(newNameIn: string): Promise<void>;\n    abstract move(to: IProjectFolder, newNameIn?: string): Promise<void>;\n    abstract destroy(): Promise<void>;\n    abstract clone(parentIn?: IProjectFolder, nameIn?: string): IProjectItem;\n    async init() {\n        this.id = this.fileMgr.generateItemId(this);\n        await this.emit(\"ready\");\n        await this.fileMgr.emitChanged();\n    }\n    async emitTreeChanged() {\n        await this.emit(\"treeChanged\");\n        await (this.parent || this.fileMgr).emitTreeChanged();\n    }\n}\n","import TypedEventEmitter, { ITypedEventEmitter } from \"../../utils/TypedEventEmitter\";\nimport { extToType } from \"../../utils/utils\";\nimport type TaskMgr from \"../TaskMgr\";\nimport type { IJSPatcherEnv } from \"../Env\";\nimport type { ProjectItemType, RawProjectItem } from \"../types\";\nimport type { IFileInstance } from \"./FileInstance\";\nimport type { IProjectFolder } from \"./AbstractProjectFolder\";\nimport type { IProjectFileOrFolder, IProjectItem, ProjectItemEventMap } from \"./AbstractProjectItem\";\nimport { IProject } from \"../Project\";\n\nexport interface ItemChangedEvent<K extends keyof ProjectItemEventMap = keyof ProjectItemEventMap> {\n    id: string;\n    isFolder: boolean;\n    path: string;\n    type: ProjectItemType;\n    data?: any;\n    eventName: K;\n    eventData?: ProjectItemEventMap[K];\n}\n\nexport interface ProjectItemManagerEventMap {\n    \"ready\": never;\n    \"treeChanged\": RawProjectItem<\"folder\">;\n    \"itemChanged\": ItemChangedEvent;\n    \"changed\": never;\n}\n\nexport interface IProjectItemManager<EventMap extends Record<string, any> & Partial<ProjectItemManagerEventMap> = {}> extends ITypedEventEmitter<EventMap & ProjectItemManagerEventMap> {\n    readonly projectFolderName: string;\n    readonly id: string;\n    readonly taskMgr: TaskMgr;\n    readonly allItems: Record<string, IProjectFileOrFolder>;\n    readonly allProjectItems: Record<string, IProjectFileOrFolder>;\n    root: IProjectFolder;\n    /** Enpty the backend file manager */\n    empty(): Promise<any>;\n    /** Empty the project rool folder */\n    emptyProject(): Promise<void>;\n    /** Create all project items by analyzing the backend */\n    init(clean?: boolean): Promise<this>;\n    getTypeFromFileName(name: string): ProjectItemType;\n    getProjectItemFromId(id: string): IProjectFileOrFolder;\n    getProjectItemFromPath(path: string): IProjectFileOrFolder;\n    getPathIdMap(): Record<string, string>;\n    instantiateProjectPath(path: string, envIn: IJSPatcherEnv, projectIn?: IProject): Promise<IFileInstance>;\n    emitTreeChanged(): Promise<void>;\n    emitChanged(): Promise<void>;\n    generateItemId(item: IProjectItem): string;\n}\n\nexport default abstract class AbstractProjectItemManager<EventMap extends Record<string, any> & Partial<ProjectItemManagerEventMap> = {}> extends TypedEventEmitter<EventMap & ProjectItemManagerEventMap> implements IProjectItemManager<EventMap> {\n    readonly projectFolderName = \"project\";\n    readonly id: string;\n    readonly env: IJSPatcherEnv;\n    readonly taskMgr: TaskMgr;\n    get allItems() {\n        const items: Record<string, IProjectFileOrFolder> = {};\n        const rec = (cur: IProjectFileOrFolder) => {\n            items[cur.id] = cur;\n            if (cur.isFolder) cur.items.forEach(rec);\n        };\n        rec(this.root);\n        return items;\n    }\n    get allProjectItems() {\n        const items: Record<string, IProjectFileOrFolder> = {};\n        const rec = (cur: IProjectFileOrFolder) => {\n            items[cur.id] = cur;\n            if (cur.isFolder) cur.items.forEach(rec);\n        };\n        rec(this.projectRoot);\n        return items;\n    }\n    root: IProjectFolder;\n    constructor(envIn: IJSPatcherEnv) {\n        super();\n        this.env = envIn;\n        this.id = envIn.generateId(this);\n        this.taskMgr = envIn.taskMgr;\n    }\n    abstract empty(): Promise<any>;\n    emptyProject() {\n        return this.projectRoot.empty();\n    }\n    abstract init(clean?: boolean): Promise<this>;\n    getTypeFromFileName(name: string): ProjectItemType {\n        const splitted = name.split(\".\");\n        const ext = splitted[splitted.length - 1];\n        return extToType(ext);\n    }\n    getProjectItemFromId(id: string) {\n        return this.allItems[id];\n    }\n    getProjectItemFromPath(path: string) {\n        const pathArray = path.split(\"/\");\n        const itemArray: (IProjectFileOrFolder)[] = [this.root, this.projectRoot];\n        for (let i = 0; i < pathArray.length; i++) {\n            const id = pathArray[i];\n            if (id.length === 0) continue;\n            if (id === \".\") continue;\n            if (id === \"..\") {\n                itemArray.pop();\n                continue;\n            }\n            const cur = itemArray[itemArray.length - 1];\n            if (!cur.isFolder) throw new Error(`${cur.name} from path ${path} is not a folder`);\n            const next = cur.findItem(id);\n            if (!next) throw new Error(`Cannot find ${id} from path ${path}`);\n            itemArray.push(next);\n        }\n        return itemArray[itemArray.length - 1];\n    }\n    getPathIdMap() {\n        const map: Record<string, string> = {};\n        Object.entries(this.allItems).forEach(([id, { path }]) => map[path] = id);\n        return map;\n    }\n    instantiateProjectPath(path: string, envIn: IJSPatcherEnv, projectIn: IProject) {\n        const item = this.getProjectItemFromPath(path);\n        if (item.isFolder === false) return item.instantiate({ env: envIn, project: projectIn });\n        throw new Error(`Cannot instantiate ${item.name} from path ${path} as it is a folder`);\n    }\n    async emitTreeChanged() {\n        this.emit(\"treeChanged\", this.root.getTree());\n    }\n    async emitChanged() {\n        this.emit(\"changed\");\n    }\n    get projectRoot() {\n        return this.root.findItem(this.projectFolderName) as IProjectFolder;\n    }\n    generateItemId(item: IProjectItem) {\n        return this.env.generateId(item);\n    }\n}\n","import type { SemanticICONS } from \"semantic-ui-react\";\nimport TypedEventEmitter, { ITypedEventEmitter } from \"../../utils/TypedEventEmitter\";\nimport History from \"./History\";\nimport TemporaryProjectFile from \"./TemporaryProjectFile\";\nimport type { IFileInstance } from \"./FileInstance\";\nimport type { IProjectFile } from \"./AbstractProjectFile\";\nimport type { IJSPatcherEnv } from \"../Env\";\nimport type { IProject } from \"../Project\";\nimport type { IProjectFolder } from \"./AbstractProjectFolder\";\n\nexport interface FileEditorEventMap {\n    \"ready\": never;\n    \"changed\": never;\n    \"dirty\": boolean;\n    \"saved\": never;\n    \"locked\": boolean;\n    \"destroy\": never;\n}\n\nexport interface IFileEditor<Instance extends IFileInstance = IFileInstance, EventMap extends Record<string, any> & Partial<FileEditorEventMap> = {}> extends ITypedEventEmitter<EventMap & FileEditorEventMap> {\n    readonly instance: Instance;\n    readonly env: IJSPatcherEnv;\n    readonly project: IProject;\n    readonly ctx: IFileInstance[\"ctx\"];\n    readonly isInMemory: boolean;\n    readonly isTemporary: boolean;\n    isReadonly: boolean;\n    readonly isReady: boolean;\n    readonly isDestroyed: boolean;\n    readonly isDirty: boolean;\n    readonly isLocked: boolean;\n    readonly isActive: boolean;\n    readonly editorId: string;\n    readonly fileExtension: string;\n    readonly fileIcon: SemanticICONS;\n    file: IProjectFile;\n    setActive(): void;\n    undo(): Promise<void>;\n    redo(): Promise<void>;\n    copy(): Promise<void>;\n    cut(): Promise<void>;\n    paste(): Promise<void>;\n    deleteSelected(): Promise<any>;\n    selectAll(): Promise<void>;\n    onUiResized(): void;\n    save(): Promise<void>;\n    saveAs(parent: any, name: string): Promise<void>;\n    destroy(): Promise<void>;\n}\n\nexport type AnyFileEditor = FileEditor<any, Record<string, any>>;\n\nexport default class FileEditor<Instance extends IFileInstance = IFileInstance, EventMap extends Record<string, any> & Partial<FileEditorEventMap> = {}> extends TypedEventEmitter<EventMap & FileEditorEventMap> implements IFileEditor<Instance, EventMap> {\n    static async fromProjectItem({ file, env, project, instanceId }: { file: IProjectFile; env: IJSPatcherEnv; project?: IProject; instanceId?: string }): Promise<IFileEditor> {\n        return new this(await file.instantiate({ env, project, instanceId }));\n    }\n    readonly instance: Instance;\n    get env() {\n        return this.instance.env;\n    }\n    get project() {\n        return this.instance.project;\n    }\n    get file() {\n        return this.instance.file;\n    }\n    set file(value) {\n        this.instance.file = value;\n    }\n    get ctx() {\n        return this.instance.ctx;\n    }\n    get isInMemory() {\n        return this.instance.isInMemory;\n    }\n    get isTemporary() {\n        return this.instance.isTemporary;\n    }\n    get isReadonly() {\n        return this.instance.isReadonly;\n    }\n    set isReadonly(value) {\n        this.instance.isReadonly = value;\n    }\n    protected _isReady = false;\n    get isReady() {\n        return this._isReady;\n    }\n    protected _isDestroyed = false;\n    get isDestroyed() {\n        return this._isDestroyed;\n    }\n    get isDirty() {\n        return this.history?.isDirty;\n    }\n    get isLocked() {\n        return false;\n    }\n    get history(): History<Partial<EventMap>, this> {\n        return this.instance.history;\n    }\n    get fileExtension() {\n        return \"data\";\n    }\n    get fileIcon(): SemanticICONS {\n        return \"code\";\n    }\n    setActive() {\n        this.env.activeEditor = this;\n    }\n    get isActive(): boolean {\n        return this.env.thread === \"main\" && this.env.activeEditor === this;\n    }\n    readonly editorId: string;\n    handleProjectSave = async () => this.save();\n    handleProjectUnload = async () => this.destroy();\n    handleDestroy = () => this.destroy();\n    constructor(instance: Instance) {\n        super();\n        this.instance = instance;\n        this.instance?.addObserver(this);\n        this.instance.on(\"destroy\", this.handleDestroy);\n        this.history?.addEditor(this);\n        this.on(\"dirty\", async (isDirty) => {\n            if (isDirty && this.env.autoSave && !this.isReadonly && !this.isInMemory) await this.save();\n            else this.file?.emit(\"dirty\", isDirty);\n        });\n        this.env.on(\"options\", ({ options: { autoSave } }) => {\n            if (autoSave && !this.isReadonly && !this.isInMemory) this.save();\n        });\n        this.on(\"destroy\", () => this.file?.emit(\"dirty\", false));\n        const handleReady = () => {\n            this._isReady = true;\n            this.off(\"ready\", handleReady);\n        };\n        this.on(\"ready\", handleReady);\n        this.editorId = this.env.generateId(this);\n        if (this.env.thread === \"main\") this.env.registerInstance(this.instance);\n        if (this.project) {\n            this.project.on(\"save\", this.handleProjectSave);\n            this.project.on(\"unload\", this.handleProjectUnload);\n        }\n    }\n    async toFileData() {\n        return this.instance.serialize();\n    }\n    async toTempData(): Promise<any> {\n        return this.instance;\n    }\n    undo() {\n        return this.history.undo();\n    }\n    redo() {\n        return this.history.redo();\n    }\n    async copy() {\n        throw new Error(\"Not implemented.\");\n    }\n    async cut() {\n        throw new Error(\"Not implemented.\");\n    }\n    async paste() {\n        throw new Error(\"Not implemented.\");\n    }\n    async deleteSelected(): Promise<any> {\n        throw new Error(\"Not implemented.\");\n    }\n    async selectAll() {\n        throw new Error(\"Not implemented.\");\n    }\n    onUiResized() {\n        throw new Error(\"Not implemented.\");\n    }\n    async save() {\n        if (this.isReadonly) throw new Error(\"Cannot save readonly file\");\n        if (this.isInMemory) throw new Error(\"Cannot save in-memory instance\");\n        const data = await (this.file instanceof TemporaryProjectFile ? this.toTempData() : this.toFileData());\n        await this.file.save(data, this);\n        await this.emit(\"saved\");\n    }\n    async saveAs(parent: IProjectFolder, name: string) {\n        const data = await this.toFileData();\n        if (this.isTemporary) {\n            await this.file.saveAsCopy(parent, name, data);\n        } else if (this.isReadonly) {\n            await this.file.saveAs(parent, name, data, this);\n        } else if (this.isInMemory) {\n            this.file = await parent.addFile(name, data) as any;\n        } else {\n            await this.file.saveAs(parent, name, data, this);\n        }\n        this.isReadonly = false;\n        await this.emit(\"saved\");\n    }\n    async destroy() {\n        if (this.isDestroyed) return;\n        if (this.project) {\n            this.project.off(\"save\", this.handleProjectSave);\n            this.project.off(\"unload\", this.handleProjectUnload);\n        }\n        this.instance.off(\"destroy\", this.handleDestroy);\n        this.instance.removeObserver(this);\n        this.history?.removeEditor(this);\n        this._isDestroyed = true;\n        await this.emit(\"destroy\");\n    }\n}\n","import TypedEventEmitter, { ITypedEventEmitter } from \"../../utils/TypedEventEmitter\";\nimport TemporaryProjectFile from \"./TemporaryProjectFile\";\nimport type History from \"./History\";\nimport type { IJSPatcherEnv } from \"../Env\";\nimport type { IProject } from \"../Project\";\nimport type { IObservee } from \"../types\";\nimport type { IFileEditor } from \"./FileEditor\";\nimport type { IProjectFile } from \"./AbstractProjectFile\";\n\nexport interface FileInstanceEventMap {\n    \"observers\": Set<any>;\n    \"ready\": never;\n    \"changed\": never;\n    \"destroy\": never;\n}\n\nexport interface IFileInstance<EventMap extends Record<string, any> & Partial<FileInstanceEventMap> = {}, File extends IProjectFile = IProjectFile> extends ITypedEventEmitter<EventMap & FileInstanceEventMap>, IObservee {\n    file?: File;\n    readonly env: IJSPatcherEnv;\n    readonly project: IProject;\n    readonly ctx: File | IProject | IJSPatcherEnv;\n    /** Means it doesn't have a file to save */\n    readonly isInMemory: boolean;\n    /** Means it doesn't have a file to save in the backend */\n    readonly isTemporary: boolean;\n    isReadonly: boolean;\n    isReady: boolean;\n    readonly isActive: boolean;\n    readonly id: string;\n    readonly history: History<any, any>;\n    init(): Promise<this>;\n    setActive(): void;\n    getEditor(): Promise<IFileEditor>;\n    serialize(): Promise<ArrayBuffer>;\n    destroy(): Promise<void>;\n}\n\nexport default abstract class FileInstance<EventMap extends Record<string, any> & Partial<FileInstanceEventMap> = {}, File extends IProjectFile = IProjectFile> extends TypedEventEmitter<EventMap & FileInstanceEventMap> implements IFileInstance<EventMap, File> {\n    private readonly _env: IJSPatcherEnv;\n    get env() {\n        return this._env;\n    }\n    private readonly _project: IProject;\n    get project(): IProject {\n        return this._project;\n    }\n    private _file?: File;\n    get file(): File {\n        return this._file;\n    }\n    set file(value) {\n        if (value === this._file) return;\n        this._file?.removeObserver(this._id);\n        this._file = value;\n        this._file?.addObserver(this._id);\n    }\n    get ctx(): File | IProject | IJSPatcherEnv {\n        return this.file || this.project || this.env;\n    }\n    get isInMemory() {\n        return !this.file;\n    }\n    get isTemporary() {\n        return this.file instanceof TemporaryProjectFile;\n    }\n    private _isReadonly = false;\n    get isReadonly() {\n        return this._isReadonly;\n    }\n    set isReadonly(value) {\n        this._isReadonly = value;\n    }\n    protected _isReady = false;\n    get isReady() {\n        return this._isReady;\n    }\n    setActive() {\n        this.env.activeInstance = this;\n    }\n    get isActive(): boolean {\n        return this.env.activeInstance === this;\n    }\n    async getEditor(): Promise<IFileEditor> {\n        throw new Error(\"Not implemented.\");\n    }\n    protected readonly _observers = new Set<any>();\n    async addObserver(observer: any) {\n        this._observers.add(observer);\n        await this.emit(\"observers\", this._observers);\n    }\n    async removeObserver(observer: any) {\n        this._observers.delete(observer);\n        await this.emit(\"observers\", this._observers);\n        if (this._observers.size === 0) await this.destroy();\n    }\n    readonly _id: string;\n    get id() {\n        return this._id;\n    }\n    readonly _history: History<any, any>;\n    get history() {\n        return this._history;\n    }\n    constructor({ env, project, file, instanceId, noRegister }: { env: IJSPatcherEnv; project?: IProject; file?: File; instanceId?: string; noRegister?: boolean }) {\n        super();\n        this._env = env;\n        this._project = project;\n        this._file = file;\n        if (!noRegister) this._id = this.env.registerInstance(this, instanceId);\n        this._file?.addObserver(this._id);\n    }\n    async init() {\n        return this;\n    }\n    async serialize(): Promise<ArrayBuffer> {\n        throw new Error(\"Not implemented.\");\n    }\n    async destroy() {\n        await this.emit(\"destroy\");\n        await this.file?.removeObserver(this._id);\n    }\n}\n","import TypedEventEmitter from \"../../utils/TypedEventEmitter\";\nimport { getTimestamp } from \"../../utils/utils\";\nimport FileEditor, { FileEditorEventMap } from \"./FileEditor\";\n\nexport interface HistoryEventMap {\n    \"change\": IHistoryEvent<any>;\n}\n\nexport interface IHistoryEvent<EventMap extends Record<string, any> & Partial<FileEditorEventMap> = {}> {\n    timestamp: number;\n    editorId?: string;\n    fileId: string;\n    eventName?: keyof EventMap & string;\n    eventData?: EventMap[keyof EventMap & string];\n    prevHistoryIndex: number;\n    nextHistoryIndex: number;\n}\n\nexport interface IHistoryData<EventMap extends Record<string, any> & Partial<FileEditorEventMap> = {}> {\n    /** Current index in the event queue */\n    $: number;\n    /** Queued events */\n    eventQueue: IHistoryEvent<EventMap>[];\n}\n\n/** The class records some events and allows to perform undo/redo with a specific editor. */\nexport default abstract class History<EventMap extends Record<string, any> & Partial<FileEditorEventMap> = {}, Editor extends FileEditor<any, EventMap> = FileEditor<any, EventMap>> extends TypedEventEmitter<HistoryEventMap> {\n    /** Editors to sync and to listen */\n    editors: Set<Editor> = new Set();\n    $ = 0;\n    /** index of the save */\n    $save = 0;\n    eventQueue: IHistoryEvent<EventMap>[] = [];\n    /** Another event queue including index changes. There's no going back here. */\n    changes: IHistoryEvent<EventMap>[] = [];\n    /** Can be set to `false` to prevent recording events while undoing/redoing */\n    capture = true;\n    get eventListening(): (keyof EventMap & string)[] {\n        return [];\n    }\n    get now() {\n        return getTimestamp();\n    }\n    get firstEditor(): Editor {\n        return this.editors.values().next().value;\n    }\n    get fileId() {\n        return this.firstEditor.file?.id;\n    }\n\n    addEditor(editor: Editor) {\n        this.editors.add(editor);\n        editor.onAny(this.handleEditorEvent);\n        editor.on(\"saved\", this.handleSaved);\n        editor.once(\"destroy\", () => this.removeEditor(editor));\n        /*\n        editor.once(\"ready\", async () => {\n            const { $ } = this;\n            this.$ = 0;\n            if ($) await this.redoUntil(this.eventQueue[$ - 1].timestamp);\n        });\n        */\n    }\n    removeEditor(editor: Editor) {\n        editor.offAny(this.handleEditorEvent);\n        this.editors.delete(editor);\n    }\n    handleEditorEvent = async (eventName: keyof EventMap & string, eventData: any, editor: Editor) => {\n        if (this.eventListening.indexOf(eventName) === -1) return;\n        if (!this.capture) return;\n        this.capture = false;\n        await Promise.all(Array.from(this.editors).filter($editor => $editor !== editor).map($editor => $editor.emit(eventName, eventData)));\n        this.capture = true;\n        this.eventQueue.splice(this.$);\n        const event: IHistoryEvent<EventMap> = {\n            eventName,\n            eventData,\n            timestamp: this.now,\n            editorId: editor.editorId,\n            fileId: editor.file?.id,\n            prevHistoryIndex: this.$,\n            nextHistoryIndex: this.$ + 1\n        };\n        this.$ = this.eventQueue.push(event);\n        this.emitChanged(event);\n    };\n    emitChanged(event: IHistoryEvent<EventMap>) {\n        this.changes.push(event);\n        this.emit(\"change\", event);\n        this.editors.forEach(editor => editor.emit(\"changed\"));\n        this.emitDirty();\n    }\n    emitDirty() {\n        const { isDirty } = this;\n        this.editors.forEach(editor => editor.emit(\"dirty\", isDirty));\n    }\n    destroy() {\n        this.editors.forEach(editor => this.removeEditor(editor));\n    }\n    get isDirty() {\n        return this.$save !== this.$;\n    }\n    get isUndoable() {\n        return this.$ !== 0;\n    }\n    get isRedoable() {\n        return this.$ !== this.eventQueue.length;\n    }\n    handleSaved = () => {\n        this.$save = this.$;\n        this.emitDirty();\n    };\n    abstract undoOf(editor: Editor, eventName: keyof EventMap, eventData?: any): Promise<void>;\n    async undo(passive = false, ...editors: Editor[]) {\n        if (!this.isUndoable) return;\n        this.capture = false;\n        const { eventName, eventData } = this.eventQueue[this.$ - 1];\n        await Promise.all((editors.length ? editors : Array.from(this.editors)).map(editor => this.undoOf(editor, eventName, eventData)));\n        this.$--;\n        this.capture = true;\n        if (!passive) this.emitChanged({ prevHistoryIndex: this.$ + 1, nextHistoryIndex: this.$, timestamp: this.now, fileId: this.fileId });\n    }\n    abstract redoOf(editor: Editor, eventName: keyof EventMap, eventData?: any): Promise<void>;\n    async redo(passive = false, ...editors: Editor[]) {\n        if (!this.isRedoable) return;\n        this.capture = false;\n        const { eventName, eventData } = this.eventQueue[this.$];\n        await Promise.all((editors.length ? editors : Array.from(this.editors)).map(editor => this.redoOf(editor, eventName, eventData)));\n        this.$++;\n        this.capture = true;\n        if (!passive) this.emitChanged({ prevHistoryIndex: this.$ - 1, nextHistoryIndex: this.$, timestamp: this.now, fileId: this.fileId });\n    }\n    /** event at index exclusive */\n    async undoUntil($: number, passive = false, ...editors: Editor[]) {\n        while (this.isUndoable && $ < this.$) {\n            await this.undo(passive, ...editors);\n        }\n    }\n    /** event at timestamp inclusive */\n    async redoUntil($: number, passive = false, ...editors: Editor[]) {\n        while (this.isRedoable && $ > this.$) {\n            await this.redo(passive, ...editors);\n        }\n    }\n    async setIndex($: number, passive = false) {\n        if ($ < this.$) await this.undoUntil($, passive);\n        else if ($ > this.$) await this.redoUntil($, passive);\n    }\n    getSyncData()/* : IHistoryData<EventMap> */ {\n        // const { $, eventQueue } = this;\n        // return { $, eventQueue };\n    }\n    async syncData(data: IHistoryData<EventMap>) {\n        for (let i = 0; i < this.eventQueue.length; i++) {\n            const { timestamp } = this.eventQueue[i];\n            if (timestamp !== data.eventQueue[i]?.timestamp) {\n                await this.undoUntil(timestamp);\n                break;\n            }\n        }\n        this.eventQueue = data.eventQueue;\n        await this.setIndex(data.$);\n    }\n    async mergeChanges(...changes: IHistoryEvent<EventMap>[]) {\n        if (!changes.length) return;\n        const sortedChanges = changes.filter(e => e.fileId === this.fileId).sort((a, b) => a.timestamp - b.timestamp);\n        if (!sortedChanges.length) return;\n        const t0 = sortedChanges[0].timestamp;\n        let $change = this.changes.length;\n        while ($change && this.changes[$change - 1].timestamp > t0) {\n            $change--;\n        }\n        const unmerge = this.changes.splice($change);\n        await this.unmergeChanges(...unmerge);\n        for (const change of sortedChanges) {\n            const { nextHistoryIndex: $, prevHistoryIndex: $prev, eventData } = change;\n            if (eventData) {\n                if (this.$ !== $prev) await this.setIndex($prev, true);\n                this.eventQueue.splice($prev);\n                this.eventQueue.push(change);\n                await this.setIndex($, true);\n            }\n            await this.setIndex($, true);\n            this.changes.push(change);\n        }\n    }\n    async unmergeChanges(...changes: IHistoryEvent<EventMap>[]) {\n        if (!changes.length) return;\n        const sortedChanges = changes.filter(e => e.fileId === this.fileId).sort((a, b) => a.timestamp - b.timestamp);\n        if (!sortedChanges.length) return;\n        let $change = changes.length - 1;\n        this.capture = false;\n        while ($change >= 0) {\n            const { eventName, eventData, prevHistoryIndex, timestamp } = changes[$change];\n            if (eventData) {\n                await Promise.all((Array.from(this.editors)).map(editor => this.undoOf(editor, eventName, eventData)));\n                this.$ = prevHistoryIndex;\n                const i = this.eventQueue.findIndex(e => e.timestamp === timestamp);\n                if (i >= 0) this.eventQueue.splice(i);\n            } else {\n                await this.setIndex(prevHistoryIndex, true);\n            }\n            const i = this.changes.findIndex(e => e.timestamp === timestamp);\n            if (i >= 0) this.changes.splice(i, 1);\n            $change--;\n        }\n        this.capture = true;\n    }\n    reset() {\n        this.$ = 0;\n        this.$save = 0;\n        this.eventQueue = [];\n        this.changes = [];\n    }\n}\n","import AbstractProjectFile from \"./AbstractProjectFile\";\nimport type { IJSPatcherEnv } from \"../Env\";\nimport type { IProject } from \"../Project\";\nimport type { IFileEditor } from \"./FileEditor\";\nimport type { IFileInstance } from \"./FileInstance\";\nimport type { IProjectFolder } from \"./AbstractProjectFolder\";\nimport type { IPersistentProjectItemManager } from \"./PersistentProjectItemManager\";\n\nexport default class PersistentProjectFile extends AbstractProjectFile<ArrayBuffer, IPersistentProjectItemManager> {\n    /* SharedArrayBuffer\n    private _sab: SharedArrayBuffer;\n    */\n    get sab() {\n        return this.data;\n    }\n    get data() {\n        return this._data;\n    }\n    set data(dataIn: ArrayBuffer) {\n        this._data = dataIn;\n        /* SharedArrayBuffer\n        if (dataIn instanceof SharedArrayBuffer) {\n            this._sab = dataIn;\n            return;\n        }\n        this._sab = new SharedArrayBuffer(dataIn.byteLength);\n        const ui8ab = new Uint8Array(dataIn);\n        const ui8sab = new Uint8Array(this._sab);\n        for (let i = 0; i < ui8ab.length; i++) {\n            ui8sab[i] = ui8ab[i];\n        }\n        */\n    }\n    lastModifiedId: string;\n    constructor(fileMgrIn: IPersistentProjectItemManager, parentIn: IProjectFolder, nameIn: string, dataIn?: ArrayBuffer) {\n        super(fileMgrIn, parentIn, nameIn);\n        this.lastModifiedId = this.id;\n        if (dataIn) this.data = dataIn;\n    }\n    async init() {\n        this.id = this.fileMgr.generateItemId(this);\n        if (!this.data) this.data = await this.fileMgr.readFile(this.path);\n        await this.emit(\"ready\");\n        await this.fileMgr.emitChanged();\n    }\n    clone(parentIn = this.parent, nameIn = this._name, dataIn = this.data) {\n        const Ctor = this.constructor as typeof PersistentProjectFile;\n        return new Ctor(this._fileMgr, parentIn, nameIn, dataIn);\n    }\n    async save(newData: ArrayBuffer, by: any) {\n        this.data = newData;\n        this.lastModifiedId = this.fileMgr.generateItemId(this);\n        await this._fileMgr.putFile(this);\n        await this.emit(\"saved\", by);\n        await this.fileMgr.emitChanged();\n    }\n    async saveAsCopy(parent: IProjectFolder, name: string, newData: ArrayBuffer) {\n        const item = this.clone(parent, name, newData);\n        await this._fileMgr.putFile(item);\n        parent.items.add(item);\n        await this.emitTreeChanged();\n        await this.fileMgr.emitChanged();\n        return item;\n    }\n    async saveAs(to: IProjectFolder, newName: string, newData: ArrayBuffer, by: any) {\n        const { parent, name, data } = this;\n        const from = parent;\n        this.data = newData;\n        this.lastModifiedId = this.fileMgr.generateItemId(this);\n        await this.move(to, newName);\n        await this._fileMgr.putFile(this);\n        const item = this.clone(parent, name, data);\n        await this._fileMgr.putFile(item);\n        parent.items.add(item);\n        await parent.emitTreeChanged();\n        await this.emitTreeChanged();\n        await this.emit(\"pathChanged\", { from: from.path, to: to.path });\n        await this.emit(\"saved\", by);\n        await this.fileMgr.emitChanged();\n        return item;\n    }\n    async rename(newNameIn: string) {\n        const newName = newNameIn.trim();\n        const oldName = this._name;\n        if (newName === oldName) return;\n        if (this.parent.existItem(newNameIn)) throw new Error(`${newName} already exists.`);\n        await this.fileMgr.rename(this.path, `${this.parentPath}/${newNameIn}`);\n        this._name = newName;\n        await this.emitTreeChanged();\n        await this.emit(\"nameChanged\", { oldName, newName });\n        await this.fileMgr.emitChanged();\n    }\n    async move(to: IProjectFolder, newName = this.name) {\n        if (to === this as any) return;\n        if (to === this.parent && newName === this.name) return;\n        if (to.existItem(newName)) throw new Error(`${newName} already exists in ${to.name}`);\n        await this._fileMgr.rename(this.path, `${to.path}/${newName}`);\n        const from = this.parent;\n        from.items.delete(this as any);\n        this.parent = to;\n        const oldName = this._name;\n        this._name = newName;\n        this.parent.items.add(this as any);\n        await from.emitTreeChanged();\n        await this.emitTreeChanged();\n        await this.emit(\"pathChanged\", { from: from.path, to: to.path });\n        if (oldName !== newName) await this.emit(\"nameChanged\", { oldName, newName });\n        await this.fileMgr.emitChanged();\n    }\n    async destroy() {\n        await this._fileMgr.remove(this.path, this.isFolder);\n        this.parent.items.delete(this as any);\n        await this.emitTreeChanged();\n        await this.emit(\"destroyed\");\n        await this.fileMgr.emitChanged();\n    }\n    async instantiate({ env, project, instanceId }: { env: IJSPatcherEnv; project?: IProject; instanceId?: string }): Promise<IFileInstance> {\n        const { type } = this;\n        const Constructor = {\n            patcher: (await import(\"../patcher/Patcher\")).default,\n            audio: (await import(\"../audio/PatcherAudio\")).default,\n            image: (await import(\"../image/PatcherImage\")).default,\n            text: (await import(\"../text/PatcherText\")).default,\n            video: (await import(\"../video/PatcherVideo\")).default,\n            unknown: (await import(\"../text/PatcherText\")).default\n        }[type];\n        if (Constructor) return Constructor.fromProjectItem({ file: this as any, env, project, instanceId }) as Promise<IFileInstance>;\n        throw new Error(\"Not implemented.\");\n    }\n    async instantiateEditor({ env, project, instanceId }: { env: IJSPatcherEnv; project?: IProject; instanceId?: string }): Promise<IFileEditor> {\n        const { type } = this;\n        const Constructor = {\n            patcher: (await import(\"../patcher/PatcherEditor\")).default,\n            audio: (await import(\"../audio/AudioEditor\")).default,\n            image: (await import(\"../image/ImageEditor\")).default,\n            text: (await import(\"../text/TextEditor\")).default,\n            video: (await import(\"../video/VideoEditor\")).default,\n            unknown: (await import(\"../text/TextEditor\")).default\n        }[type];\n        if (Constructor) return Constructor.fromProjectItem({ file: this as any, env, project, instanceId }) as Promise<IFileEditor>;\n        throw new Error(\"Not implemented.\");\n    }\n}\n","import PersistentProjectFile from \"./PersistentProjectFile\";\nimport AbstractProjectFolder, { IProjectFolder } from \"./AbstractProjectFolder\";\nimport type { IPersistentProjectItemManager } from \"./PersistentProjectItemManager\";\n\nexport default class PersistentProjectFolder extends AbstractProjectFolder<IPersistentProjectItemManager> {\n    async init() {\n        this.id = this.fileMgr.generateItemId(this);\n        const items = await this.fileMgr.readDir(this.path || \"/\");\n        for (const rawItem of items) {\n            const { name, isFolder } = rawItem;\n            const item = this.createProjectItem(name, isFolder);\n            this.items.add(item);\n            await this.emitTreeChanged();\n            await item.init();\n        }\n        await this.emit(\"ready\");\n        await this.fileMgr.emitChanged();\n    }\n    clone(parentIn = this.parent, nameIn = this._name) {\n        const Ctor = this.constructor as typeof PersistentProjectFolder;\n        return new Ctor(this._fileMgr, parentIn, nameIn);\n    }\n    createProjectItem(nameIn: string, isFolder: boolean, dataIn?: ArrayBuffer): PersistentProjectFolder | PersistentProjectFile {\n        if (isFolder) return new PersistentProjectFolder(this.fileMgr, this, nameIn);\n        return new PersistentProjectFile(this.fileMgr, this, nameIn, dataIn);\n    }\n    async addFile(nameIn: string, dataIn?: ArrayBuffer) {\n        if (this.existItem(nameIn)) throw new Error(`${nameIn} already exists.`);\n        const tempItem = new PersistentProjectFile(this.fileMgr, this, nameIn, dataIn);\n        await this.fileMgr.putFile(tempItem);\n        const item = this.createProjectItem(nameIn, false, dataIn);\n        this.items.add(item);\n        await item.init();\n        await this.emitTreeChanged();\n        return item;\n    }\n    async addFolder(name: string) {\n        if (this.existItem(name)) throw new Error(`${name} already exists.`);\n        const folder = new PersistentProjectFolder(this.fileMgr, this, name);\n        await this.fileMgr.putFile(folder);\n        this.items.add(folder);\n        await folder.init();\n        await this.emitTreeChanged();\n        return folder;\n    }\n    async rename(newNameIn: string) {\n        const newName = newNameIn.trim();\n        const oldName = this._name;\n        if (newName === oldName) return;\n        if (this.parent.existItem(newNameIn)) throw new Error(`${newName} already exists.`);\n        await this.fileMgr.rename(this.path, `${this.parentPath}/${newNameIn}`);\n        this._name = newName;\n        await this.emitTreeChanged();\n        await this.emit(\"nameChanged\", { oldName, newName });\n    }\n    async move(to: IProjectFolder, newName = this.name) {\n        if (to === this) return;\n        if (to === this.parent && newName === this.name) return;\n        if (to.existItem(newName)) throw new Error(`${newName} already exists in ${to.name}`);\n        await this._fileMgr.rename(this.path, `${to.path}/${newName}`);\n        const from = this.parent;\n        from.items.delete(this);\n        this.parent = to;\n        const oldName = this._name;\n        this._name = newName;\n        this.parent.items.add(this);\n        await from.emitTreeChanged();\n        await this.emitTreeChanged();\n        await this.emit(\"pathChanged\", { from: from.path, to: to.path });\n        if (oldName !== newName) await this.emit(\"nameChanged\", { oldName, newName });\n    }\n    async destroy() {\n        await this._fileMgr.remove(this.path, this.isFolder);\n        this.parent?.items.delete(this as any);\n        await this.emitTreeChanged();\n        await this.emit(\"destroyed\");\n    }\n}\n","import TemporaryProjectFile from \"./TemporaryProjectFile\";\n\nexport default class TempData extends TemporaryProjectFile {\n    get type() {\n        return \"unknown\" as const;\n    }\n    async instantiate(): Promise<any> {\n        return this.data;\n    }\n}\n","import AbstractProjectFile from \"./AbstractProjectFile\";\nimport PersistentProjectFile from \"./PersistentProjectFile\";\nimport type TemporaryProjectItemManager from \"./TemporaryProjectItemManager\";\nimport type PersistentProjectItemManager from \"./PersistentProjectItemManager\";\nimport type { IProjectFolder } from \"./AbstractProjectFolder\";\nimport type { IJSPatcherEnv } from \"../Env\";\nimport type { IProject } from \"../Project\";\nimport type { IFileEditor } from \"./FileEditor\";\nimport type { IFileInstance } from \"./FileInstance\";\n\n/**\n * An item under TempMgr, this contains in-memory data/instance.\n */\nexport default class TemporaryProjectFile<Data = any> extends AbstractProjectFile<Data, TemporaryProjectItemManager> {\n    async removeObserver(observer: string) {\n        await super.removeObserver(observer);\n        await this.fileMgr.emitChanged();\n        if (this._observers.size === 0) await this.destroy();\n    }\n    /**\n     * Creating alias (do not copy the data, new item has the same ref)\n     */\n    clone(parentIn = this.parent, nameIn = this._name, dataIn = this.data) {\n        const Ctor = this.constructor as typeof TemporaryProjectFile;\n        return new Ctor(this._fileMgr, parentIn, nameIn, dataIn);\n    }\n    async rename(newNameIn: string) {\n        const newName = newNameIn.trim();\n        const oldName = this._name;\n        if (newName === oldName) return;\n        if (this.parent.existItem(newNameIn)) throw new Error(`${newName} already exists.`);\n        this._name = newName;\n        await this.emitTreeChanged();\n        await this.emit(\"nameChanged\", { oldName, newName });\n        await this.fileMgr.emitChanged();\n    }\n    async move(to: IProjectFolder, newName = this.name) {\n        if (to === this as any) return;\n        if (to === this.parent) return;\n        if (to.existItem(newName)) throw new Error(`${newName} already exists in ${to.name}`);\n        const from = this.parent;\n        from.items.delete(this);\n        this.parent = to;\n        const oldName = this._name;\n        this._name = newName;\n        this.parent.items.add(this);\n        await from.emitTreeChanged();\n        await this.emitTreeChanged();\n        await this.emit(\"pathChanged\", { from: from.path, to: to.path });\n        if (oldName !== newName) await this.emit(\"nameChanged\", { oldName, newName });\n        await this.fileMgr.emitChanged();\n    }\n    async destroy() {\n        this.parent.items.delete(this);\n        await this.emitTreeChanged();\n        await this.emit(\"destroyed\");\n        await this.fileMgr.emitChanged();\n    }\n    async save(newData: Data, by: any) {\n        this._data = newData;\n        this.emit(\"saved\", by);\n        await this.fileMgr.emitChanged();\n    }\n    async saveAsCopy(parent: IProjectFolder, name: string, newData: ArrayBuffer, persistentMgr?: PersistentProjectItemManager) {\n        const item = new PersistentProjectFile(persistentMgr, parent, name, newData);\n        await persistentMgr.putFile(item);\n        parent.items.add(item);\n        await this.emitTreeChanged();\n        await item.init();\n        return item;\n    }\n    async saveAs(to: IProjectFolder, name: string, newData: ArrayBuffer, by: any, persistentMgr: PersistentProjectItemManager) {\n        const item = new PersistentProjectFile(persistentMgr, to, name, newData);\n        await persistentMgr.putFile(item);\n        const from = this.parent;\n        this.parent = to;\n        this._name = name;\n        const _this: PersistentProjectFile = Object.setPrototypeOf(this, PersistentProjectFile.prototype);\n        this.parent.items.add(_this);\n        await this.emitTreeChanged();\n        await this.emit(\"pathChanged\", { from: from.path, to: to.path });\n        await this.emit(\"saved\", by);\n        await item.init();\n        return this;\n    }\n    async instantiate(options: { env: IJSPatcherEnv; project?: IProject; instanceId?: string }): Promise<IFileInstance> {\n        throw new Error(\"Not implemented.\");\n        // new instance Patcher / AudioBuffer etc\n    }\n    async instantiateEditor(options: { env: IJSPatcherEnv; project?: IProject; instanceId?: string }): Promise<IFileEditor> {\n        throw new Error(\"Not implemented.\");\n    }\n}\n","import TempAudioFile from \"../audio/TempAudioFile\";\nimport TempPatcherFile from \"../patcher/TempPatcherFile\";\nimport TempTextFile from \"../text/TempTextFile\";\nimport TempData from \"./TempData\";\nimport AbstractProjectFolder, { IProjectFolder } from \"./AbstractProjectFolder\";\nimport type TemporaryProjectFile from \"./TemporaryProjectFile\";\nimport type { TempItemType } from \"../types\";\nimport type TemporaryProjectItemManager from \"./TemporaryProjectItemManager\";\n\nexport default class TemporaryProjectFolder extends AbstractProjectFolder<TemporaryProjectItemManager> {\n    async init() {\n        this.id = this.fileMgr.generateItemId(this);\n        await this.emit(\"ready\");\n    }\n    clone(parentIn = this.parent, nameIn = this._name) {\n        const Ctor = this.constructor as typeof TemporaryProjectFolder;\n        return new Ctor(this._fileMgr, parentIn, nameIn);\n    }\n    createProjectItem(name: string, isFolder: boolean, data?: any, typeIn?: TempItemType): TemporaryProjectFile {\n        const type = typeIn || this.fileMgr.getTypeFromFileName(name);\n        if (type === \"patcher\") return new TempPatcherFile(this.fileMgr, this, name, data);\n        if (type === \"audio\") return new TempAudioFile(this.fileMgr, this, name, data);\n        if (type === \"text\") return new TempTextFile(this.fileMgr, this, name, data);\n        return new TempData(this.fileMgr, this, name, data);\n    }\n    async addFile(name: string, data?: any, typeIn?: TempItemType) {\n        if (this.existItem(name)) throw new Error(`${name} already exists.`);\n        const item = this.createProjectItem(name, false, data, typeIn);\n        this.items.add(item);\n        await this.emitTreeChanged();\n        await item.init();\n        return item;\n    }\n    async addFolder(name: string) {\n        if (this.existItem(name)) throw new Error(`${name} already exists.`);\n        const folder = new TemporaryProjectFolder(this.fileMgr, this, name);\n        this.items.add(folder);\n        await folder.init();\n        await this.emitTreeChanged();\n        await this.fileMgr.emitChanged();\n        return folder;\n    }\n    async rename(newNameIn: string) {\n        const newName = newNameIn.trim();\n        const oldName = this._name;\n        if (newName === oldName) return;\n        if (this.parent.existItem(newNameIn)) throw new Error(`${newName} already exists.`);\n        this._name = newName;\n        await this.emitTreeChanged();\n        await this.emit(\"nameChanged\", { oldName, newName });\n        await this.fileMgr.emitChanged();\n    }\n    async move(to: IProjectFolder, newName = this.name) {\n        if (to === this) return;\n        if (to === this.parent) return;\n        if (to.existItem(newName)) throw new Error(`${newName} already exists in ${to.name}`);\n        const from = this.parent;\n        from.items.delete(this);\n        this.parent = to;\n        const oldName = this._name;\n        this._name = newName;\n        this.parent.items.add(this);\n        await from.emitTreeChanged();\n        await this.emitTreeChanged();\n        await this.emit(\"pathChanged\", { from: from.path, to: to.path });\n        if (oldName !== newName) await this.emit(\"nameChanged\", { oldName, newName });\n        await this.fileMgr.emitChanged();\n    }\n    async destroy() {\n        this.parent.items.delete(this);\n        await this.emitTreeChanged();\n        await this.emit(\"destroyed\");\n        await this.fileMgr.emitChanged();\n    }\n}\n","import TemporaryProjectFolder from \"./TemporaryProjectFolder\";\nimport AbstractProjectItemManager from \"./AbstractProjectItemManager\";\nimport type { IProjectFileOrFolder } from \"./AbstractProjectItem\";\n\nexport default class TemporaryProjectItemManager extends AbstractProjectItemManager {\n    root: TemporaryProjectFolder;\n    async empty() {\n        return true;\n    }\n    async init(clean?: boolean) {\n        this.root = new TemporaryProjectFolder(this, null, null);\n        await this.root.init();\n        this.emit(\"ready\");\n        return this;\n    }\n    getProjectItemFromPath(path: string) {\n        const pathArray = path.split(\"/\");\n        const itemArray: IProjectFileOrFolder[] = [this.root];\n        for (let i = 0; i < pathArray.length; i++) {\n            const id = pathArray[i];\n            if (id.length === 0) continue;\n            if (id === \".\") continue;\n            if (id === \"..\") {\n                itemArray.pop();\n                continue;\n            }\n            const cur = itemArray[itemArray.length - 1];\n            if (cur.isFolder === false) throw new Error(`${cur.name} from path ${path} is not a folder`);\n            const next = cur.findItem(id);\n            if (!next) throw new Error(`Cannot find ${id} from path ${path}`);\n            itemArray.push(next);\n        }\n        return itemArray[itemArray.length - 1];\n    }\n}\n","import AbstractProjectItemManager, { IProjectItemManager } from \"./AbstractProjectItemManager\";\nimport PersistentProjectFolder from \"./PersistentProjectFolder\";\nimport type { TypedMessagePort } from \"../workers/Worker\";\nimport type WorkletEnvProcessor from \"../worklets/WorkletEnv.worklet\";\nimport type { IProjectFolder } from \"./AbstractProjectFolder\";\nimport type { IPersistentProjectItemManager, ProjectItemManagerDataForDiff } from \"./PersistentProjectItemManager\";\nimport type { IProjectItem } from \"./AbstractProjectItem\";\nimport type PersistentProjectFile from \"./PersistentProjectFile\";\n\nexport default class WorkletProjectItemManager extends AbstractProjectItemManager implements IPersistentProjectItemManager {\n    readonly port: TypedMessagePort;\n    readonly env: WorkletEnvProcessor;\n    cachedPathIdMap: Record<string, string> = {};\n    disabled = false;\n    constructor(envIn: WorkletEnvProcessor) {\n        super(envIn);\n        this.env = envIn;\n    }\n    empty(): Promise<any> {\n        throw new Error(\"Empty is not allowed from other threads.\");\n    }\n    async init() {\n        this.cachedPathIdMap = await this.env.fileMgrGetPathIdMap();\n        this.root = new PersistentProjectFolder(this, null, null);\n        await this.root.init();\n        if (!this.projectRoot) await this.root.addFolder(this.projectFolderName);\n        this.emit(\"ready\");\n        return this;\n    }\n    getDataForDiff() {\n        const map: ProjectItemManagerDataForDiff = {};\n        const { allItems } = this;\n        for (const id in allItems) {\n            const item = allItems[id] as PersistentProjectFile | PersistentProjectFolder;\n            if (item.isFolder === true) map[id] = { isFolder: item.isFolder, parent: item.parent?.id, name: item.name, path: item.path };\n            else map[id] = { isFolder: item.isFolder, data: item.sab, lastModifiedId: item.lastModifiedId, parent: item.parent?.id, name: item.name, path: item.path };\n        }\n        return map;\n    }\n    async processDiff(diff: ProjectItemManagerDataForDiff) {\n        this.disabled = true;\n        for (const id in this.allItems) {\n            if (!(id in diff)) {\n                const current = this.getProjectItemFromId(id);\n                if (current) await current.destroy();\n            }\n        }\n        for (const id in diff) {\n            const process = async (id: string): Promise<void> => {\n                const $item = diff[id];\n                const $parentId = $item.parent;\n                if (!$parentId) return;\n                let parent = this.getProjectItemFromId($parentId);\n                if (!parent) await process($parentId);\n                parent = this.getProjectItemFromId($parentId) as PersistentProjectFolder;\n                const current = this.getProjectItemFromId(id) as PersistentProjectFile | PersistentProjectFolder;\n                if (current) {\n                    if (current.isFolder === false && $item.isFolder === false) {\n                        if (current.lastModifiedId !== $item.lastModifiedId) await current.save($item.data, this);\n                        if (current.name !== $item.name) await current.rename($item.name);\n                        if (current.parent?.id !== $item.parent) await current.move(parent);\n                    }\n                } else {\n                    if (parent.isFolder === true) {\n                        this.cachedPathIdMap[$item.path] = id;\n                        if ($item.isFolder === true) {\n                            await parent.addFolder($item.name);\n                        } else {\n                            const newFile = await parent.addFile($item.name, $item.data) as PersistentProjectFile;\n                            newFile.lastModifiedId = $item.lastModifiedId;\n                        }\n                    }\n                }\n            };\n            await process(id);\n        }\n        this.disabled = false;\n    }\n    generateItemId(item: IProjectItem) {\n        if (!item.path) return \"root\";\n        const id = this.cachedPathIdMap[item.path];\n        if (!id) return this.env.generateId(item);\n        delete this.cachedPathIdMap[item.path];\n        return id;\n    }\n    readFile(path: string) {\n        return this.env.fileMgrReadFile(path);\n    }\n    readDir(path?: string): Promise<{ isFolder: boolean; name: string }[]> {\n        return this.env.fileMgrReadDir(path);\n    }\n    getFileDetails(path: string, name: string) {\n        return this.env.fileMgrGetFileDetails(path, name);\n    }\n    exists(path: string) {\n        return this.env.fileMgrExists(path);\n    }\n    putFile(item: { isFolder: boolean; path: string; data?: ArrayBuffer | SharedArrayBuffer }) {\n        if (this.disabled) return null;\n        return this.env.fileMgrPutFile(item);\n    }\n    async writeFile(path: string, data: ArrayBuffer | SharedArrayBuffer) {\n        if (this.disabled) return null;\n        return this.env.fileMgrWriteFile(path, data);\n    }\n    async remove(path: string, isFolder?: boolean) {\n        return true;\n    }\n    async rename(oldPath: string, newPath: string) {\n        return true;\n    }\n    importFileZip(data: ArrayBuffer, subfolder?: string, to?: IProjectFolder<IProjectItemManager<{}>>, taskHost?: any): Promise<void> {\n        throw new Error(\"Import is not allowed from other threads.\");\n    }\n    exportProjectZip(): Promise<ArrayBuffer> {\n        throw new Error(\"Import is not allowed from other threads.\");\n    }\n}\n","import type { SemanticICONS } from \"semantic-ui-react\";\nimport TypedEventEmitter from \"../../../utils/TypedEventEmitter\";\nimport { stringifyError } from \"../../../utils/utils\";\nimport Line from \"../../patcher/Line\";\nimport type Box from \"../../patcher/Box\";\nimport type Patcher from \"../../patcher/Patcher\";\nimport type { ProjectItemType, TempItemByType, SharedItemByType, TempItemType, TAudioNodeInletConnection, TAudioNodeOutletConnection } from \"../../types\";\nimport type AbstractUI from \"./AbstracttUI\";\nimport type { IJSPatcherEnv } from \"../../Env\";\n\nexport const isJSPatcherObjectConstructor = (x: any): x is typeof AbstractObject => typeof x === \"function\" && x?.isJSPatcherObjectConstructor;\n\nexport const isJSPatcherObject = (x: any): x is AbstractObject => typeof x === \"object\" && x?.isJSPatcherObject;\n\nexport type TMetaType = \"anything\" | \"signal\" | \"object\" | \"number\" | \"boolean\" | \"string\" | \"function\" | \"bang\" | \"color\" | \"enum\";\nexport interface IInletMeta {\n    isHot: boolean;\n    type: TMetaType;\n    enums?: string[];\n    varLength?: boolean;\n    description: string;\n}\nexport type IInletsMeta = IInletMeta[];\nexport interface IOutletMeta {\n    type: TMetaType;\n    enums?: string[];\n    varLength?: boolean;\n    description: string;\n}\nexport type IOutletsMeta = IOutletMeta[];\nexport interface IArgMeta {\n    type: TMetaType;\n    enums?: string[];\n    optional: boolean;\n    default?: any;\n    varLength?: boolean;\n    description: string;\n}\nexport type IArgsMeta = IArgMeta[];\nexport interface IPropMeta<T extends any = any> {\n    type: TMetaType;\n    enums?: T[];\n    default: T;\n    group?: string;\n    description: string;\n    isUIState?: boolean;\n}\nexport type IPropsMeta<T extends Record<string, any> = Record<string, any>> = { [K in keyof T]: IPropMeta<T[K]> };\nexport interface IJSPatcherObjectMeta<P extends Record<string, any> = Record<string, any>> {\n    package: string; // div will have class \"package-name\" \"package-name-objectname\"\n    name: string;\n    icon: SemanticICONS; // semantic icon to display in UI\n    author: string;\n    version: string;\n    description: string;\n    inlets: IInletsMeta;\n    outlets: IOutletsMeta;\n    args: IArgsMeta;\n    props: IPropsMeta<P>;\n    isPatcherInlet: \"data\" | \"audio\" | \"parameter\" | false;\n    isPatcherOutlet: \"data\" | \"audio\" | false;\n}\n\nexport interface ObjectUpdateOptions {\n    /** The ID will be passed through update*, set* and *Updated events */\n    id?: string;\n    undoable?: boolean;\n}\n\nexport type Data<T> = T extends IJSPatcherObject<infer D, any, any, any, any, any, any, any> ? D : never;\nexport type State<T> = T extends IJSPatcherObject<any, infer S, any, any, any, any, any, any> ? S : never;\nexport type Inputs<T> = T extends IJSPatcherObject<any, any, infer I, any, any, any, any, any> ? I : never;\nexport type Outputs<T> = T extends IJSPatcherObject<any, any, any, infer O, any, any, any, any> ? O : never;\nexport type Args<T> = T extends IJSPatcherObject<any, any, any, any, infer A, any, any, any> ? A : never;\nexport type Props<T> = T extends IJSPatcherObject<any, any, any, any, any, infer P, any, any> ? P : never;\nexport type UIState<T> = T extends IJSPatcherObject<any, any, any, any, any, any, infer U, any> ? U : never;\nexport type EventMap<T> = T extends IJSPatcherObject<any, any, any, any, any, any, any, infer E> ? E : never;\nexport type TInletEvent<I extends any[] = any[], $ extends keyof Pick<I, number> = keyof Pick<I, number>> = { inlet: $; data: I[$] };\nexport type TOutletEvent<O extends any[] = any[], $ extends keyof Pick<O, number> = keyof Pick<O, number>> = { outlet: $; data: O[$] };\nexport type JSPatcherObjectEventMap<D, S, I extends any[], A extends any[], P, U, E> = {\n    /** Emitted before any connection */\n    \"preInit\": never;\n    /** Emitted after connections */\n    \"postInit\": never;\n    /** Emitted immediately when the editor request changes to the args */\n    \"updateArgs\": Partial<A>;\n    /** Emitted immediately when the editor request changes to the props */\n    \"updateProps\": Partial<P>;\n    /** Emitted immediately when the editor request changes to the state */\n    \"updateState\": { id?: string; state: Partial<S> };\n    /** The UI will listen to this event type */\n    \"updateUI\": Partial<U> | never;\n    /** Emitted if received any input */\n    \"inlet\": TInletEvent<I>;\n    /** Emitted when a new connection/disconnection is made on any I/O */\n    \"connectedInlet\": { inlet: number; srcBoxId: string; srcOutlet: number; lineId: string };\n    \"connectedOutlet\": { outlet: number; destBoxId: string; destInlet: number; lineId: string };\n    \"disconnectedInlet\": { inlet: number; srcBoxId: string; srcOutlet: number; lineId: string };\n    \"disconnectedOutlet\": { outlet: number; destBoxId: string; destInlet: number; lineId: string };\n    /** Emitted when the object will be destroyed, attach a callback to clean up */\n    \"destroy\": never;\n    /** Emitted when the object's metadata is changed (by itself) */\n    \"metaUpdated\": { oldMeta: IJSPatcherObjectMeta; meta: IJSPatcherObjectMeta };\n    /** Emitted when the object's args is changed */\n    \"argsUpdated\": { oldArgs: A; args: A };\n    /** Emitted when the object's data is changed */\n    \"propsUpdated\": { oldProps: Partial<P>; props: Partial<P> };\n    /** Emitted when the object's data is changed (by itself) */\n    \"dataUpdated\": { oldData: D; data: D };\n    /** Emitted when the object's state is changed */\n    \"stateUpdated\": { oldState: S; state: S; id?: string };\n} & E;\n\n/**\n * All JSPatcher Object should extends this class\n *\n * @template D serializable, type of `data` property, use `setData` to update. Data will be stored with the box in the serialized patcher. Will mark the patcher `dirty`.\n * @template S serializable, type of `state` property, use `setState` to update. State is temporary to the object instance. Can be updated from the host.\n * @template I type of inlets as an array.\n * @template O type of outlets as an array.\n * @template A serializable, type of args as an array.\n * @template P serializable, type of props as a map.\n * @template U type of UI state as a map, the UI will listen to any update of this map. If the object can be running on another thread, this should be serializable.\n * @template E type of additional event map\n */\nexport interface IJSPatcherObject<\n    D extends {} = {},\n    S extends {} = {},\n    I extends any[] = any[],\n    O extends any[] = any[],\n    A extends any[] = any[],\n    P extends {} = {},\n    U extends {} = {},\n    E extends Partial<JSPatcherObjectEventMap<D, S, I, A, P, U, {}>> & Record<string, any> = {}\n> extends TypedEventEmitter<JSPatcherObjectEventMap<D, S, I, A, P, U, E>> {\n    /** Should be true */\n    readonly isJSPatcherObject: true;\n    /** Unique identifier of the object */\n    readonly id: string;\n    /** constructor (class) name */\n    readonly class: string;\n    /** the patcher that the object lives in */\n    readonly patcher: Patcher;\n    /** Patcher constructor */\n    readonly Patcher: typeof Patcher;\n    /** the box that the object lives in */\n    readonly box: Box<this>;\n    /** the env that the object lives in */\n    readonly env: IJSPatcherEnv;\n    readonly audioCtx?: AudioContext;\n    readonly meta: IJSPatcherObjectMeta<P>;\n    setMeta(metaIn: Partial<IJSPatcherObjectMeta>): void;\n    /** Serializable, use `setState` to update. State is temporary to the object instance. Can be updated from the host. */\n    state: S;\n    setState(stateIn: Partial<S>, id?: string): void;\n    /** Serializable, type of `data` property, use `setData` to update. Data will be stored with the box in the serialized patcher. */\n    readonly data: D;\n    setData(dataIn: Partial<D>): void;\n    /** Get all props from box, if not defined, get from metadata default */\n    readonly props: Partial<P>;\n    /** Get prop value from box, if not defined, get from metadata default. */\n    getProp<K extends keyof P = keyof P>(key: K): P[K];\n    setProps(props: Partial<P>): void;\n    readonly args: Partial<A>;\n    setArgs(args: Partial<A>): void;\n    inlets: number;\n    outlets: number;\n    readonly inletLines: Set<Line>[];\n    readonly outletLines: Set<Line>[];\n    inletAudioConnections: TAudioNodeInletConnection<AudioNode | AudioParam>[];\n    outletAudioConnections: TAudioNodeOutletConnection[];\n\n    // for box\n    /** Will be called just after constructed */\n    init(): Promise<void>;\n    /** Will be called after the object attached to box */\n    postInit(): Promise<void>;\n    /** Will be called when need to change arguments */\n    updateArgs(args: A, options?: ObjectUpdateOptions): Promise<void>;\n    /** Will be called when need to change properties */\n    updateProps(props: Partial<P>, options?: ObjectUpdateOptions): Promise<void>;\n    /** Will be called when need to change state */\n    updateState(state: Partial<S>, options?: ObjectUpdateOptions): Promise<void>;\n    /** Main function when receive data from a inlet (base 0). */\n    fn<$ extends number = number>(inlet: $, data: I[$]): void;\n    /** Called when object will be destroyed. */\n    destroy(): Promise<void>;\n    // called when inlet or outlet are connected or disconnected\n    connectedInlet(inlet: number, srcBoxId: string, srcOutlet: number, lineId: string): void;\n    disconnectedInlet(inlet: number, srcBoxId: string, srcOutlet: number, lineId: string): void;\n    connectedOutlet(outlet: number, destBoxId: string, destInlet: number, lineId: string): void;\n    disconnectedOutlet(outlet: number, destBoxId: string, destInlet: number, lineId: string): void;\n    /** Highlight the UI box. */\n    highlight(): void;\n\n    // for developer\n    /** Update UI's React State. */\n    updateUI(state: Partial<U>): void;\n    /** Output data with ith outlet. */\n    outlet<$ extends number>(outlet: $, data: O[$]): void;\n    /**\n     * Outlet all values in an array with corresponding index,\n     * use sparse array to omit an outlet,\n     * `[, 1]` will outlet 1 on second outlet,\n     * but `[undefined, 1]` will also outlet undefined on first outlet\n     */\n    outletAll(outputs: Partial<O>): void;\n    /** Record an undoable operation to the patcher history */\n    undoable(e: { oldArgs?: A; args?: A; oldProps?: Partial<P>; props?: Partial<P>; oldState?: S; state?: S }): void;\n    /**\n     * Get a shared item from files or temp\n     * If no ID provided, this will create a new key in temp\n     * if no such ID found in files or in temp, will put the result of data() into it.\n     */\n    getSharedItem<T extends ProjectItemType>(id?: string, type?: T, data?: () => Promise<TempItemByType<T>[\"data\"]>, onceCreate?: (aitem: SharedItemByType<T>) => any): Promise<{ id: string; item: SharedItemByType<T>; newItem: boolean; off?: () => any }>;\n    // output to console\n    post(data: any): void;\n    error(data: any): void;\n    info(data: any): void;\n    warn(data: any): void;\n    connectAudio(): void;\n    connectAudioInlet(portIn?: number): void;\n    connectAudioOutlet(portIn?: number): void;\n    disconnectAudio(): void;\n    disconnectAudioInlet(portIn?: number): void;\n    disconnectAudioOutlet(portIn?: number): void;\n    applyBPF(param: AudioParam, bpf: number[][]): void;\n}\nexport declare const IJSPatcherObject: {\n    /** Should be true */\n    readonly isJSPatcherObjectConstructor: true;\n    /** div will have class \"packageName\" \"packageName-objectName\" */\n    package: string;\n    readonly _name: string;\n    icon: SemanticICONS;\n    author: string;\n    version: string;\n    description: string;\n    inlets: IInletsMeta;\n    outlets: IOutletsMeta;\n    args: IArgsMeta;\n    props: IPropsMeta;\n    isPatcherInlet: \"data\" | \"audio\" | false;\n    isPatcherOutlet: \"data\" | \"audio\" | false;\n    readonly meta: IJSPatcherObjectMeta;\n    /**\n     * The UI that the object uses to display in the patcher, not available in other threads.\n     * is `BaseUI` by default\n     */\n    UI?: typeof AbstractUI;\n    new (box: Box, patcher: Patcher): IJSPatcherObject;\n};\n\nexport interface AnyJSPatcherObject extends IJSPatcherObject<Record<string, any>, Record<string, any>, any[], any[], any[], Record<string, any>, Record<string, any>, Record<string, any>> {}\n\nexport default abstract class AbstractObject<\n    D extends {} = {},\n    S extends {} = {},\n    I extends any[] = any[],\n    O extends any[] = any[],\n    A extends any[] = any[],\n    P extends {} = {},\n    U extends {} = {},\n    E extends Partial<JSPatcherObjectEventMap<D, S, I, A, P, U, {}>> & Record<string, any> = {}\n> extends TypedEventEmitter<JSPatcherObjectEventMap<D, S, I, A, P, U, E>> implements IJSPatcherObject<D, S, I, O, A, P, U, E> {\n    static readonly isJSPatcherObjectConstructor = true as const;\n    static package = \"Base\";\n    static get _name() {\n        return this.name;\n    }\n    static icon = null as SemanticICONS;\n    static author = \"\";\n    static version = \"0.0.0\";\n    static description = \"\";\n    static inlets: IInletsMeta = [];\n    static outlets: IOutletsMeta = [];\n    static args: IArgsMeta = [];\n    static props: IPropsMeta = {};\n    static isPatcherInlet: \"data\" | \"audio\" | false = false;\n    static isPatcherOutlet: \"data\" | \"audio\" | false = false;\n    static get meta(): IJSPatcherObjectMeta {\n        return {\n            package: this.package, // div will have class \"package-name\" \"package-name-objectname\"\n            name: this._name,\n            icon: this.icon, // semantic icon to display in UI\n            author: this.author,\n            version: this.version,\n            description: this.description,\n            inlets: this.inlets,\n            outlets: this.outlets,\n            args: this.args,\n            props: this.props,\n            isPatcherInlet: this.isPatcherInlet,\n            isPatcherOutlet: this.isPatcherOutlet\n        };\n    }\n    static UI: typeof AbstractUI;\n\n    readonly isJSPatcherObject = true as const;\n    readonly id: string;\n    get class() {\n        return this.constructor.name;\n    }\n    protected readonly _patcher: Patcher;\n    get patcher() {\n        return this._patcher;\n    }\n    get Patcher() {\n        return this._patcher.constructor as typeof Patcher;\n    }\n    protected readonly _box: Box<this>;\n    get box() {\n        return this._box;\n    }\n    get env() {\n        return this.patcher.env;\n    }\n    get audioCtx() {\n        return this.patcher.audioCtx;\n    }\n    private _meta = (this.constructor as typeof AbstractObject).meta as IJSPatcherObjectMeta<P>;\n    get meta(): IJSPatcherObjectMeta<P> {\n        return this._meta;\n    }\n    setMeta(metaIn: Partial<IJSPatcherObjectMeta<P>>) {\n        const oldMeta = { ...this.meta };\n        this._meta = Object.assign(this.meta, metaIn);\n        this.emit(\"metaUpdated\", { oldMeta, meta: { ...this.meta } });\n    }\n    state: S;\n    setState = (stateIn: Partial<S>, id?: string) => {\n        const oldState = { ...this.state };\n        this.state = Object.assign(this.state, stateIn);\n        this.emit(\"stateUpdated\", { oldState, state: { ...this.state }, id });\n    };\n    get data(): D {\n        return this._box.data;\n    }\n    setData(dataIn: Partial<D>) {\n        const oldData = { ...this._box.data };\n        this._box.data = Object.assign(this.data, dataIn) as any;\n        this.emit(\"dataUpdated\", { oldData, data: { ...this.data } });\n    }\n    get props(): Partial<P> {\n        const props: Partial<P> = {};\n        for (const key in this.meta.props) {\n            props[key as keyof P] = this.getProp(key as keyof P);\n        }\n        return props;\n    }\n    getProp<K extends keyof P = keyof P>(key: K): P[K] {\n        if (key === \"rect\") return this.box.rect as any;\n        if (key === \"presentationRect\") return this.box.presentationRect as any;\n        if (key === \"background\") return this.box.background as any;\n        if (key === \"presentation\") return this.box.presentation as any;\n        return typeof this.box.props[key] === \"undefined\" ? this.meta.props[key].default : this.box.props[key];\n    }\n    setProps = (propsIn: Partial<P>) => {\n        const keys = Object.keys(propsIn);\n        const oldProps = { ...this.props } as Partial<P>;\n        this.box.update({ props: propsIn });\n        const props = { ...this.props } as Partial<P>;\n        for (const key in oldProps) {\n            if (keys.indexOf(key) === -1) {\n                delete oldProps[key];\n                delete props[key];\n            }\n        }\n        this.emit(\"propsUpdated\", { oldProps, props });\n    };\n    get args(): Partial<A> {\n        return this.box.args as any;\n    }\n    setArgs = (args: Partial<A>) => {\n        const oldArgs = this.args.slice() as A;\n        this.box.update({ args });\n        this.emit(\"argsUpdated\", { oldArgs, args: this.args.slice() as A });\n    };\n    get inlets() {\n        return this._box.inlets;\n    }\n    set inlets(i: number) {\n        this._box.setInlets(i);\n    }\n    get outlets() {\n        return this._box.outlets;\n    }\n    set outlets(i: number) {\n        this._box.setOutlets(i);\n    }\n    get outletLines() {\n        return this._box.outletLines;\n    }\n    get inletLines() {\n        return this._box.inletLines;\n    }\n    inletAudioConnections: TAudioNodeInletConnection[] = [];\n    outletAudioConnections: TAudioNodeOutletConnection[] = [];\n    constructor(box: Box, patcher: Patcher) {\n        super();\n        // line connected = metaChange event subscribed\n        // patcher object outside, use _ for prevent recursive stringify\n        this._patcher = patcher;\n        // the box which create this instance, use _ for prevent recursive stringify\n        this._box = box as Box<this>;\n        this.id = this.env.generateId(this);\n    }\n    async init() {\n        // process args and props\n        this.subscribe();\n        await this.emit(\"preInit\");\n    }\n    async postInit() {\n        await this.emit(\"postInit\");\n    }\n    /** Do everything here */\n    subscribe(): void {}\n    updateUI(state: Partial<U>) {\n        this.emit(\"updateUI\", state);\n    }\n    async updateArgs(args: A, options?: ObjectUpdateOptions) {\n        if (args?.length) {\n            const oldArgs = this.args.slice() as A;\n            await this.emit(\"updateArgs\", args);\n            if (options?.undoable) this.undoable({ oldArgs, args: this.args.slice() as A });\n        }\n    }\n    async updateProps(propsIn: Partial<P>, options?: ObjectUpdateOptions) {\n        if (propsIn && Object.keys(propsIn).length) {\n            const keys = Object.keys(propsIn);\n            const oldProps = { ...this.props };\n            await this.emit(\"updateProps\", propsIn);\n            const props = { ...this.props };\n            for (const key in oldProps) {\n                if (keys.indexOf(key) === -1) {\n                    delete oldProps[key];\n                    delete props[key];\n                }\n            }\n            if (options?.undoable) this.undoable({ oldProps, props });\n        }\n    }\n    async updateState(state: Partial<S>, options?: ObjectUpdateOptions) {\n        if (state && Object.keys(state).length) {\n            const oldState = { ...this.state };\n            await this.emit(\"updateState\", { id: options?.id, state });\n            if (options?.undoable) this.undoable({ oldState, state: { ...this.state } });\n        }\n    }\n    fn<$ extends keyof Pick<I, number> = keyof Pick<I, number>>(inlet: $, data: I[$]) {\n        if (inlet === 0) { // allow change props via first inlet with an props object\n            if (data !== null && typeof data === \"object\") {\n                const propsInKeys = Object.keys(data);\n                const propsKeys = Object.keys(this.meta.props);\n                if (propsInKeys.length && propsInKeys.every(k => propsKeys.indexOf(k) !== -1)) {\n                    this.updateProps(data);\n                    return;\n                }\n            }\n        }\n        this.emit(\"inlet\", { data, inlet });\n    }\n    outlet<$ extends keyof Pick<O, number>>(outlet: $, data: O[$]) {\n        if (outlet >= this.outlets) return;\n        Array.from(this.outletLines[outlet]).sort(Line.compare).map(line => line.pass(data));\n    }\n    outletAll(outputs: Partial<O>) {\n        for (let i = outputs.length - 1; i >= 0; i--) {\n            if (i in outputs) this.outlet(i, outputs[i]);\n        }\n    }\n    undoable(e: { oldArgs?: A; args?: A; oldProps?: Partial<P>; props?: Partial<P>; oldState?: S; state?: S }) {\n        this.box.undoable(e as any);\n    }\n    async destroy() {\n        await this.emit(\"destroy\");\n    }\n    connectedOutlet(outlet: number, destBoxId: string, destInlet: number, lineId: string) {\n        this.emit(\"connectedOutlet\", { outlet, destBoxId, destInlet, lineId });\n    }\n    connectedInlet(inlet: number, srcBoxId: string, srcOutlet: number, lineId: string) {\n        this.emit(\"connectedInlet\", { inlet, srcBoxId, srcOutlet, lineId });\n    }\n    disconnectedOutlet(outlet: number, destBoxId: string, destInlet: number, lineId: string) {\n        this.emit(\"disconnectedOutlet\", { outlet, destBoxId, destInlet, lineId });\n    }\n    disconnectedInlet(inlet: number, srcBoxId: string, srcOutlet: number, lineId: string) {\n        this.emit(\"disconnectedInlet\", { inlet, srcBoxId, srcOutlet, lineId });\n    }\n    post(data: any) {\n        this._patcher.newLog(\"none\", this.meta.name, stringifyError(data), this._box);\n    }\n    error(data: any) {\n        const s = stringifyError(data);\n        this._patcher.newLog(\"error\", this.meta.name, s, this._box);\n        this._box.error(s);\n    }\n    info(data: any) {\n        this._patcher.newLog(\"info\", this.meta.name, stringifyError(data), this._box);\n    }\n    warn(data: any) {\n        this._patcher.newLog(\"warn\", this.meta.name, stringifyError(data), this._box);\n    }\n    highlight() {\n        this._box.highlight();\n    }\n\n    connectAudio() {\n        this.box.allLines.forEach(line => line.enable());\n    }\n    connectAudioInlet(portIn?: number) {\n        this.inletLines.forEach((lines, port) => {\n            if (typeof portIn === \"undefined\" || port === portIn) lines.forEach(line => line.enable());\n        });\n    }\n    connectAudioOutlet(portIn?: number) {\n        this.outletLines.forEach((lines, port) => {\n            if (typeof portIn === \"undefined\" || port === portIn) lines.forEach(line => line.enable());\n        });\n    }\n    disconnectAudio() {\n        this.box.allLines.forEach(line => line.disable());\n    }\n    disconnectAudioInlet(portIn?: number) {\n        this.inletLines.forEach((lines, port) => {\n            if (typeof portIn === \"undefined\" || port === portIn) lines.forEach(line => line.disable());\n        });\n    }\n    disconnectAudioOutlet(portIn?: number) {\n        this.outletLines.forEach((lines, port) => {\n            if (typeof portIn === \"undefined\" || port === portIn) lines.forEach(line => line.disable());\n        });\n    }\n    applyBPF(param: AudioParam, bpf: number[][]) {\n        const { audioCtx } = this;\n        const { currentTime } = audioCtx;\n        param.cancelScheduledValues(currentTime);\n        param.setValueAtTime(param.value, currentTime);\n        let t = 0;\n        bpf.forEach((a) => {\n            if (a.length === 1) {\n                param.setValueAtTime(a[0], currentTime + t);\n            } else if (a.length > 1) {\n                t += a[1];\n                param.linearRampToValueAtTime(a[0], currentTime + t);\n            }\n        });\n    }\n    async getSharedItem<T extends ProjectItemType>(id = this.box.id, type: T = \"unknown\" as T, data?: () => Promise<TempItemByType<T>[\"data\"]>, onceCreate?: (aitem: SharedItemByType<T>) => any): Promise<{ id: string; item: SharedItemByType<T>; newItem: boolean; off?: () => any }> {\n        let item: SharedItemByType<T>;\n        let newItem = false;\n        const { fileMgr, tempMgr } = this.patcher.env;\n        try {\n            item = fileMgr.getProjectItemFromPath(id) as SharedItemByType<T>;\n        } catch {\n            try {\n                item = tempMgr.getProjectItemFromPath(id) as SharedItemByType<T>;\n            } catch {\n                if (data) {\n                    const d = await data();\n                    try {\n                        item = await tempMgr.root.addFile(id, d, type as TempItemType) as SharedItemByType<T>;\n                        newItem = true;\n                    } catch {\n                        item = tempMgr.getProjectItemFromPath(id) as SharedItemByType<T>;\n                    }\n                } else {\n                    if (onceCreate) {\n                        const off = () => {\n                            fileMgr.off(\"treeChanged\", handleFileMgrTreeChanged);\n                            tempMgr.off(\"treeChanged\", handleTempMgrTreeChanged);\n                        };\n                        const handleFileMgrTreeChanged = () => {\n                            try {\n                                item = fileMgr.getProjectItemFromPath(id) as SharedItemByType<T>;\n                                off();\n                                onceCreate(item);\n                            } catch {}\n                        };\n                        const handleTempMgrTreeChanged = () => {\n                            try {\n                                item = tempMgr.getProjectItemFromPath(id) as SharedItemByType<T>;\n                                off();\n                                onceCreate(item);\n                            } catch {}\n                        };\n                        fileMgr.on(\"treeChanged\", handleFileMgrTreeChanged);\n                        tempMgr.on(\"treeChanged\", handleTempMgrTreeChanged);\n                        return { id, item: null, newItem, off };\n                    }\n                    return { id, item: null, newItem };\n                }\n            }\n        }\n        if (item.type !== type) throw new Error(`Getting shared item ${id}, but returned item is of type ${item.type}, not of type ${type}.`);\n        return { id, item, newItem };\n    }\n}\n","export default class Bang {\n    isBang = true;\n    toString() {\n        return \"bang\";\n    }\n}\n\nexport const isBang = (x: any): x is Bang => typeof x === \"object\" && x?.isBang;\n","import AbstractObject, { IJSPatcherObjectMeta, IPropsMeta } from \"./AbstractObject\";\nimport type { TRect } from \"../../types\";\nimport type { BaseUIState } from \"./BaseUI\";\n\nexport interface BaseObjectAdditionalProps {\n    background: boolean;\n    presentation: boolean;\n    rect: TRect;\n    presentationRect: TRect;\n}\nexport interface BaseObjectProps extends BaseObjectAdditionalProps, BaseUIState {}\nexport default class BaseObject<\n    D extends {} = {},\n    S extends {} = {},\n    I extends any[] = any[],\n    O extends any[] = any[],\n    A extends any[] = any[],\n    P extends Partial<BaseObjectProps> & Record<string, any> = {},\n    U extends Partial<BaseUIState> & Record<string, any> = {},\n    E extends {} = {}\n> extends AbstractObject<D, S, I, O, A, P & BaseObjectProps, U & BaseUIState, E> {\n    static package = \"base\";\n    static props: IPropsMeta = {\n        hidden: {\n            type: \"boolean\",\n            default: false,\n            description: \"Hide on lock\",\n            isUIState: true\n        },\n        background: {\n            type: \"boolean\",\n            default: false,\n            description: \"Include in background\"\n        },\n        presentation: {\n            type: \"boolean\",\n            default: false,\n            description: \"Include in presentation\"\n        },\n        rect: {\n            type: \"object\",\n            default: [0, 0, 90, 20],\n            description: \"Position and dimensions in patch\"\n        },\n        presentationRect: {\n            type: \"object\",\n            default: [0, 0, 90, 20],\n            description: \"Position and dimensions in presentation\"\n        },\n        ignoreClick: {\n            type: \"boolean\",\n            default: false,\n            description: \"Ignore Click\",\n            isUIState: true\n        },\n        hint: {\n            type: \"string\",\n            default: \"\",\n            description: \"Hint on hover\",\n            isUIState: true\n        }\n    };\n    static get meta(): IJSPatcherObjectMeta {\n        const thisName = this._name;\n        const superMeta = Object.getPrototypeOf(this).meta;\n        const superProps = superMeta.props;\n        const thisProps = this.props;\n        for (const key in thisProps) {\n            thisProps[key as keyof IPropsMeta<BaseObjectProps>].group = key in superProps ? superProps[key].group : thisName;\n        }\n        return {\n            package: this.package,\n            name: this._name,\n            icon: this.icon,\n            author: this.author,\n            version: this.version,\n            description: this.description,\n            inlets: [...this.inlets],\n            outlets: [...this.outlets],\n            args: [...this.args],\n            props: {\n                ...superProps,\n                ...thisProps\n            },\n            isPatcherInlet: this.isPatcherInlet,\n            isPatcherOutlet: this.isPatcherOutlet\n        };\n    }\n    isUIStateKey = (x: any) => this.meta.props[x] && this.meta.props[x].isUIState;\n    updateUIFromProps = (props: Partial<P & BaseObjectProps>) => {\n        if (props) {\n            const uiState: Partial<U & BaseUIState> = {};\n            for (const key in props) {\n                if (this.isUIStateKey(key)) uiState[key as keyof (U & BaseUIState)] = props[key] as any;\n            }\n            this.updateUI(uiState);\n        }\n    };\n    subscribe() {\n        super.subscribe();\n        this.on(\"metaUpdated\", e => this.box.emit(\"metaUpdated\", e));\n        this.on(\"argsUpdated\", e => this.box.emit(\"argsUpdated\", e));\n        this.on(\"propsUpdated\", e => this.box.emit(\"propsUpdated\", e));\n        this.on(\"dataUpdated\", e => this.box.emit(\"dataUpdated\", e));\n        this.on(\"stateUpdated\", e => this.box.emit(\"stateUpdated\", e));\n        this.on(\"updateArgs\", this.setArgs);\n        this.on(\"updateProps\", this.setProps);\n        this.on(\"updateProps\", this.updateUIFromProps);\n    }\n}\n","import BaseObject from \"./BaseObject\";\nimport type { IArgsMeta, IPropsMeta } from \"./AbstractObject\";\nimport type { CommentUIState } from \"./CommentUI\";\n\nexport interface CommentProps {\n    bgColor: string;\n    textColor: string;\n    fontFamily: string;\n    fontSize: number;\n    fontStyle: \"normal\" | \"italic\" | \"oblique\";\n    fontWeight: \"normal\" | \"bold\" | \"lighter\" | \"bolder\" | number;\n    textAlign: \"center\" | \"left\" | \"right\";\n    textDecoration: \"none\" | \"underline\" | \"overline\" | \"line-through\";\n}\n\nexport default class comment extends BaseObject<{ value: string }, {}, [string], [], [string], CommentProps, CommentUIState> {\n    static description = \"Text Comment\";\n    static args: IArgsMeta = [{\n        type: \"string\",\n        optional: true,\n        varLength: true,\n        description: \"Initial text\"\n    }];\n    static props: IPropsMeta<CommentProps> = {\n        bgColor: {\n            type: \"color\",\n            default: \"transparent\",\n            description: \"Background color\",\n            isUIState: true\n        },\n        textColor: {\n            type: \"color\",\n            default: \"rgb(255, 255, 255)\",\n            description: \"Text color\",\n            isUIState: true\n        },\n        fontFamily: {\n            type: \"enum\",\n            enums: [\"Lato\", \"Georgia\", \"Times New Roman\", \"Arial\", \"Tahoma\", \"Verdana\", \"Courier New\"],\n            default: \"Lato\",\n            description: \"Font family\",\n            isUIState: true\n        },\n        fontSize: {\n            type: \"number\",\n            default: 12,\n            description: \"Text font size\",\n            isUIState: true\n        },\n        fontStyle: {\n            type: \"enum\",\n            enums: [\"normal\", \"italic\", \"oblique\"],\n            default: \"normal\",\n            description: \"Text style\",\n            isUIState: true\n        },\n        fontWeight: {\n            type: \"string\",\n            default: \"normal\",\n            description: 'Text style: \"normal\" | \"bold\" | \"lighter\" | \"bolder\" | number',\n            isUIState: true\n        },\n        textAlign: {\n            type: \"enum\",\n            enums: [\"left\", \"center\", \"right\"],\n            default: \"left\",\n            description: \"Text style\",\n            isUIState: true\n        },\n        textDecoration: {\n            type: \"enum\",\n            enums: [\"none\", \"underline\", \"overline\", \"line-through\"],\n            default: \"none\",\n            description: \"Text decoration\",\n            isUIState: true\n        }\n    };\n    subscribe() {\n        super.subscribe();\n        this.on(\"preInit\", () => {\n            this.inlets = 1;\n            this.outlets = 0;\n        });\n        this.on(\"updateArgs\", (args) => {\n            if (!this.data.hasOwnProperty(\"value\")) this.setData({ value: args.join(\" \") });\n        });\n        this.on(\"inlet\", ({ data, inlet }) => {\n            if (typeof data === \"string\") {\n                this.setData({ value: data });\n                this.updateUI({ value: data });\n            }\n        });\n    }\n}\n","import type BaseObject from \"./BaseObject\";\n\nexport interface RemotedObjectEventMap {\n    \"outlet\": { outlet: number; data: any };\n}\n\n/** Generate an object that can be used in the AudioWorklet as remoted. */\nexport default <\n    D extends {} = {},\n    S extends {} = {},\n    I extends any[] = any[],\n    O extends any[] = any[],\n    A extends any[] = any[],\n    P extends {} = {},\n    U extends {} = {},\n    E extends Partial<RemotedObjectEventMap> & Record<string, any> = {}\n>(O: typeof BaseObject) => class RemotedObject extends O<D, S, I, O, A, P, U, E & RemotedObjectEventMap> {\n    static get _name() {\n        return O._name;\n    }\n    get proxy() {\n        return this.patcher.state.patcherProcessor;\n    }\n    subscribe() {\n        super.subscribe();\n        const handleBoxIoCountChanged = () => {\n            const { id, inlets, outlets } = this.box;\n            this.proxy?.objectEmitFromWorklet(id, \"boxIoCountChanged\", { inlets, outlets });\n        };\n        this.box.on(\"ioCountChanged\", handleBoxIoCountChanged);\n        this.on(\"outlet\", ({ outlet, data }) => this.outlet(outlet, data));\n        this.on(\"destroy\", () => this.box.off(\"ioCountChanged\", handleBoxIoCountChanged));\n    }\n};\n","import BaseObject from \"./BaseObject\";\nimport { Func, New } from \"../importer/RemotedImporter\";\nimport getIO from \"../jsaw/index.jsdsppkg.aw\";\nimport _comment from \"./Comment\";\nimport generateRemotedObject from \"./generateRemotedObject\";\n\nexport default async () => ({\n    BaseObject,\n    EmptyObject: BaseObject,\n    InvalidObject: BaseObject,\n    func: Func,\n    new: New,\n    comment: generateRemotedObject(_comment as typeof BaseObject),\n    ...await getIO()\n});\n","import RemotedImporter from \"../importer/RemotedImporter\";\n\nexport default async () => RemotedImporter.import(\"globalThis\", globalThis, true);\n","import StaticMethod from \"./StaticMethod\";\nimport Method from \"./Method\";\nimport BaseObject from \"../base/BaseObject\";\nimport Bang, { isBang } from \"../base/Bang\";\nimport type ImportedObject from \"./ImportedObject\";\nimport type { IJSPatcherObjectMeta } from \"../base/AbstractObject\";\n\ntype TAnyFunction = (...args: any[]) => any;\ntype TWrapper = typeof StaticMethod | typeof Method;\ninterface IS { Wrapper: TWrapper }\nexport default class Func extends BaseObject<{}, {}, [Bang], [TAnyFunction], any[], {}, { loading: boolean }> {\n    static description = \"Get the function itself\";\n    static inlets: IJSPatcherObjectMeta[\"inlets\"] = [{\n        isHot: true,\n        type: \"bang\",\n        description: \"Bang to get the function itself\"\n    }];\n    static outlets: IJSPatcherObjectMeta[\"outlets\"] = [{\n        type: \"function\",\n        description: \"function\"\n    }];\n    static args: IJSPatcherObjectMeta[\"args\"] = [{\n        type: \"string\",\n        optional: false,\n        varLength: false,\n        description: \"Function name\"\n    }];\n    _: IS = { Wrapper: null };\n    subscribe() {\n        super.subscribe();\n        this.on(\"postInit\", () => {\n            this.inlets = 1;\n            this.outlets = 1;\n            handleUpdateArgs(this.args);\n        });\n        const handleUpdateArgs = (args: any[]) => {\n            if (typeof args[0] !== \"undefined\") {\n                const Wrapper = this.patcher.activeLib[args[0]];\n                if (!Wrapper) this.error(`Function ${args[0]} not found.`);\n                else if (Wrapper.prototype instanceof StaticMethod || Wrapper.prototype instanceof Method) {\n                    this._.Wrapper = Wrapper as TWrapper;\n                } else {\n                    this.error(\"Given identifier function is not a function\");\n                }\n            } else {\n                this.error(\"A function identifier is needed.\");\n            }\n        };\n        this.on(\"updateArgs\", handleUpdateArgs);\n        this.on(\"inlet\", ({ data, inlet }) => {\n            if (inlet === 0) {\n                if (isBang(data)) this.output();\n            }\n        });\n    }\n    callback = () => this.outlet(0, this.imported);\n    output() {\n        return this.callback();\n    }\n    set loading(loading: boolean) {\n        this.updateUI({ loading });\n    }\n    get name() {\n        const c = this._.Wrapper;\n        return c.path[c.path.length - 1];\n    }\n    get imported(): TAnyFunction {\n        const c = this._.Wrapper || this.patcher.activeLib.Object as TWrapper;\n        let r: TAnyFunction;\n        try {\n            r = c.path.reduce((acc, cur) => acc[cur], c.root);\n        } catch (e) {\n            this.error(e);\n        }\n        return r;\n    }\n    set imported(v: TAnyFunction) {\n        const c = (this.constructor as typeof ImportedObject);\n        let parent = c.root;\n        try {\n            if (!c.path.length) {\n                c.root = v;\n            } else {\n                c.path.slice(0, -1).forEach(key => parent = parent[key]);\n                parent[c.path[c.path.length - 1]] = v;\n            }\n        } catch (e) {\n            this.error(e);\n        }\n    }\n}\n","import ImportedObject from \"./ImportedObject\";\nimport Bang, { isBang } from \"../base/Bang\";\nimport type { IJSPatcherObjectMeta } from \"../base/AbstractObject\";\nimport type { ImportedObjectType } from \"../../types\";\n\ninterface IS<Static extends boolean> {\n    instance: Static extends true ? undefined : any;\n    result: any;\n}\ntype I<Static extends boolean> = Static extends true ? [Bang] : [any | Bang];\ntype O<Static extends boolean> = Static extends true ? [any] : [any, any];\nexport default class Getter<Static extends boolean = false> extends ImportedObject<any, {}, I<Static>, O<Static>, [], { sync: boolean }, { loading: boolean }> {\n    static importedObjectType: ImportedObjectType = \"Getter\";\n    static description = \"Auto-imported getter\";\n    static inlets: IJSPatcherObjectMeta[\"inlets\"] = [{\n        isHot: true,\n        type: \"anything\",\n        description: \"Instance to read\"\n    }];\n    static outlets: IJSPatcherObjectMeta[\"outlets\"] = [{\n        type: \"anything\",\n        description: \"Value\"\n    }, {\n        type: \"anything\",\n        description: \"Instance bypass\"\n    }];\n    static props: IJSPatcherObjectMeta[\"props\"] = {\n        sync: {\n            type: \"boolean\",\n            default: false,\n            description: \"If true and in case the result is a Promise, instead of waiting for result, will output the Promise object\"\n        }\n    };\n    _: IS<Static> = { instance: undefined, result: null };\n    handlePreInit = () => {\n        this.inlets = 1;\n        this.outlets = 2;\n    };\n    handleInlet = ({ data, inlet }: { data: any; inlet: number }) => {\n        if (inlet === 0) {\n            if (!isBang(data)) this._.instance = data;\n            if (this.execute()) this.output();\n        }\n    };\n    subscribe() {\n        super.subscribe();\n        this.on(\"preInit\", this.handlePreInit);\n        this.on(\"inlet\", this.handleInlet);\n    }\n    execute() {\n        try {\n            this._.result = this._.instance[this.name];\n            return true;\n        } catch (e) {\n            this.error(e);\n            return false;\n        }\n    }\n    callback = () => this.outletAll([this._.result, this._.instance] as O<Static>);\n    output() {\n        if (this._.result instanceof Promise && !this.getProp(\"sync\")) {\n            this.loading = true;\n            this._.result.then((r) => {\n                this.loading = false;\n                this._.result = r;\n                this.callback();\n            }, (r) => {\n                this.loading = false;\n                this.error(r);\n            });\n            return this;\n        }\n        return this.callback();\n    }\n    set loading(loading: boolean) {\n        this.updateUI({ loading });\n    }\n}\n","import BaseObject from \"../base/BaseObject\";\nimport type { ImportedObjectType } from \"../../types\";\n\n/**\n* ```JavaScript\n*   class A {\n*       static a = {} // A.a\n*       static b() {} // A.b\n*       static get c() {} // A.c (get)\n*       static set d(x) {} // A.d (set)\n*       e = {} // Nothing\n*       f() {} // A.prototype.f\n*       get g() {} // A.prototype.g (get)\n*       set h(x) {} // A.prototype.h (set)\n*       constructor() {} // A.prototype.constructor\n*   }\n*   const B = {\n*       a: {}, // B.a\n*       b() {} // B.b\n*   }\n*   const C = function() {\n*       this.a = null; // C.prototype.constructor\n*   }\n* ```\n*/\n\nexport default abstract class ImportedObject<T, S, I extends any[], O extends any[], A extends any[], P, U> extends BaseObject<{}, S, I, O, A, P, U> {\n    static importedObjectType: ImportedObjectType;\n    static root: Record<string, any>;\n    static path: string[];\n    static description = \"Auto-imported object\";\n    get name() {\n        const c = (this.constructor as typeof ImportedObject);\n        return c.path[c.path.length - 1];\n    }\n    get imported(): T {\n        const c = (this.constructor as typeof ImportedObject);\n        let r: T;\n        try {\n            r = c.path.reduce((acc, cur) => acc[cur], c.root);\n        } catch (e) {\n            this.error(e);\n        }\n        return r;\n    }\n    set imported(v: T) {\n        const c = (this.constructor as typeof ImportedObject);\n        let parent = c.root;\n        try {\n            if (!c.path.length) {\n                c.root = v;\n            } else {\n                c.path.slice(0, -1).forEach(key => parent = parent[key]);\n                parent[c.path[c.path.length - 1]] = v;\n            }\n        } catch (e) {\n            this.error(e);\n        }\n    }\n}\nexport class AnyImportedObject extends ImportedObject<any, any, any, any, any, any, any> {}\n","import { ImporterDirSelfObject } from \"../../../utils/symbols\";\nimport { getPropertyDescriptors } from \"../../../utils/utils\";\nimport { IJSPatcherObject, IJSPatcherObjectMeta, isJSPatcherObjectConstructor } from \"../base/AbstractObject\";\nimport type { TPackage } from \"../../types\";\n\nexport default abstract class Importer {\n    static $self = ImporterDirSelfObject;\n    static getObject(p: PropertyDescriptor, pkgName: string, root: Record<string, any>, path: string[], meta?: Partial<IJSPatcherObjectMeta>): typeof IJSPatcherObject {\n        throw new Error(\"getObject not implemented\");\n    }\n    /*\n    static async test() {\n        await Importer.importFrom(\"https://unpkg.com/@tensorflow/tfjs\", \"tf\").then(console.log);\n        await Importer.importFrom(\"https://unpkg.com/three\", \"THREE\").then(console.log);\n        await Importer.importFrom(\"https://unpkg.com/webmidi\", \"MIDI\").then(console.log);\n    }\n    */\n    static writeInPath(pkgIn: TPackage, pathIn: string[], object: typeof IJSPatcherObject) {\n        if (pathIn.length === 0) {\n            Object.assign(pkgIn, { [this.$self]: object });\n            return;\n        }\n        const path = pathIn.slice();\n        let pkg = pkgIn;\n        while (path.length > 1) {\n            const key = path.shift();\n            if (!pkg[key]) pkg[key] = {};\n            else if (isJSPatcherObjectConstructor(pkg[key])) pkg[key] = { [this.$self]: pkg[key] };\n            pkg = pkg[key] as TPackage;\n        }\n        pkg[path[0]] = object;\n    }\n    /**\n     * Recursive transform JavaScript object to JSPatcher Package\n     *\n     * @param {string} pkgName package identifier\n     * @param {Record<string, any>} root imported JavaScript object\n     * @param {boolean} [all] import non-iterables\n     * @param {Record<string, IJSPatcherObjectMeta>} [metaIn] object meta to inject\n     * @param {TPackage} [outIn]\n     * @param {string[]} [pathIn]\n     * @param {any[]} [stackIn]\n     * @param {number} [depthIn]\n     */\n    static import(pkgName: string, root: Record<string, any>, all?: boolean, metaIn: Record<string, IJSPatcherObjectMeta> = {}, outIn?: TPackage, pathIn?: string[], stackIn?: any[], depthIn?: number) {\n        const depth = typeof depthIn === \"undefined\" ? 0 : depthIn;\n        const out = outIn || {};\n        const path = pathIn || [];\n        const stack = stackIn ? stackIn.slice() : [];\n        let o: any;\n        try {\n            o = path.reduce((acc, cur) => acc[cur], root);\n        } catch (e) {\n            return out;\n        }\n        if (typeof o === \"undefined\" || o === null || stack.indexOf(o) !== -1 || (depth && o === globalThis) || o === (globalThis as any).jspatcherEnv) return out; // cyclic object\n        stack[depth] = o;\n        let props: Record<string, TypedPropertyDescriptor<any> | PropertyDescriptor>;\n        try { // mitigate opener.location.href error\n            props = getPropertyDescriptors(o);\n        } catch (e) {\n            return out;\n        }\n        if (path.length === 0) {\n            const newObj = this.getObject({ value: root }, pkgName, root, []);\n            if (newObj) this.writeInPath(out, [], newObj);\n        }\n        for (const key in props) {\n            if (key.startsWith(\"$\")) continue;\n            if (typeof o === \"function\" && [\"arguments\", \"caller\", \"length\", \"name\", \"__proto__\"].indexOf(key) >= 0) continue;\n            if (typeof o === \"object\" && [\"constructor\", \"__proto__\"].indexOf(key) >= 0) continue;\n            const prop = props[key];\n            const newPath = [...path, key];\n            if (!all && !prop.enumerable && key.startsWith(\"_\") && key !== \"prototype\") continue;\n            const newObj = this.getObject(prop, pkgName, root, newPath, metaIn[newPath.join(\".\")]);\n            if (newObj) this.writeInPath(out, newPath.map((s, i) => (i !== newPath.length - 1 && s === \"prototype\" ? \"\" : s)), newObj);\n            const value = prop.value;\n            if ((typeof value === \"object\" || typeof value === \"function\") && value !== null && (value === Array.prototype || !Array.isArray(value))) {\n                this.import(pkgName, root, all, metaIn, out, newPath, stack, depth + 1);\n            }\n        }\n        return out;\n    }\n}\n","import ImportedObject from \"./ImportedObject\";\nimport Bang, { isBang } from \"../base/Bang\";\nimport type { IJSPatcherObjectMeta, IPropsMeta } from \"../base/AbstractObject\";\nimport type { ImportedObjectType } from \"../../types\";\n\ntype TAnyFunction = (...args: any[]) => any;\ninterface IS<Static extends boolean> {\n    instance: Static extends true ? undefined : any;\n    inputs: any[];\n    result: any;\n}\ntype I<Static extends boolean> = Static extends true ? [any | Bang, ...any[]] : [any | Bang, any, ...any[]];\ntype O<Static extends boolean> = Static extends true ? [any, ...any[]] : [any, any, ...any[]];\ninterface P {\n    args: number;\n    spreadArgs: boolean;\n    sync: boolean;\n}\n\nexport default class Method<Static extends boolean = false> extends ImportedObject<TAnyFunction, {}, I<Static>, O<Static>, any[], P, { loading: boolean }> {\n    static importedObjectType: ImportedObjectType = \"Method\";\n    static description = \"Auto-imported method\";\n    static inlets: IJSPatcherObjectMeta[\"inlets\"] = [{\n        isHot: true,\n        type: \"anything\",\n        description: \"Instance to read\"\n    }, {\n        isHot: false,\n        type: \"anything\",\n        varLength: true,\n        description: \"Method argument\"\n    }];\n    static outlets: IJSPatcherObjectMeta[\"outlets\"] = [{\n        type: \"anything\",\n        description: \"Method return value\"\n    }, {\n        type: \"anything\",\n        description: \"Instance bypass\"\n    }, {\n        type: \"anything\",\n        varLength: true,\n        description: \"Argument after method called\"\n    }];\n    static args: IJSPatcherObjectMeta[\"args\"] = [{\n        type: \"anything\",\n        optional: true,\n        varLength: true,\n        description: \"Set arguments while loaded\"\n    }];\n    static props: IPropsMeta<P> = {\n        args: {\n            type: \"number\",\n            default: 0,\n            description: \"arguments count for method\"\n        },\n        spreadArgs: {\n            type: \"boolean\",\n            default: false,\n            description: \"arguments input will be spreaded if true\"\n        },\n        sync: {\n            type: \"boolean\",\n            default: false,\n            description: \"If true and in case the result is a Promise, instead of waiting for result, will output the Promise object\"\n        }\n    };\n    _: IS<Static> = { instance: undefined, inputs: [], result: null };\n    initialInlets = 1;\n    initialOutlets = 2;\n    handleInlet = ({ data, inlet }: { data: any; inlet: number }) => {\n        if (inlet === 0) {\n            if (!isBang(data)) this._.instance = data;\n            if (this.execute()) this.output();\n        } else {\n            this._.inputs[inlet - 1] = data;\n        }\n    };\n    subscribe() {\n        super.subscribe();\n        this.on(\"postInit\", () => {\n            handleUpdateArgs(this.args);\n        });\n        const handleUpdateArgs = (args: any[]) => {\n            this._.inputs = args.slice();\n            const fn = this.imported;\n            const argsCount = Math.max(fn.length, args.length, ~~+this.getProp(\"args\"));\n            this.inlets = Math.max(1, this.initialInlets + argsCount);\n            this.outlets = this.initialOutlets + argsCount;\n        };\n        this.on(\"updateArgs\", handleUpdateArgs);\n        this.on(\"updateProps\", (props) => {\n            if (props.args && typeof props.args === \"number\" && props.args >= 0) {\n                const fn = this.imported;\n                const argsCount = Math.max(fn.length, this.box.args.length, ~~props.args);\n                this.inlets = Math.max(1, this.initialInlets + argsCount);\n                this.outlets = this.initialOutlets + argsCount;\n            }\n        });\n        this.on(\"inlet\", this.handleInlet);\n    }\n    execute() {\n        const fn = this.imported;\n        try {\n            this._.result = fn.call(this._.instance, ...(this.getProp(\"spreadArgs\") ? this._.inputs.reduce<any[]>((acc, cur) => [...acc, ...cur], []) : this._.inputs));\n            return true;\n        } catch (e) {\n            this.error(e);\n            return false;\n        }\n    }\n    callback = () => this.outletAll([this._.result, this._.instance, ...this._.inputs] as O<Static>);\n    output() {\n        if (this._.result instanceof Promise && !this.getProp(\"sync\")) {\n            this.loading = true;\n            this._.result.then((r) => {\n                this.loading = false;\n                this._.result = r;\n                this.callback();\n            }, (r) => {\n                this.loading = false;\n                this.error(r);\n            });\n            return this;\n        }\n        return this.callback();\n    }\n    set loading(loading: boolean) {\n        this.updateUI({ loading });\n    }\n}\n","import StaticMethod from \"./StaticMethod\";\nimport BaseObject from \"../base/BaseObject\";\nimport Bang, { isBang } from \"../base/Bang\";\nimport type ImportedObject from \"./ImportedObject\";\nimport type { IJSPatcherObjectMeta, IPropsMeta } from \"../base/AbstractObject\";\n\ntype TAnyConstructor = new (...args: any[]) => any;\ninterface P {\n    args: number;\n    spreadArgs: boolean;\n}\ninterface IS {\n    Wrapper: typeof StaticMethod;\n    inputs: any[];\n    result: any;\n}\n\nexport default class New extends BaseObject<{}, {}, [any | Bang, ...any[]], [any, ...any[]], any[], P, { loading: boolean }> {\n    static description = \"Call function as a constructor\";\n    static inlets: IJSPatcherObjectMeta[\"inlets\"] = [{\n        isHot: true,\n        type: \"anything\",\n        description: \"Constructor argument, output instance constructed\"\n    }, {\n        isHot: false,\n        type: \"anything\",\n        varLength: true,\n        description: \"Constructor argument\"\n    }];\n    static outlets: IJSPatcherObjectMeta[\"outlets\"] = [{\n        type: \"anything\",\n        description: \"Instance constructed\"\n    }, {\n        type: \"anything\",\n        varLength: true,\n        description: \"Argument after constructor called\"\n    }];\n    static args: IJSPatcherObjectMeta[\"args\"] = [{\n        type: \"string\",\n        optional: false,\n        varLength: false,\n        description: \"Constructor name\"\n    }, {\n        type: \"anything\",\n        optional: true,\n        varLength: true,\n        description: \"Set arguments while loaded\"\n    }];\n    static props: IPropsMeta<P> = {\n        args: {\n            type: \"number\",\n            default: 0,\n            description: \"arguments count for method\"\n        },\n        spreadArgs: {\n            type: \"boolean\",\n            default: false,\n            description: \"arguments input will be spreaded if true\"\n        }\n    };\n    _: IS = { Wrapper: null, inputs: [], result: null };\n    subscribe() {\n        super.subscribe();\n        this.on(\"postInit\", () => {\n            handleUpdateArgs(this.args);\n        });\n        const handleUpdateArgs = (args: any[]) => {\n            if (typeof args[0] !== \"undefined\") {\n                const Wrapper = this.patcher.activeLib[args[0]];\n                if (!Wrapper) this.error(`Function ${args[0]} not found.`);\n                else if (Wrapper.prototype instanceof StaticMethod) {\n                    this._.Wrapper = Wrapper as typeof StaticMethod;\n                    const Fn = this.imported;\n                    const argsCount = Math.max(Fn.length, args.length - 1, ~~+this.getProp(\"args\"));\n                    this.inlets = Math.max(1, argsCount);\n                    this.outlets = 1 + this.inlets;\n                } else {\n                    this.error(\"Given function is not constructable\");\n                }\n            } else {\n                this.error(\"A constructor is needed.\");\n            }\n            this._.inputs = args.slice(1);\n        };\n        this.on(\"updateArgs\", handleUpdateArgs);\n        this.on(\"updateProps\", (props) => {\n            if (props.args && typeof props.args === \"number\" && props.args >= 0) {\n                const Fn = this.imported;\n                const argsCount = Math.max(Fn.length, this.box.args.length - 1, ~~+props.args);\n                this.inlets = Math.max(1, argsCount);\n                this.outlets = 1 + this.inlets;\n            }\n        });\n        this.on(\"inlet\", ({ data, inlet }) => {\n            if (inlet === 0) {\n                if (!isBang(data)) this._.inputs[inlet] = data;\n                if (this.execute()) this.output();\n            } else {\n                this._.inputs[inlet] = data;\n            }\n        });\n    }\n    execute() {\n        const Fn = this.imported;\n        try {\n            this._.result = new Fn(...(this.getProp(\"spreadArgs\") ? this._.inputs.reduce<any[]>((acc, cur) => [...acc, ...cur], []) : this._.inputs));\n            return true;\n        } catch (e) {\n            this.error(e);\n            return false;\n        }\n    }\n    callback = () => this.outletAll([this._.result, ...this._.inputs]);\n    output() {\n        return this.callback();\n    }\n    set loading(loading: boolean) {\n        this.updateUI({ loading });\n    }\n    get name() {\n        const c = this._.Wrapper;\n        return c.path[c.path.length - 1];\n    }\n    get imported(): TAnyConstructor {\n        const c = this._.Wrapper || this.patcher.activeLib.Object as typeof StaticMethod;\n        let r: TAnyConstructor;\n        try {\n            r = c.path.reduce((acc, cur) => acc[cur], c.root);\n        } catch (e) {\n            this.error(e);\n        }\n        return r;\n    }\n    set imported(v: TAnyConstructor) {\n        const c = (this.constructor as typeof ImportedObject);\n        let parent = c.root;\n        try {\n            if (!c.path.length) {\n                c.root = v;\n            } else {\n                c.path.slice(0, -1).forEach(key => parent = parent[key]);\n                parent[c.path[c.path.length - 1]] = v;\n            }\n        } catch (e) {\n            this.error(e);\n        }\n    }\n}\n","import ImportedObject from \"./ImportedObject\";\nimport Bang, { isBang } from \"../base/Bang\";\nimport type { IJSPatcherObjectMeta } from \"../base/AbstractObject\";\nimport type { ImportedObjectType } from \"../../types\";\n\ninterface IS<Static extends boolean> { instance: Static extends true ? undefined : any }\ntype I<Static extends boolean> = Static extends true ? [Bang, any] : [any | Bang, any];\ntype O<Static extends boolean> = Static extends true ? [any] : [any, any];\ntype A<Static extends boolean> = Static extends true ? [any] : [];\n\nexport default class Property<Static extends boolean = false> extends ImportedObject<any, {}, I<Static>, O<Static>, A<Static>, {}, {}> {\n    static importedObjectType: ImportedObjectType = \"Property\";\n    static description = \"Auto-imported property\";\n    static inlets: IJSPatcherObjectMeta[\"inlets\"] = [{\n        isHot: true,\n        type: \"anything\",\n        description: \"Constructor argument, output instance constructed\"\n    }, {\n        isHot: false,\n        type: \"anything\",\n        varLength: true,\n        description: \"Constructor argument\"\n    }];\n    static outlets: IJSPatcherObjectMeta[\"outlets\"] = [{\n        type: \"anything\",\n        description: \"Value\"\n    }, {\n        type: \"anything\",\n        description: \"Instance bypass\"\n    }];\n    _: IS<Static> = { instance: undefined };\n    handlePreInit = () => {\n        this.inlets = 2;\n        this.outlets = 2;\n    };\n    handleInlet = ({ data, inlet }: { data: any; inlet: number }) => {\n        if (inlet === 0) {\n            if (!isBang(data)) this._.instance = data;\n            let result;\n            try {\n                result = this._.instance[this.name];\n            } catch (e) {\n                this.error(e);\n            }\n            this.outletAll([result, this._.instance] as O<Static>);\n        } else if (inlet === 1) {\n            try {\n                this._.instance[this.name] = data;\n            } catch (e) {\n                this.error(e);\n            }\n        }\n    };\n    subscribe() {\n        super.subscribe();\n        this.on(\"preInit\", this.handlePreInit);\n        this.on(\"inlet\", this.handleInlet);\n    }\n}\n","import NewBase from \"./New\";\nimport FuncBase from \"./Func\";\nimport PropertyBase from \"./Property\";\nimport GetterBase from \"./Getter\";\nimport SetterBase from \"./Setter\";\nimport SetterGetterBase from \"./SetterGetter\";\nimport MethodBase from \"./Method\";\nimport StaticPropertyBase from \"./StaticProperty\";\nimport StaticGetterBase from \"./StaticGetter\";\nimport StaticSetterBase from \"./StaticSetter\";\nimport StaticSetterGetterBase from \"./StaticSetterGetter\";\nimport StaticMethodBase from \"./StaticMethod\";\nimport generateRemotedObject from \"../base/generateRemotedObject\";\nimport Importer from \"./Importer\";\nimport type BaseObject from \"../base/BaseObject\";\nimport type { IJSPatcherObject, IJSPatcherObjectMeta } from \"../base/AbstractObject\";\n\nexport class New extends generateRemotedObject(NewBase as typeof BaseObject) {\n}\nexport class Func extends generateRemotedObject(FuncBase as typeof BaseObject) {\n}\nexport class Property extends generateRemotedObject(PropertyBase as typeof BaseObject) {\n}\nexport class Getter extends generateRemotedObject(GetterBase as typeof BaseObject) {\n}\nexport class Setter extends generateRemotedObject(SetterBase as typeof BaseObject) {\n}\nexport class SetterGetter extends generateRemotedObject(SetterGetterBase as typeof BaseObject) {\n}\nexport class Method extends generateRemotedObject(MethodBase as typeof BaseObject) {\n}\nexport class StaticProperty extends generateRemotedObject(StaticPropertyBase as typeof BaseObject) {\n}\nexport class StaticGetter extends generateRemotedObject(StaticGetterBase as typeof BaseObject) {\n}\nexport class StaticSetter extends generateRemotedObject(StaticSetterBase as typeof BaseObject) {\n}\nexport class StaticSetterGetter extends generateRemotedObject(StaticSetterGetterBase as typeof BaseObject) {\n}\nexport class StaticMethod extends generateRemotedObject(StaticMethodBase as typeof BaseObject) {\n}\n\nexport default class RemotedImporter extends Importer {\n    static getObject(p: PropertyDescriptor, pkgName: string, root: Record<string, any>, path: string[], meta?: Partial<IJSPatcherObjectMeta>): typeof IJSPatcherObject {\n        const isStatic = path[path.length - 2] !== \"prototype\";\n        let Super: typeof IJSPatcherObject;\n        const type = typeof p.value;\n        if (type === \"function\") {\n            if (isStatic) Super = StaticMethod;\n            else Super = Method;\n        } else if (type === \"undefined\") {\n            const setter = p.set;\n            const getter = p.get;\n            if (isStatic) {\n                if (setter && getter) Super = StaticSetterGetter;\n                else if (setter) Super = StaticSetter;\n                else if (getter) Super = StaticGetter;\n                else return null;\n            } else {\n                if (setter && getter) Super = SetterGetter;\n                else if (setter) Super = Setter;\n                else if (getter) Super = Getter;\n                else return null;\n            }\n        } else {\n            if (isStatic) Super = StaticProperty;\n            else Super = Property;\n        }\n        const Ctor = class extends Super {\n            static package = pkgName;\n            static root = root;\n            static path = path;\n            static get _name() { return path[path.length - 1] || pkgName; }\n        };\n        if (meta) {\n            for (const keyIn in meta) {\n                const key = keyIn as keyof IJSPatcherObjectMeta;\n                if (key === \"name\") continue;\n                (Ctor as any)[key] = meta[key];\n            }\n        }\n        return Ctor;\n    }\n}\n","import ImportedObject from \"./ImportedObject\";\nimport Bang, { isBang } from \"../base/Bang\";\nimport type { IJSPatcherObjectMeta } from \"../base/AbstractObject\";\nimport type { ImportedObjectType } from \"../../types\";\n\ninterface IS<Static extends boolean> {\n    instance: Static extends true ? undefined : any;\n    input: any;\n}\ntype I<Static extends boolean> = Static extends true ? [any] : [any | Bang, any];\ntype O<Static extends boolean> = Static extends true ? [] : [any];\n\nexport default class Setter<Static extends boolean = false> extends ImportedObject<any, {}, I<Static>, O<Static>, [any], {}, {}> {\n    static importedObjectType: ImportedObjectType = \"Setter\";\n    static description = \"Auto-imported setter\";\n    static inlets: IJSPatcherObjectMeta[\"inlets\"] = [{\n        isHot: true,\n        type: \"anything\",\n        description: \"Instance to set property\"\n    }, {\n        isHot: false,\n        type: \"anything\",\n        description: \"Set the value\"\n    }];\n    static outlets: IJSPatcherObjectMeta[\"outlets\"] = [{\n        type: \"anything\",\n        description: \"Instance bypass\"\n    }];\n    static args: IJSPatcherObjectMeta[\"args\"] = [{\n        type: \"anything\",\n        optional: true,\n        varLength: false,\n        description: \"Initial value to set\"\n    }];\n    initialInlets = 2;\n    initialOutlets = 1;\n    _: IS<Static> = { instance: undefined, input: undefined };\n    handleInlet = ({ data, inlet }: { data: any; inlet: number }) => {\n        if (inlet === 0) {\n            if (!isBang(data)) this._.instance = data;\n            if (typeof this._.instance === \"undefined\") return;\n            try {\n                this._.instance[this.name] = this._.input;\n            } catch (e) {\n                this.error(e);\n                return;\n            }\n            this.outlet(0, this._.instance);\n        } else {\n            this._.input = data;\n        }\n    };\n    handleUpdateArgs = (args: [any?]) => {\n        if (args.length) this._.input = args[0];\n    };\n    subscribe() {\n        super.subscribe();\n        this.on(\"preInit\", () => {\n            this.inlets = this.initialInlets;\n            this.outlets = this.initialOutlets;\n            this.handleUpdateArgs(this.args);\n        });\n        this.on(\"updateArgs\", this.handleUpdateArgs);\n        this.on(\"inlet\", this.handleInlet);\n    }\n}\n","import ImportedObject from \"./ImportedObject\";\nimport Bang, { isBang } from \"../base/Bang\";\nimport type { IJSPatcherObjectMeta } from \"../base/AbstractObject\";\nimport type { ImportedObjectType } from \"../../types\";\n\ninterface IS<Static extends boolean> {\n    instance: Static extends true ? undefined : any;\n    input: any;\n    result: any;\n}\ntype I<Static extends boolean> = Static extends true ? [any] : [any | Bang, any];\ntype O<Static extends boolean> = Static extends true ? [any] : [any, any];\n\nexport default class SetterGetter<Static extends boolean = false> extends ImportedObject<any, {}, I<Static>, O<Static>, [any], { sync: boolean }, { loading: boolean }> {\n    static importedObjectType: ImportedObjectType = \"SetterGetter\";\n    static description = \"Auto-imported setter / getter\";\n    static inlets: IJSPatcherObjectMeta[\"inlets\"] = [{\n        isHot: true,\n        type: \"anything\",\n        description: \"Instance to manipulate\"\n    }, {\n        isHot: false,\n        type: \"anything\",\n        description: \"Set the value, bang to void\"\n    }];\n    static outlets: IJSPatcherObjectMeta[\"outlets\"] = [{\n        type: \"anything\",\n        description: \"Value\"\n    }, {\n        type: \"anything\",\n        description: \"Instance bypass\"\n    }];\n    static args: IJSPatcherObjectMeta[\"args\"] = [{\n        type: \"anything\",\n        optional: true,\n        varLength: false,\n        description: \"Initial value to set\"\n    }];\n    static props: IJSPatcherObjectMeta[\"props\"] = {\n        sync: {\n            type: \"boolean\",\n            default: false,\n            description: \"If true and in case the result is a Promise, instead of waiting for result, will output the Promise object\"\n        }\n    };\n    initialInlets = 2;\n    initialOutlets = 2;\n    _: IS<Static> = { instance: undefined, input: new Bang(), result: null };\n    handleInlet = ({ data, inlet }: { data: any; inlet: number }) => {\n        if (inlet === 0) {\n            if (!isBang(data)) this._.instance = data;\n            if (typeof this._.instance === \"undefined\") return;\n            if (!isBang(this._.input)) {\n                try {\n                    this._.instance[this.name] = this._.input;\n                } catch (e) {\n                    this.error(e);\n                    return;\n                }\n            }\n            if (this.execute()) this.output();\n        } else if (inlet === 1) {\n            this._.input = data;\n        }\n    };\n    subscribe() {\n        super.subscribe();\n        this.on(\"preInit\", () => {\n            this.inlets = this.initialInlets;\n            this.outlets = this.initialOutlets;\n            handleUpdateArgs(this.args);\n        });\n        const handleUpdateArgs = (args: [any?]) => {\n            if (args.length) this._.input = args[0];\n        };\n        this.on(\"updateArgs\", handleUpdateArgs);\n        this.on(\"inlet\", this.handleInlet);\n    }\n    execute() {\n        try {\n            this._.result = this._.instance[this.name];\n            return true;\n        } catch (e) {\n            this.error(e);\n            return false;\n        }\n    }\n    callback = () => this.outletAll([this._.result, this._.instance] as O<Static>);\n    output() {\n        if (this._.result instanceof Promise && !this.getProp(\"sync\")) {\n            this.loading = true;\n            this._.result.then((r) => {\n                this.loading = false;\n                this._.result = r;\n                this.callback();\n            }, (r) => {\n                this.loading = false;\n                this.error(r);\n            });\n            return this;\n        }\n        return this.callback();\n    }\n    set loading(loading: boolean) {\n        this.updateUI({ loading });\n    }\n}\n","import Getter from \"./Getter\";\nimport { isBang } from \"../base/Bang\";\nimport type { IJSPatcherObjectMeta } from \"../base/AbstractObject\";\nimport type { ImportedObjectType } from \"../../types\";\n\nexport default class StaticGetter extends Getter<true> {\n    static importedObjectType: ImportedObjectType = \"StaticGetter\";\n    static description = \"Auto-imported static getter\";\n    static inlets: IJSPatcherObjectMeta[\"inlets\"] = [{\n        isHot: true,\n        type: \"bang\",\n        description: \"Get the value\"\n    }];\n    static outlets: IJSPatcherObjectMeta[\"outlets\"] = [{\n        type: \"anything\",\n        description: \"Value\"\n    }];\n    handlePreInit = () => {\n        this.inlets = 1;\n        this.outlets = 1;\n    };\n    handleInlet = ({ data, inlet }: { data: any; inlet: number }) => {\n        if (inlet === 0 && isBang(data) && this.execute()) this.output();\n    };\n    execute() {\n        try {\n            this._.result = this.imported;\n            return true;\n        } catch (e) {\n            this.error(e);\n            return false;\n        }\n    }\n    callback = () => this.outlet(0, this._.result);\n}\n","import Method from \"./Method\";\nimport { ImportedStaticMethodObject } from \"../../../utils/symbols\";\nimport { isBang } from \"../base/Bang\";\nimport type { IJSPatcherObjectMeta } from \"../base/AbstractObject\";\nimport type { ImportedObjectType } from \"../../types\";\n\nexport default class StaticMethod extends Method<true> {\n    static importedObjectType: ImportedObjectType = \"StaticMethod\";\n    static [ImportedStaticMethodObject] = true;\n    static description = \"Auto-imported static method\";\n    static inlets: IJSPatcherObjectMeta[\"inlets\"] = [{\n        isHot: true,\n        type: \"anything\",\n        varLength: true,\n        description: \"Method argument\"\n    }];\n    static outlets: IJSPatcherObjectMeta[\"outlets\"] = [{\n        type: \"anything\",\n        description: \"Method return value\"\n    }, {\n        type: \"anything\",\n        varLength: true,\n        description: \"Argument after method called\"\n    }];\n    initialInlets = 0;\n    initialOutlets = 1;\n    handleInlet = ({ data, inlet }: { data: any; inlet: number }) => {\n        if (inlet === 0) {\n            if (!isBang(data)) this._.inputs[inlet] = data;\n            if (this.execute()) this.output();\n        } else {\n            this._.inputs[inlet] = data;\n        }\n    };\n    execute() {\n        const fn = this.imported;\n        try {\n            this._.result = fn(...(this.getProp(\"spreadArgs\") ? this._.inputs.reduce<any[]>((acc, cur) => [...acc, ...cur], []) : this._.inputs));\n            return true;\n        } catch (e) {\n            this.error(e);\n            return false;\n        }\n    }\n    callback = () => this.outletAll([this._.result, ...this._.inputs]);\n}\n","import Property from \"./Property\";\nimport { isBang } from \"../base/Bang\";\nimport type { IJSPatcherObjectMeta } from \"../base/AbstractObject\";\nimport type { ImportedObjectType } from \"../../types\";\n\nexport default class StaticProperty extends Property<true> {\n    static importedObjectType: ImportedObjectType = \"StaticProperty\";\n    static description = \"Auto-imported static property\";\n    static inlets: IJSPatcherObjectMeta[\"inlets\"] = [{\n        isHot: true,\n        type: \"bang\",\n        description: \"Get the value\"\n    }, {\n        isHot: false,\n        type: \"anything\",\n        description: \"Set the value\"\n    }];\n    static outlets: IJSPatcherObjectMeta[\"outlets\"] = [{\n        type: \"anything\",\n        description: \"Value\"\n    }];\n    static args: IJSPatcherObjectMeta[\"args\"] = [{\n        type: \"anything\",\n        optional: true,\n        description: \"Set the value while loaded.\"\n    }];\n    handlePreInit = () => {\n        this.inlets = 2;\n        this.outlets = 1;\n    };\n    handleInlet = ({ data, inlet }: { data: any; inlet: number }) => {\n        if (inlet === 0) {\n            if (isBang(data)) this.outlet(0, this.imported);\n        } else if (inlet === 1) {\n            this.imported = data;\n        }\n    };\n    subscribe() {\n        super.subscribe();\n        this.on(\"updateArgs\", (args) => {\n            if (args.length) this.imported = args[0];\n        });\n        this.on(\"inlet\", this.handleInlet);\n    }\n}\n","import Setter from \"./Setter\";\nimport type { IJSPatcherObjectMeta } from \"../base/AbstractObject\";\nimport type { ImportedObjectType } from \"../../types\";\n\nexport default class StaticSetter extends Setter<true> {\n    static importedObjectType: ImportedObjectType = \"StaticSetter\";\n    static description = \"Auto-imported static setter\";\n    static inlets: IJSPatcherObjectMeta[\"inlets\"] = [{\n        isHot: false,\n        type: \"anything\",\n        description: \"Set the value\"\n    }];\n    static outlets: IJSPatcherObjectMeta[\"outlets\"] = [];\n    initialInlets = 1;\n    initialOutlets = 0;\n    handleInlet = ({ data, inlet }: { data: any; inlet: number }) => {\n        if (inlet === 0) this.imported = data;\n    };\n    handleUpdateArgs = (args: [any?]) => {\n        if (args.length) this.imported = args[0];\n    };\n}\n","import SetterGetter from \"./SetterGetter\";\nimport { isBang } from \"../base/Bang\";\nimport type { IJSPatcherObjectMeta } from \"../base/AbstractObject\";\nimport type { ImportedObjectType } from \"../../types\";\n\nexport default class StaticSetterGetter extends SetterGetter<true> {\n    static importedObjectType: ImportedObjectType = \"StaticSetterGetter\";\n    static description = \"Auto-imported static setter / getter\";\n    static inlets: IJSPatcherObjectMeta[\"inlets\"] = [{\n        isHot: true,\n        type: \"bang\",\n        description: \"Get the value\"\n    }, {\n        isHot: false,\n        type: \"anything\",\n        description: \"Set the value\"\n    }];\n    static outlets: IJSPatcherObjectMeta[\"outlets\"] = [{\n        type: \"anything\",\n        description: \"Value\"\n    }];\n    initialInlets = 2;\n    initialOutlets = 1;\n    handleInlet = ({ data, inlet }: { data: any; inlet: number }) => {\n        if (inlet === 0) {\n            if (!isBang(data)) return;\n            if (!isBang(this._.input)) {\n                try {\n                    this.imported = this._.input;\n                } catch (e) {\n                    this.error(e);\n                    return;\n                }\n            }\n            if (this.execute()) this.output();\n        } else if (inlet === 1) {\n            this._.input = data;\n        }\n    };\n    execute() {\n        try {\n            this._.result = this.imported;\n            return true;\n        } catch (e) {\n            this.error(e);\n            return false;\n        }\n    }\n    callback = () => this.outlet(0, this._.result);\n}\n","import BaseObject from \"../base/BaseObject\";\nimport type { IArgsMeta, IOutletsMeta, IPropsMeta } from \"../base/AbstractObject\";\nimport type { PatcherEventMap } from \"../../patcher/Patcher\";\n\ninterface P {\n    description: string;\n}\n\nexport default class AudioIn extends BaseObject<{}, {}, [], [Float32Array], [number], P> {\n    static isPatcherInlet = \"audio\" as const;\n    static description = \"Patcher inlet (audio)\";\n    static args: IArgsMeta = [{\n        type: \"number\",\n        optional: false,\n        default: 1,\n        description: \"Inlet index (1-based)\"\n    }];\n    static props: IPropsMeta<P> = {\n        description: {\n            type: \"string\",\n            default: \"\",\n            description: \"Description text\"\n        }\n    };\n    static outlets: IOutletsMeta = [{\n        type: \"object\",\n        description: \"Float32Array buffer\"\n    }];\n    protected get index() {\n        return Math.max(1, ~~this.box.args[0] || 1);\n    }\n    protected _ = { index: this.index };\n    protected handlePatcherInput = ({ input, buffer }: PatcherEventMap[\"audioInput\"]) => {\n        if (input === this.index - 1) this.outlet(0, buffer);\n    };\n    protected emitPatcherChangeIO = () => this.patcher.changeIO();\n    subscribe() {\n        super.subscribe();\n        this.on(\"metaUpdated\", this.emitPatcherChangeIO);\n        this.on(\"preInit\", () => {\n            this.inlets = 0;\n            this.outlets = 1;\n        });\n        this.on(\"postInit\", this.emitPatcherChangeIO);\n        this.on(\"updateArgs\", () => {\n            const { index } = this;\n            if (index !== this._.index) {\n                this._.index = index;\n                this.patcher.changeIO();\n            }\n        });\n        this.on(\"updateProps\", (props) => {\n            const outlet0 = { ...this.meta.outlets[0] };\n            if (typeof props.description === \"string\") outlet0.description = props.description;\n            this.setMeta({ outlets: [outlet0] });\n            this.emitPatcherChangeIO();\n        });\n        if (this.env.thread === \"AudioWorklet\") this.patcher.on(\"audioInput\", this.handlePatcherInput);\n        this.on(\"destroy\", () => {\n            this.patcher.off(\"audioInput\", this.handlePatcherInput);\n            this.patcher.changeIO();\n        });\n    }\n}\n","import BaseObject from \"../base/BaseObject\";\nimport type { IArgsMeta, IInletsMeta, IPropsMeta } from \"../base/AbstractObject\";\n\ninterface P {\n    description: string;\n}\n\nexport default class AudioOut extends BaseObject<{}, {}, [Float32Array], [], [number], P> {\n    static isPatcherOutlet = \"audio\" as const;\n    static description = \"Patcher outlet (audio)\";\n    static args: IArgsMeta = [{\n        type: \"number\",\n        optional: false,\n        default: 1,\n        description: \"Inlet index (1-based)\"\n    }];\n    static props: IPropsMeta<P> = {\n        description: {\n            type: \"string\",\n            default: \"\",\n            description: \"Description text\"\n        }\n    };\n    static inlets: IInletsMeta = [{\n        isHot: true,\n        type: \"anything\",\n        description: \"Float32Array buffer\"\n    }];\n    protected get index() {\n        return Math.max(1, ~~this.box.args[0] || 1);\n    }\n    protected _ = { index: this.index };\n    protected emitPatcherChangeIO = () => {\n        this.patcher.inspectAudioIO();\n        this.patcher.changeIO();\n    };\n    subscribe() {\n        super.subscribe();\n        this.on(\"metaUpdated\", this.emitPatcherChangeIO);\n        this.on(\"preInit\", () => {\n            this.inlets = 1;\n            this.outlets = 0;\n        });\n        this.on(\"postInit\", this.emitPatcherChangeIO);\n        this.on(\"updateArgs\", () => {\n            const { index } = this;\n            if (index !== this._.index) {\n                this._.index = index;\n                this.patcher.changeIO();\n            }\n        });\n        this.on(\"updateProps\", (props) => {\n            const inlet0 = { ...this.meta.inlets[0] };\n            if (typeof props.description === \"string\") inlet0.description = props.description;\n            this.setMeta({ inlets: [inlet0] });\n            this.emitPatcherChangeIO();\n        });\n        this.on(\"inlet\", ({ data, inlet }) => {\n            if (inlet === 0) this.patcher.outputAudio(this.index - 1, data);\n        });\n        this.on(\"destroy\", this.emitPatcherChangeIO);\n    }\n}\n","import BaseObject from \"../base/BaseObject\";\nimport type { IArgsMeta, IOutletsMeta, IPropsMeta, TMetaType } from \"../base/AbstractObject\";\nimport type { PatcherEventMap } from \"../../patcher/Patcher\";\n\ninterface P {\n    description: string;\n    type: Exclude<TMetaType, \"signal\" | \"enum\">;\n}\n\nexport default class In extends BaseObject<{}, {}, [], [any], [number], P> {\n    static isPatcherInlet = \"data\" as const;\n    static description = \"Patcher inlet (data)\";\n    static args: IArgsMeta = [{\n        type: \"number\",\n        optional: false,\n        default: 1,\n        description: \"Inlet index (1-based)\"\n    }];\n    static props: IPropsMeta<P> = {\n        description: {\n            type: \"string\",\n            default: \"\",\n            description: \"Description text\"\n        },\n        type: {\n            type: \"enum\",\n            enums: [\"string\", \"number\", \"boolean\", \"object\", \"function\", \"anything\", \"bang\", \"color\"],\n            default: \"anything\",\n            description: \"Inlet data type\"\n        }\n    };\n    static outlets: IOutletsMeta = [{\n        type: \"anything\",\n        description: \"\"\n    }];\n    protected get index() {\n        return Math.max(1, ~~this.box.args[0] || 1);\n    }\n    protected _ = { index: this.index };\n    protected handlePatcherInput = ({ data, inlet }: PatcherEventMap[\"dataInput\"]) => {\n        if (inlet === this.index - 1) this.outlet(0, data);\n    };\n    protected emitPatcherChangeIO = () => this.patcher.changeIO();\n    protected thread: \"AudioWorklet\" | \"main\" = \"AudioWorklet\";\n    subscribe() {\n        super.subscribe();\n        this.on(\"metaUpdated\", this.emitPatcherChangeIO);\n        this.on(\"preInit\", () => {\n            this.inlets = 0;\n            this.outlets = 1;\n        });\n        this.on(\"postInit\", this.emitPatcherChangeIO);\n        this.on(\"updateArgs\", () => {\n            const { index } = this;\n            if (index !== this._.index) {\n                this._.index = index;\n                this.patcher.changeIO();\n            }\n        });\n        this.on(\"updateProps\", (props) => {\n            const outlet0 = { ...this.meta.outlets[0] };\n            if (typeof props.description === \"string\") outlet0.description = props.description;\n            if (typeof props.type === \"string\") outlet0.type = props.type || \"anything\";\n            this.setMeta({ outlets: [outlet0] });\n            this.emitPatcherChangeIO();\n        });\n        if (this.env.thread === this.thread) this.patcher.on(\"dataInput\", this.handlePatcherInput);\n        this.on(\"destroy\", () => {\n            this.patcher.off(\"dataInput\", this.handlePatcherInput);\n            this.patcher.changeIO();\n        });\n    }\n}\n","import BaseObject from \"../base/BaseObject\";\nimport type { IArgsMeta, IInletsMeta, IPropsMeta, TMetaType } from \"../base/AbstractObject\";\n\ninterface P {\n    description: string;\n    type: Exclude<TMetaType, \"signal\" | \"enum\">;\n}\n\nexport default class Out extends BaseObject<{}, {}, [], [any], [number], P> {\n    static isPatcherOutlet = \"data\" as const;\n    static description = \"Patcher outlet (data)\";\n    static args: IArgsMeta = [{\n        type: \"number\",\n        optional: false,\n        default: 1,\n        description: \"Inlet index (1-based)\"\n    }];\n    static props: IPropsMeta<P> = {\n        description: {\n            type: \"string\",\n            default: \"\",\n            description: \"Description text\"\n        },\n        type: {\n            type: \"enum\",\n            enums: [\"string\", \"number\", \"boolean\", \"object\", \"function\", \"anything\", \"bang\", \"color\"],\n            default: \"anything\",\n            description: \"Inlet data type\"\n        }\n    };\n    static inlets: IInletsMeta = [{\n        isHot: true,\n        type: \"anything\",\n        description: \"\"\n    }];\n    protected get index() {\n        return Math.max(1, ~~this.box.args[0] || 1);\n    }\n    protected _ = { index: this.index };\n    protected emitPatcherChangeIO = () => this.patcher.changeIO();\n    subscribe() {\n        super.subscribe();\n        this.on(\"metaUpdated\", this.emitPatcherChangeIO);\n        this.on(\"preInit\", () => {\n            this.inlets = 1;\n            this.outlets = 0;\n        });\n        this.on(\"postInit\", this.emitPatcherChangeIO);\n        this.on(\"updateArgs\", () => {\n            const { index } = this;\n            if (index !== this._.index) {\n                this._.index = index;\n                this.patcher.changeIO();\n            }\n        });\n        this.on(\"updateProps\", (props) => {\n            const inlet0 = { ...this.meta.inlets[0] };\n            if (typeof props.description === \"string\") inlet0.description = props.description;\n            if (typeof props.type === \"string\") inlet0.type = props.type || \"anything\";\n            this.setMeta({ inlets: [inlet0] });\n            this.emitPatcherChangeIO();\n        });\n        this.on(\"inlet\", ({ data, inlet }) => {\n            if (inlet === 0) this.patcher.outlet(this.index - 1, data);\n        });\n        this.on(\"destroy\", this.emitPatcherChangeIO);\n    }\n}\n","import BaseObject from \"../base/BaseObject\";\nimport type { IArgsMeta, IOutletsMeta, IPropsMeta } from \"../base/AbstractObject\";\nimport type { PatcherEventMap } from \"../../patcher/Patcher\";\n\ninterface P {\n    description: string;\n}\n\nexport default class Param extends BaseObject<{}, {}, [], [Float32Array], [string], P> {\n    static description = \"Patcher outlet (data)\";\n    static args: IArgsMeta = [{\n        type: \"string\",\n        optional: false,\n        default: \"\",\n        description: \"Parameter name\"\n    }];\n    static props: IPropsMeta<P> = {\n        description: {\n            type: \"string\",\n            default: \"\",\n            description: \"Description text\"\n        }\n    };\n    static outlets: IOutletsMeta = [{\n        type: \"anything\",\n        description: \"\"\n    }];\n    protected handlePatcherInput = ({ param, buffer }: PatcherEventMap[\"paramInput\"]) => {\n        if (this.args[0] === param) this.outlet(0, buffer);\n    };\n    protected emitPatcherChangeIO = () => this.patcher.changeIO();\n    subscribe() {\n        super.subscribe();\n        this.on(\"metaUpdated\", this.emitPatcherChangeIO);\n        this.on(\"preInit\", () => {\n            this.inlets = 0;\n            this.outlets = 1;\n        });\n        this.on(\"postInit\", this.emitPatcherChangeIO);\n        this.on(\"updateArgs\", this.emitPatcherChangeIO);\n        this.on(\"updateProps\", (props) => {\n            const outlet0 = { ...this.meta.outlets[0] };\n            if (typeof props.description === \"string\") outlet0.description = props.description;\n            this.setMeta({ outlets: [outlet0] });\n            this.emitPatcherChangeIO();\n        });\n        if (this.env.thread === \"AudioWorklet\") this.patcher.on(\"paramInput\", this.handlePatcherInput);\n        this.on(\"destroy\", () => {\n            this.patcher.off(\"paramInput\", this.handlePatcherInput);\n            this.patcher.changeIO();\n        });\n    }\n}\n","import generateRemotedObject from \"../base/generateRemotedObject\";\nimport In from \"./In\";\nimport Out from \"./Out\";\nimport Param from \"./Param\";\nimport AudioIn from \"./AudioIn\";\nimport AudioOut from \"./AudioOut\";\nimport type BaseObject from \"../base/BaseObject\";\n\nexport default async () => ({\n    in: generateRemotedObject(In as typeof BaseObject),\n    out: generateRemotedObject(Out as typeof BaseObject),\n    \"param~\": generateRemotedObject(Param as typeof BaseObject),\n    \"in~\": generateRemotedObject(AudioIn as typeof BaseObject),\n    \"out~\": generateRemotedObject(AudioOut as typeof BaseObject)\n});\n","import TypedEventEmitter from \"../../utils/TypedEventEmitter\";\nimport { isTRect, parseToPrimitive, isTPresentationRect, isRectMovable, isRectResizable } from \"../../utils/utils\";\nimport type Patcher from \"./Patcher\";\nimport type Line from \"./Line\";\nimport type { TBox, TMaxBox, TRect, TPresentationRect } from \"../types\";\nimport type { Args, Data, IJSPatcherObject, JSPatcherObjectEventMap, ObjectUpdateOptions, Props, State } from \"../objects/base/AbstractObject\";\n\nexport interface BoxEventMap extends Pick<JSPatcherObjectEventMap<any, any, any, any, any, any, any>, \"metaUpdated\" | \"argsUpdated\" | \"propsUpdated\" | \"dataUpdated\" | \"stateUpdated\"> {\n    \"rectChanged\": Box;\n    \"presentationRectChanged\": Box;\n    \"backgroundChanged\": Box;\n    \"presentationChanged\": Box;\n    \"textChanged\": Box;\n    \"error\": string;\n    \"connectedPort\": { isSrc: boolean; i: number; last?: false };\n    \"disconnectedPort\": { isSrc: boolean; i: number; last: boolean };\n    \"ioCountChanged\": Box;\n}\n\nexport default class Box<T extends IJSPatcherObject = IJSPatcherObject> extends TypedEventEmitter<BoxEventMap> {\n    readonly id: string;\n    text = \"\";\n    inlets = 0;\n    outlets = 0;\n    rect: TRect;\n    background: boolean;\n    presentation: boolean;\n    presentationRect: TPresentationRect;\n    /** A timestamp to order boxes UI on z-axis, default = 0, negative = send to back, positive = bring to front */\n    zIndex: number;\n    data: Data<T>;\n    args: Args<T>;\n    props: Props<T>;\n    _editing: boolean;\n    private _parsed: { class: string; args: Args<T>; props: Props<T> };\n    private _object: T;\n    private _Object: typeof IJSPatcherObject;\n    private readonly _patcher: Patcher;\n    private readonly _inletLines: Set<Line>[];\n    private readonly _outletLines: Set<Line>[];\n    constructor(patcherIn: Patcher, boxIn: TBox) {\n        super();\n        this.id = boxIn.id;\n        this.text = boxIn.text;\n        this.args = (boxIn.args || []) as Args<T>;\n        this.props = (boxIn.props || {}) as Props<T>;\n        this.inlets = boxIn.inlets;\n        this.outlets = boxIn.outlets;\n        this._inletLines = new Array(this.inlets).fill(null).map(() => new Set<Line>());\n        this._outletLines = new Array(this.outlets).fill(null).map(() => new Set<Line>());\n        const maxBoxIn = boxIn as unknown as TMaxBox[\"box\"];\n        this.rect = boxIn.rect || maxBoxIn.patching_rect;\n        this.background = boxIn.background || !!maxBoxIn.background;\n        this.presentation = boxIn.presentation || !!maxBoxIn.presentation;\n        this.presentationRect = boxIn.presentationRect || maxBoxIn.presentation_rect;\n        if (!this.presentationRect) this.presentationRect = this.rect.slice() as TRect;\n        this.zIndex = boxIn.zIndex || 0;\n        this.data = boxIn.data || (boxIn as any).prevData?.storage || {};\n        this._editing = !!boxIn._editing;\n        this._patcher = patcherIn;\n        this.on(\"dataUpdated\", () => this._patcher.emitChanged());\n        this.on(\"argsUpdated\", () => this._patcher.emitChanged());\n        this.on(\"propsUpdated\", () => this._patcher.emitChanged());\n    }\n    async init() {\n        this._parsed = Box.parseObjText(this.text) as { class: string; args: Args<T>; props: Props<T> };\n        const newMeta = this._patcher.getObjectMeta(this._parsed);\n        for (const key in this.props) {\n            if (!newMeta.props[key]) delete this.props[key];\n        }\n        if (this._parsed.args.length) this.args = this._parsed.args;\n        Object.assign(this.props, this._parsed.props);\n        const Constructor = this._patcher.getObjectConstructor(this._parsed);\n        if (Constructor === this._patcher.activeLib.InvalidObject) {\n            this.error(`Object ${this._parsed.class} not found.`);\n        }\n        this._Object = Constructor;\n        if (!this.size.every(v => v > 0)) this.size = this.defaultSize;\n        if (!isTPresentationRect(this.presentationRect) || (this.presentationSize.every(v => typeof v === \"number\") && !this.presentationSize.every(v => v > 0))) this.presentationSize = this.defaultSize;\n        if (this.objectInit) {\n            this._object = new Constructor(this, this._patcher) as T;\n            await this._object.init();\n        }\n        return this;\n    }\n    async postInit() {\n        await this._object?.postInit();\n        return this;\n    }\n    /**\n     * Main function when receive data from a inlet (base 0)\n     */\n    fn(inlet: number, data: any) {\n        this._object?.fn(inlet, data);\n        return this;\n    }\n    get UI() {\n        return this._Object.UI;\n    }\n    get defaultSize() {\n        return this.UI?.defaultSize || [90, 20];\n    }\n    get meta() {\n        return this._object?.meta;\n    }\n    get outletLines() {\n        return this._outletLines;\n    }\n    get inletLines() {\n        return this._inletLines;\n    }\n    get objectInit() {\n        return this._patcher.props.objectInit;\n    }\n    get object() {\n        return this._object;\n    }\n    set object(oIn: T) {\n        this._object = oIn;\n    }\n    get Object() {\n        return this._Object;\n    }\n    get parsed() {\n        return this._parsed;\n    }\n    addInletLine(line: Line) {\n        const index = line.destInlet;\n        if (!this._inletLines[index]) this._inletLines[index] = new Set<Line>();\n        this._inletLines[index].add(line);\n    }\n    removeInletLine(line: Line) {\n        const index = line.destInlet;\n        if (this._inletLines[index]) this._inletLines[index].delete(line);\n    }\n    addOutletLine(line: Line) {\n        const index = line.srcOutlet;\n        if (!this._outletLines[index]) this._outletLines[index] = new Set<Line>();\n        this._outletLines[index].add(line);\n    }\n    removeOutletLine(line: Line) {\n        const index = line.srcOutlet;\n        if (this._outletLines[index]) this._outletLines[index].delete(line);\n    }\n    setInlets(count: number) {\n        const lines = this.allLines;\n        lines.forEach(line => line.disable());\n        this.inlets = count;\n        // Lines that should be removed will destroy themselves when enable()\n        lines.forEach(line => line.enable());\n        const linesSetLength = this._inletLines.length;\n        if (count > linesSetLength) this._inletLines.push(...new Array(count - linesSetLength).fill(null).map(() => new Set<Line>()));\n        else if (count < linesSetLength) this._inletLines.splice(count);\n        this._inletLines.forEach(set => set.forEach(line => line.uiUpdateDest()));\n        this.emit(\"ioCountChanged\", this);\n    }\n    setOutlets(count: number) {\n        const lines = this.allLines;\n        lines.forEach(line => line.disable());\n        this.outlets = count;\n        // Lines that should be removed will destroy themselves when enable()\n        lines.forEach(line => line.enable());\n        const linesSetLength = this._outletLines.length;\n        if (count > linesSetLength) this._outletLines.push(...new Array(count - linesSetLength).fill(null).map(() => new Set<Line>()));\n        else if (count < linesSetLength) this._outletLines.splice(count);\n        this._outletLines.forEach(set => set.forEach(line => line.uiUpdateSrc()));\n        this.emit(\"ioCountChanged\", this);\n    }\n    getInletPos(port: number) {\n        const { rect, inlets } = this;\n        const [left, top, width] = rect;\n        return { top, left: ((left + 10) + (width - 20) * port / (inlets > 1 ? inlets - 1 : 1)) };\n    }\n    getOutletPos(port: number) {\n        const { rect, outlets } = this;\n        const [left, top, width, height] = rect;\n        return { top: top + height, left: ((left + 10) + (width - 20) * port / (outlets > 1 ? outlets - 1 : 1)) };\n    }\n    get inletsPositions() {\n        const positions = [];\n        for (let i = 0; i < this.inlets; i++) {\n            positions[i] = this.getInletPos(i);\n        }\n        return positions;\n    }\n    get outletsPositions() {\n        const positions = [];\n        for (let i = 0; i < this.outlets; i++) {\n            positions[i] = this.getOutletPos(i);\n        }\n        return positions;\n    }\n    get allLines() {\n        const lines = new Set<Line>();\n        this._inletLines.forEach(set => set.forEach(line => lines.add(line)));\n        this._outletLines.forEach(set => set.forEach(line => lines.add(line)));\n        return lines;\n    }\n    // called when inlet or outlet are connected or disconnected\n    connectedOutlet(outlet: number, destBoxId: string, destInlet: number, lineId: string) {\n        if (this._object) this._object.connectedOutlet(outlet, destBoxId, destInlet, lineId);\n        this.emit(\"connectedPort\", { isSrc: true, i: outlet });\n        return this;\n    }\n    connectedInlet(inlet: number, srcBoxId: string, srcOutlet: number, lineId: string) {\n        if (this._object) this._object.connectedInlet(inlet, srcBoxId, srcOutlet, lineId);\n        this.emit(\"connectedPort\", { isSrc: false, i: inlet });\n        return this;\n    }\n    disconnectedOutlet(outlet: number, destBoxId: string, destInlet: number, lineId: string) {\n        if (this._object) this._object.disconnectedOutlet(outlet, destBoxId, destInlet, lineId);\n        const last = this._patcher.getLinesBySrcID(this.id)[outlet].length === 1;\n        this.emit(\"disconnectedPort\", { isSrc: true, i: outlet, last });\n        return this;\n    }\n    disconnectedInlet(inlet: number, srcBoxId: string, srcOutlet: number, lineId: string) {\n        if (this._object) this._object.disconnectedInlet(inlet, srcBoxId, srcOutlet, lineId);\n        const last = this._patcher.getLinesByDestID(this.id)[inlet].length === 1;\n        this.emit(\"disconnectedPort\", { isSrc: false, i: inlet, last });\n        return this;\n    }\n    isOutletTo(outlet: number, box: Box, inlet: number) {\n        const iterator = this._outletLines[outlet].values();\n        let r: IteratorResult<Line, Line>;\n        while (!(r = iterator.next()).done) {\n            const line = r.value;\n            if (line.destBox === box && line.destInlet === inlet) return true;\n        }\n        return false;\n    }\n    isInletFrom(inlet: number, box: Box, outlet: number) {\n        const iterator = this._inletLines[inlet].values();\n        let r: IteratorResult<Line, Line>;\n        while (!(r = iterator.next()).done) {\n            const line = r.value;\n            if (line.srcBox === box && line.srcOutlet === outlet) return true;\n        }\n        return false;\n    }\n    async changeText(textIn: string, force?: boolean) {\n        if (!force && textIn === this.text) return this;\n        const { defaultSize: oldDefaultSize } = this;\n        this.allLines.forEach(line => line.disable());\n        await this._object?.destroy();\n        this.text = textIn;\n        this.args = [] as Args<T>;\n        await this.init();\n        this.allLines.forEach(line => line.enable());\n        const { defaultSize } = this;\n        if (!defaultSize.every((v, i) => v === oldDefaultSize[i])) {\n            this.size = defaultSize;\n            this.presentationSize = defaultSize;\n        }\n        this.emit(\"textChanged\", this);\n        this._object?.setMeta(this._object.meta);\n        await this.postInit();\n        return this;\n    }\n    update(e: { args?: any[]; props?: Record<string, any> }) {\n        const { args, props } = e;\n        if (args) this.args = args as Args<T>;\n        if (props) {\n            if (isTRect(props.rect)) {\n                this.setRect(props.rect);\n                delete props.rect;\n            }\n            if (isTPresentationRect(props.presentationRect)) {\n                this.setPresentationRect(props.presentationRect);\n                delete props.presentationRect;\n            }\n            if (typeof props.presentation === \"boolean\") {\n                this.setPresentation(props.presentation);\n                delete props.presentation;\n            }\n            if (typeof props.background === \"boolean\") {\n                this.setBackground(props.background);\n                delete props.background;\n            }\n            this.props = Object.assign(this.props, props);\n        }\n        return this;\n    }\n    get position() {\n        return this.rect.slice(0, 2) as [number, number];\n    }\n    set position([leftIn, topIn]: [number, number]) {\n        const [left, top, width, height] = this.rect;\n        this.setRect([typeof leftIn === \"number\" ? leftIn : left, typeof topIn === \"number\" ? topIn : top, width, height] as TRect);\n    }\n    get presentationPosition() {\n        return this.presentationRect.slice(0, 2) as [number | string, number | string];\n    }\n    set presentationPosition([leftIn, topIn]: [number | string, number | string]) {\n        const [left, top, width, height] = this.presentationRect;\n        this.setPresentationRect([typeof leftIn === \"number\" || typeof leftIn === \"string\" ? leftIn : left, typeof topIn === \"number\" || typeof topIn === \"string\" ? topIn : top, width, height] as TPresentationRect);\n    }\n    get size() {\n        return this.rect.slice(2) as [number, number];\n    }\n    set size([widthIn, heightIn]: [number, number]) {\n        const [left, top, width, height] = this.rect;\n        this.setRect([left, top, widthIn || width, heightIn || height] as TRect);\n    }\n    get presentationSize() {\n        return this.presentationRect.slice(2) as [number | string, number | string];\n    }\n    set presentationSize([widthIn, heightIn]: [number | string, number | string]) {\n        const [left, top, width, height] = this.presentationRect;\n        this.setPresentationRect([left, top, widthIn || width, heightIn || height] as TPresentationRect);\n    }\n    getLeft(inPresentation = false) {\n        const rectKey = inPresentation ? \"presentationRect\" : \"rect\";\n        return this[rectKey][0];\n    }\n    setLeft(leftIn: number | string, inPresentation = false) {\n        const positionKey = inPresentation ? \"presentationPosition\" : \"position\";\n        this[positionKey] = [leftIn as any, undefined];\n    }\n    getTop(inPresentation = false) {\n        const rectKey = inPresentation ? \"presentationRect\" : \"rect\";\n        return this[rectKey][1];\n    }\n    setTop(topIn: number | string, inPresentation = false) {\n        const positionKey = inPresentation ? \"presentationPosition\" : \"position\";\n        this[positionKey] = [undefined, topIn as any];\n    }\n    getWidth(inPresentation = false) {\n        const rectKey = inPresentation ? \"presentationRect\" : \"rect\";\n        return this[rectKey][2];\n    }\n    setWidth(widthIn: number | string, inPresentation = false) {\n        const sizeKey = inPresentation ? \"presentationSize\" : \"size\";\n        this[sizeKey] = [widthIn as any, undefined];\n    }\n    getHeight(inPresentation = false) {\n        const rectKey = inPresentation ? \"presentationRect\" : \"rect\";\n        return this[rectKey][3];\n    }\n    setHeight(heightIn: number | string, inPresentation = false) {\n        const sizeKey = inPresentation ? \"presentationSize\" : \"size\";\n        this[sizeKey] = [undefined, heightIn as any];\n    }\n    setBackground(bool: boolean) {\n        if (!!this.background === !!bool) return this;\n        this.background = bool;\n        this.emit(\"backgroundChanged\", this);\n        return this;\n    }\n    setPresentation(bool: boolean) {\n        if (!!this.presentation === !!bool) return this;\n        this.presentation = bool;\n        if (bool) this.presentationRect = this.rect.slice() as TRect;\n        this.emit(\"presentationChanged\", this);\n        return this;\n    }\n    setRect(rect: TRect) {\n        if (!isTRect(rect)) return this;\n        rect[0] = Math.max(0, rect[0]);\n        rect[1] = Math.max(0, rect[1]);\n        rect[2] = Math.max(15, rect[2]);\n        rect[3] = Math.max(15, rect[3]);\n        this.rect = rect;\n        this.inletLines.forEach(set => set.forEach(line => line.uiUpdateDest()));\n        this.outletLines.forEach(set => set.forEach(line => line.uiUpdateSrc()));\n        this.emit(\"rectChanged\", this);\n        return this;\n    }\n    setPresentationRect(rect: TPresentationRect) {\n        if (!isTPresentationRect(rect)) return this;\n        if (typeof rect[0] === \"number\") rect[0] = Math.max(0, rect[0]);\n        if (typeof rect[1] === \"number\") rect[1] = Math.max(0, rect[1]);\n        if (typeof rect[2] === \"number\") rect[2] = Math.max(15, rect[2]);\n        if (typeof rect[3] === \"number\") rect[3] = Math.max(15, rect[3]);\n        this.presentationRect = rect;\n        this.emit(\"presentationRectChanged\", this);\n        return this;\n    }\n    getIsMovable(inPresentation = false) {\n        if (!inPresentation) return true;\n        return isRectMovable(this.presentationRect);\n    }\n    getIsResizable(inPresentation = false) {\n        if (!inPresentation) return true;\n        return isRectResizable(this.presentationRect);\n    }\n    setZIndex(zIndex: number) {\n        const oldZIndex = this.zIndex;\n        this.zIndex = zIndex;\n        this.undoable({ oldZIndex, zIndex });\n        this._patcher.emit(\"zIndexChanged\", { boxId: this.id, zIndex });\n    }\n    error(text: string) {\n        this.emit(\"error\", text);\n        this._patcher.newLog(\"error\", \"Patcher\", text, this);\n    }\n    highlight() {\n        this._patcher.emit(\"highlightBox\", this.id);\n    }\n    highlightPort(isSrc: boolean, portIndex: number) {\n        this._patcher.emit(\"highlightPort\", { boxId: this.id, isSrc, i: portIndex });\n    }\n    undoable(e: { oldArgs?: Args<T>; args?: Args<T>; oldProps?: Props<T>; props?: Props<T>; oldState?: State<T>; state?: State<T>; oldZIndex: number; zIndex?: number }) {\n        this._patcher.boxChanged(this.id, e);\n    }\n    async changeObject({ args, props, state, zIndex }: { args?: Args<T>; props?: Props<T>; state?: State<T>; zIndex?: number }, options?: ObjectUpdateOptions) {\n        if (args) await this._object?.updateArgs(args, options);\n        if (props) await this._object?.updateProps(props, options);\n        if (state) await this._object?.updateState(state, options);\n    }\n    async destroy() {\n        this.allLines.forEach(line => this._patcher.deleteLine(line.id));\n        await this._object?.destroy();\n        delete this._patcher.boxes[this.id];\n        return this;\n    }\n    static parseObjText(strIn: string) {\n        const REGEX = /`([^`]*)`|[^\\s]+/gi;\n        const strArray = [];\n        let match = REGEX.exec(strIn);\n        while (match != null) {\n            // Index 1 in the array is the captured group if it exists\n            // Index 0 is the matched text, which we use if no captured group exists\n            strArray.push(match[1] ? match[1] : match[0]);\n            // Each call to exec returns the next regex match as an array\n            match = REGEX.exec(strIn);\n        }\n        const objOut: { class: string; args: any[]; props: Record<string, any> } = { class: \"\", args: [], props: {} };\n        let lastProp;\n        if (strArray.length) objOut.class = strArray.shift();\n        while (strArray.length) {\n            const el = strArray.shift();\n            if (typeof lastProp === \"undefined\" && el.charAt(0) !== \"@\") { // is arg, to push\n                try {\n                    objOut.args.push(JSON.parse(el));\n                } catch (e) {\n                    objOut.args.push(el);\n                }\n                continue;\n            }\n            if (el.length > 1 && el.charAt(0) === \"@\") { // is prop key\n                lastProp = el.substr(1);\n                objOut.props[lastProp] = [];\n                continue;\n            }\n            try { // is prop value\n                objOut.props[lastProp].push(JSON.parse(el));\n            } catch (e) {\n                objOut.props[lastProp].push(el);\n            }\n        }\n        for (const key in objOut.props) { // no value = true, one value need to parse, else array\n            if (objOut.props[key].length === 0) objOut.props[key] = true;\n            else if (objOut.props[key].length === 1) objOut.props[key] = parseToPrimitive(objOut.props[key][0]);\n            else objOut.props[key] = parseToPrimitive(objOut.props[key].join(\" \"));\n        }\n        return objOut;\n    }\n    toString() {\n        const { id, text, inlets, outlets, rect, background, presentation, presentationRect, args, props, data, zIndex } = this;\n        return JSON.stringify({ id, text, inlets, outlets, rect, background, presentation, presentationRect, args, props, data, zIndex });\n    }\n    toSerializable(): TBox {\n        return JSON.parse(this.toString());\n    }\n}\n","import type { Rec, Receive, Import, Iterator, FaustOp, Effect, In, Out, TLineMap } from \"../objects/Faust\";\nimport type Box from \"./Box\";\nimport type Line from \"./Line\";\nimport type Patcher from \"./Patcher\";\n\nconst mapLines = (box: Box, patcher: Patcher, visitedBoxes: Box[], ins: In[], recs: Rec[], lineMap: Map<Line, string>) => {\n    if (visitedBoxes.indexOf(box) >= 0) return;\n    visitedBoxes.push(box);\n    if (box.object.class === \"Iterator\" && box !== visitedBoxes[0]) return;\n    const inletLines = new Set(box.inletLines);\n    if (box.object.class === \"Receive\") {\n        const { sendID, _: { sendMap } } = box.object as Receive;\n        if (sendMap[sendID]) {\n            sendMap[sendID].forEach(s => s.inletLines.forEach(l => inletLines.add(l)));\n        }\n    }\n    inletLines.forEach(lines => lines.forEach((line) => {\n        const { srcBox } = line;\n        if (srcBox.object.class === \"In\" && ins.indexOf(srcBox.object as In) === -1) ins.push(srcBox.object as In);\n        else if (srcBox.object.class === \"Rec\" && recs.indexOf(srcBox.object as Rec) === -1) recs.push(srcBox.object as Rec);\n        if (srcBox.object.class === \"Effect\") lineMap.set(line, \"_\");\n        else lineMap.set(line, `${(srcBox.object as FaustOp).resultID}_${line.srcOutlet}`);\n        mapLines(srcBox, patcher, visitedBoxes, ins, recs, lineMap);\n    }));\n};\nexport const toFaustLambda = (patcher: Patcher, outs: FaustOp[], lambdaName: string) => {\n    const exprs: string[] = [];\n    const onces: string[] = [];\n    const mainIns: string[] = [];\n    const mainOuts: string[] = [];\n    const recIns: string[] = [];\n    const recOuts: string[] = [];\n    const visitedBoxes: Box[] = [];\n    let ins: In[] = [];\n    const recs: Rec[] = [];\n    const lineMap: TLineMap = new Map<Line, string>();\n    // Build graph\n    outs.forEach(out => mapLines(out.box, patcher, visitedBoxes, ins, recs, lineMap));\n    visitedBoxes.forEach((box) => {\n        if (box.object.class === \"In\") return;\n        if (box.object.class === \"Out\") return;\n        if (box.object.class === \"Rec\") return;\n        if (outs.indexOf(box.object as FaustOp) !== -1) return;\n        const { onces: o, exprs: e } = (box.object as FaustOp).toExpr(lineMap);\n        if (o) onces.push(...o.filter(v => onces.indexOf(v) === -1));\n        if (e) exprs.push(...e);\n    });\n    // Reverse order for readibility\n    exprs.reverse();\n    // Build rec in/outs\n    recs.forEach((rec) => {\n        exprs.push(...rec.toExpr(lineMap).exprs || []);\n        const recIn = rec.resultID;\n        const recOut = `${recIn}_0`;\n        recIns.push(recIn);\n        recOuts.push(recOut);\n    });\n    // Build main in/outs\n    ins = ins.sort((a, b) => a.index - b.index);\n    ins.forEach((in_) => {\n        const id = `${in_.resultID}_0`;\n        if (mainIns.indexOf(id) === -1) mainIns.push(id);\n    });\n    outs.forEach((out) => {\n        if (out.class === \"Iterator\") exprs.push(...(out as Iterator).toNormalExpr(lineMap).exprs || []);\n        else exprs.push(...out.toExpr(lineMap).exprs || []);\n        const id = out.resultID;\n        if (mainIns.indexOf(id) === -1) mainOuts.push(id);\n    });\n    // Generate Final expressions\n    exprs.forEach((s, i) => exprs[i] = `    ${s.replace(/\\n/g, \"\\n    \")}`); // indent\n    if (recIns.length) {\n        exprs.unshift(`Main(${[...recOuts, ...mainIns].join(\", \")}) = ${[...recIns, ...mainOuts].join(\", \")} with {`);\n        exprs.push(\n            \"};\",\n            `Rec = ${recIns.map(() => \"_\").join(\", \")} : ${recOuts.map(() => \"_\").join(\", \")};`,\n            `${lambdaName} = Main ~ Rec : ${[...recIns.map(() => \"!\"), ...mainOuts.map(() => \"_\")].join(\", \")};`\n        );\n    } else if (mainIns.length) {\n        exprs.unshift(`${lambdaName}(${mainIns.join(\", \")}) = ${mainOuts.join(\", \")} with {`);\n        exprs.push(\"};\");\n    } else if (exprs.length) {\n        exprs.unshift(`${lambdaName} = ${mainOuts.join(\", \")} with {`);\n        exprs.push(\"};\");\n    } else {\n        exprs.push(`${lambdaName} = 0;`);\n    }\n    return { onces, exprs, ins, outs };\n};\nexport const toFaustDspCode = (patcher: Patcher) => inspectFaustPatcher(patcher).code;\nexport const inspectFaustPatcher = (patcher: Patcher) => {\n    const imports: Import[] = [];\n    let outs: Out[] = [];\n    const effects: Effect[] = [];\n    // Find outs and imports\n    for (const boxId in patcher.boxes) {\n        const box = patcher.boxes[boxId];\n        if (box.object.class === \"Effect\") effects.push(box.object as Effect);\n        else if (box.object.class === \"Out\") outs.push(box.object as Out);\n        else if (box.object.class === \"Import\") imports.push(box.object as Import);\n    }\n    outs = outs.sort((a, b) => a.index - b.index);\n    const { onces, exprs, ins } = toFaustLambda(patcher, outs, \"process\");\n    if (effects.length) {\n        const { onces: fxOnces, exprs: fxExprs, ins: fxIns } = toFaustLambda(patcher, [effects[0]], \"effect\");\n        onces.push(...fxOnces.filter(v => onces.indexOf(v) === -1));\n        exprs.push(...fxExprs);\n        ins.push(...fxIns);\n    }\n    imports.map(i => i.toOnceExpr()).forEach(o => onces.push(...o.filter(v => onces.indexOf(v) === -1)));\n    const code = `${onces.join(\"\\n\")}${onces.length ? \"\\n\" : \"\"}${exprs.join(\"\\n\")}\\n`;\n    return { code, onces, exprs, ins, outs };\n};\n","import type { WamNode } from \"@webaudiomodules/api\";\nimport TypedEventEmitter from \"../../utils/TypedEventEmitter\";\nimport type Patcher from \"./Patcher\";\nimport type { TLine, TLineType } from \"../types\";\nimport type { IJSPatcherObject, TMetaType } from \"../objects/base/AbstractObject\";\n\nexport interface LineEventMap {\n    \"passData\": any;\n    \"destPosChanged\": { top: number; left: number };\n    \"srcPosChanged\": { top: number; left: number };\n    \"posChanged\": Line;\n    \"typeChanged\": TLineType;\n}\n\nexport default class Line extends TypedEventEmitter<LineEventMap> {\n    static isConnectableByAudio(from: IJSPatcherObject, outlet: number, to: IJSPatcherObject, inlet: number) {\n        const fromConnection = from?.outletAudioConnections[outlet];\n        const toConnection = to?.inletAudioConnections[inlet];\n        if (!fromConnection) return false;\n        if (!toConnection) return false;\n        if (!fromConnection.node) return false;\n        if (!toConnection.node) return false;\n        return true;\n    }\n    static isWamNode(x: any): x is WamNode {\n        return typeof x === \"object\" && x !== null && x?.module?.isWebAudioModule;\n    }\n    static compare(line1: Line, line2: Line) {\n        return line2.positionHash - line1.positionHash;\n    }\n    readonly id: string;\n    src: [string, number];\n    dest: [string, number];\n    disabled = true;\n    private _type: TLineType;\n    private readonly _patcher: Patcher;\n    constructor(patcherIn: Patcher, lineIn: TLine) {\n        super();\n        this.id = lineIn.id;\n        this.src = lineIn.src;\n        this.dest = lineIn.dest;\n        this.disabled = true;\n        this._patcher = patcherIn;\n        const { srcBox, destBox } = this;\n        this._type = this.calcType();\n        if (srcBox) {\n            srcBox.on(\"metaUpdated\", this.updateType);\n            srcBox.addOutletLine(this);\n        }\n        if (destBox) {\n            destBox.on(\"metaUpdated\", this.updateType);\n            destBox.addInletLine(this);\n        }\n    }\n    get isConnectableByAudio() {\n        if (this._patcher.props.mode !== \"js\") return false;\n        return Line.isConnectableByAudio(this.srcBox.object, this.srcOutlet, this.destBox.object, this.destInlet);\n    }\n    get presentation() {\n        return this.srcBox && this.srcBox.presentation && this.destBox && this.destBox.presentation;\n    }\n    setSrc(src: [string, number]) {\n        const srcId = src[0];\n        const srcOutlet = src[1];\n        if (srcId === this.src[0] && srcOutlet === this.src[1]) return this;\n        this.srcBox.off(\"metaUpdated\", this.updateType);\n        this.disable();\n        this.srcBox.removeOutletLine(this);\n        this.src = [srcId, srcOutlet];\n        this.srcBox.addOutletLine(this);\n        this.enable();\n        this.srcBox.on(\"metaUpdated\", this.updateType);\n        this.updateType();\n        return this.uiUpdateSrc();\n    }\n    getSrc() {\n        return this.src;\n    }\n    uiUpdateSrc() {\n        this.emit(\"srcPosChanged\", this.srcPos);\n        return this;\n    }\n    setDest(dest: [string, number]) {\n        const destId = dest[0];\n        const destInlet = dest[1];\n        if (destId === this.dest[0] && destInlet === this.dest[1]) return this;\n        this.destBox.off(\"metaUpdated\", this.updateType);\n        this.disable();\n        this.destBox.removeInletLine(this);\n        this.dest = [destId, destInlet];\n        this.destBox.addInletLine(this);\n        this.enable();\n        this.destBox.on(\"metaUpdated\", this.updateType);\n        this.updateType();\n        return this.uiUpdateDest();\n    }\n    getDest() {\n        return this.dest;\n    }\n    uiUpdateDest() {\n        this.emit(\"destPosChanged\", this.destPos);\n        return this;\n    }\n    disable(bool?: boolean): Line {\n        if (bool === false) return this.enable();\n        if (this.disabled) return this;\n        this.disabled = true;\n        const { srcBox, destBox } = this;\n        if (this._patcher.getLinesByBox(this.srcId, this.destId, this.srcOutlet, this.destInlet).length > 1) return this; // not last cable\n        if (this.isConnectableByAudio) {\n            const from = this.srcBox.object.outletAudioConnections[this.srcOutlet];\n            const to = this.destBox.object.inletAudioConnections[this.destInlet];\n            if (from && to && from.node && to.node) {\n                const isAudioParam = to.node instanceof AudioParam;\n                try {\n                    if (isAudioParam) from.node.disconnect(to.node as AudioParam, from.index);\n                    else from.node.disconnect(to.node as AudioNode, from.index, to.index);\n                    if (Line.isWamNode(from.node) && Line.isWamNode(to.node)) from.node.disconnectEvents(to.node.instanceId);\n                } catch (e) {\n                    this._patcher.error((e as Error).message);\n                }\n            }\n        }\n        srcBox.disconnectedOutlet(this.srcOutlet, destBox.id, this.destInlet, this.id);\n        destBox.disconnectedInlet(this.destInlet, srcBox.id, this.srcOutlet, this.id);\n        return this;\n    }\n    enable(bool?: boolean): Line {\n        if (bool === false) return this.disable();\n        if (!this.disabled) return this;\n        const { srcBox, destBox } = this;\n        if (this.srcOutlet >= srcBox.outlets || this.destInlet >= destBox.inlets) return this._patcher.deleteLine(this.id);\n        if (this._patcher.getLinesByBox(this.srcId, this.destId, this.srcOutlet, this.destInlet).length > 1) return this; // not last cable\n        if (this.isConnectableByAudio) {\n            const from = this.srcBox.object.outletAudioConnections[this.srcOutlet];\n            const to = this.destBox.object.inletAudioConnections[this.destInlet];\n            if (from && to && from.node && to.node) {\n                const isAudioParam = to.node instanceof AudioParam;\n                try {\n                    if (isAudioParam) from.node.connect(to.node as AudioParam, from.index);\n                    else from.node.connect(to.node as AudioNode, from.index, to.index);\n                    if (Line.isWamNode(from.node) && Line.isWamNode(to.node)) from.node.connectEvents(to.node.instanceId);\n                } catch (e) {\n                    this._patcher.error((e as Error).message);\n                }\n            }\n        }\n        this.disabled = false;\n        srcBox.connectedOutlet(this.srcOutlet, destBox.id, this.destInlet, this.id);\n        destBox.connectedInlet(this.destInlet, srcBox.id, this.srcOutlet, this.id);\n        return this;\n    }\n    destroy() {\n        this.destBox.off(\"metaUpdated\", this.updateType);\n        this.srcBox.off(\"metaUpdated\", this.updateType);\n        this.disable();\n        this.srcBox.removeOutletLine(this);\n        this.destBox.removeInletLine(this);\n        delete this._patcher.lines[this.id];\n        return this;\n    }\n    pass(data: any) {\n        this.emit(\"passData\", data);\n        return this.disabled ? this : this.destBox.fn(this.destInlet, data);\n    }\n    get positionHash() {\n        const { top, left } = this._patcher.boxes[this.dest[0]].getInletPos(this.dest[1]);\n        return left * 65536 + top;\n    }\n    get srcPos() {\n        return this._patcher.boxes[this.src[0]].getOutletPos(this.src[1]);\n    }\n    get destPos() {\n        return this._patcher.boxes[this.dest[0]].getInletPos(this.dest[1]);\n    }\n    get srcId() {\n        return this.src[0];\n    }\n    get srcOutlet() {\n        return this.src[1];\n    }\n    get destId() {\n        return this.dest[0];\n    }\n    get destInlet() {\n        return this.dest[1];\n    }\n    get srcBox() {\n        return this._patcher.boxes[this.src[0]];\n    }\n    get destBox() {\n        return this._patcher.boxes[this.dest[0]];\n    }\n    private calcType() {\n        const srcMeta = this.srcBox.object.meta.outlets;\n        const destMeta = this.destBox.object.meta.inlets;\n        let srcType: TMetaType = \"anything\";\n        let destType: TMetaType = \"anything\";\n        if (srcMeta[this.srcOutlet]) srcType = srcMeta[this.srcOutlet].type;\n        else if (srcMeta[srcMeta.length - 1] && srcMeta[srcMeta.length - 1].varLength) srcType = srcMeta[srcMeta.length - 1].type;\n        if (destMeta[this.destInlet]) destType = destMeta[this.destInlet].type;\n        else if (destMeta[destMeta.length - 1] && destMeta[destMeta.length - 1].varLength) destType = destMeta[destMeta.length - 1].type;\n        return srcType === \"signal\" && destType === \"signal\" ? \"audio\" : \"normal\";\n    }\n    updateType = () => {\n        const type = this.calcType();\n        if (type !== this._type) {\n            this._type = type;\n            this.emit(\"typeChanged\", type);\n        }\n    };\n    get type(): TLineType {\n        return this._type;\n    }\n    toString() {\n        return JSON.stringify(this.toSerializable());\n    }\n    toSerializable(): TLine {\n        const { id, src, dest, disabled } = this;\n        return { id, src: [...src], dest: [...dest], disabled };\n    }\n}\n","import FileInstance from \"../file/FileInstance\";\nimport PatcherEditor from \"./PatcherEditor\";\nimport Line from \"./Line\";\nimport Box from \"./Box\";\nimport PatcherHistory from \"./PatcherHistory\";\nimport PackageManager, { IPackageManager } from \"../PackageManager\";\nimport { max2js, js2max } from \"../../utils/utils\";\nimport { toFaustDspCode } from \"./FaustPatcherAnalyser\";\nimport type Env from \"../Env\";\nimport type Project from \"../Project\";\nimport type TempPatcherFile from \"./TempPatcherFile\";\nimport type PersistentProjectFile from \"../file/PersistentProjectFile\";\nimport type { IJSPatcherEnv } from \"../Env\";\nimport type { IProject } from \"../Project\";\nimport type { TInletEvent, TOutletEvent, IJSPatcherObjectMeta, IPropsMeta, IJSPatcherObject, TMetaType } from \"../objects/base/AbstractObject\";\nimport type { TLine, TBox, PatcherMode, RawPatcher, TMaxPatcher, TErrorLevel, TPatcherAudioConnection, TFlatPackage, TPackage, ILogInfo, TDependencies } from \"../types\";\nimport type PatcherNode from \"../worklets/PatcherNode\";\nimport type PatcherProcessor from \"../worklets/Patcher.worklet\";\n\nexport interface TPatcherProps {\n    mode: PatcherMode;\n    dependencies: TDependencies;\n    bgColor: string;\n    editingBgColor: string;\n    grid: [number, number];\n    boxIndexCount: number;\n    lineIndexCount: number;\n    package?: string;\n    name?: string;\n    author?: string;\n    version?: string;\n    description?: string;\n    openInPresentation: boolean;\n    objectInit: boolean;\n}\nexport type TPublicPatcherProps = Pick<TPatcherProps, \"dependencies\" | \"bgColor\" | \"editingBgColor\" | \"grid\" | \"openInPresentation\">;\n\nexport interface TPatcherState {\n    name: string;\n    isReady: boolean;\n    log: ILogInfo[];\n    selected: string[];\n    pkgMgr: IPackageManager;\n    preventEmitChanged: boolean;\n    patcherNode?: PatcherNode;\n    patcherProcessor?: PatcherProcessor;\n}\n\nexport interface PatcherEventMap extends TPublicPatcherProps {\n    \"postInited\": never;\n    \"ready\": never;\n    \"unload\": never;\n    \"changeBoxText\": { boxId: string; oldText: string; text: string };\n    \"boxChanged\": { boxId: string; oldArgs?: any[]; args?: any[]; oldProps?: Record<string, any>; props?: Record<string, any>; oldState?: Record<string, any>; state?: Record<string, any>; oldZIndex?: number; zIndex?: number };\n    \"zIndexChanged\": { boxId: string; zIndex: number };\n    \"passiveDeleteLine\": Line;\n    \"graphChanged\": never;\n    \"changed\": never;\n    \"ioChanged\": IJSPatcherObjectMeta;\n    \"dataInput\": TInletEvent<any[]>;\n    \"dataOutput\": TOutletEvent<any[]>;\n    \"audioInput\": { input: number; buffer: Float32Array };\n    \"paramInput\": { param: string; buffer: Float32Array };\n    \"audioOutput\": { output: number; buffer: Float32Array };\n    \"disconnectAudioInlet\": number;\n    \"disconnectAudioOutlet\": number;\n    \"connectAudioInlet\": number;\n    \"connectAudioOutlet\": number;\n    \"propsChanged\": { props: Partial<TPublicPatcherProps>; oldProps: Partial<TPublicPatcherProps> };\n    \"libChanged\": { pkg: TPackage; lib: TFlatPackage };\n    \"highlightBox\": string;\n    \"highlightPort\": { boxId: string; isSrc: boolean; i: number } | null;\n}\n\nexport default class Patcher extends FileInstance<PatcherEventMap, PersistentProjectFile | TempPatcherFile> {\n    static props: IPropsMeta<TPublicPatcherProps> = {\n        dependencies: {\n            type: \"object\",\n            description: \"Patcher dependencies\",\n            default: []\n        },\n        bgColor: {\n            type: \"color\",\n            description: \"Background color\",\n            default: \"rgba(61, 65, 70, 1)\"\n        },\n        editingBgColor: {\n            type: \"color\",\n            description: \"Background color while unlocked\",\n            default: \"rgba(82, 87, 94, 1)\"\n        },\n        grid: {\n            type: \"object\",\n            description: \"Grid size\",\n            default: [15, 15]\n        },\n        openInPresentation: {\n            type: \"boolean\",\n            description: \"Open patcher in presentation\",\n            default: false\n        }\n    };\n    static async fromProjectItem(options: { file: PersistentProjectFile | TempPatcherFile; env: IJSPatcherEnv; project?: IProject; instanceId?: string }): Promise<Patcher> {\n        return new this(options).init();\n    }\n    async getEditor() {\n        const editor = new PatcherEditor(this);\n        return editor.init();\n    }\n    lines: Record<string, Line> = {};\n    boxes: Record<string, Box> = {};\n    props: TPatcherProps;\n    _state: TPatcherState;\n    _inletAudioConnections: TPatcherAudioConnection[] = [];\n    _outletAudioConnections: TPatcherAudioConnection[] = [];\n    _history = new PatcherHistory();\n    constructor(options: { env: IJSPatcherEnv; project?: IProject; file?: PersistentProjectFile | TempPatcherFile; instanceId?: string; objectInit?: boolean }) {\n        super(options);\n        this._state = {\n            name: \"patcher\",\n            isReady: false,\n            log: [],\n            selected: [],\n            pkgMgr: undefined,\n            preventEmitChanged: false\n        };\n        this.lines = {};\n        this.boxes = {};\n        this.props = {\n            mode: \"js\",\n            dependencies: Patcher.props.dependencies.default.slice(),\n            bgColor: Patcher.props.bgColor.default,\n            editingBgColor: Patcher.props.editingBgColor.default,\n            grid: Patcher.props.grid.default.slice() as [number, number],\n            openInPresentation: Patcher.props.openInPresentation.default,\n            boxIndexCount: 0,\n            lineIndexCount: 0,\n            objectInit: typeof options.objectInit === \"boolean\" ? options.objectInit : true\n        };\n    }\n    get state() {\n        return this._state;\n    }\n    get activePkg() {\n        return this._state.pkgMgr.pkg;\n    }\n    get activeLib() {\n        return this._state.pkgMgr.lib;\n    }\n    get isReady() {\n        return !!this._state?.isReady;\n    }\n    get audioCtx() {\n        return (this.project as Project)?.audioCtx || (this.env as Env).audioCtx;\n    }\n    get fileExtension() {\n        return {\n            js: \"jspat\",\n            max: \"maxpat\",\n            gen: \"gendsp\",\n            faust: \"dsppat\",\n            jsaw: \"jsdsp\"\n        }[this.props.mode];\n    }\n    get fileName() {\n        return this.file?.name || `${this._state.name}.${this.fileExtension}`;\n    }\n    emitGraphChanged() {\n        if (this._state.preventEmitChanged) return;\n        this.emit(\"graphChanged\");\n        this.emitChanged();\n    }\n    emitChanged() {\n        if (this._state.preventEmitChanged) return;\n        this.emit(\"changed\");\n    }\n    boxChanged(boxId: string, changed: { oldArgs?: any[]; args?: any[]; oldProps?: Record<string, any>; props?: Record<string, any>; oldState?: Record<string, any>; state?: Record<string, any> }) {\n        this.emit(\"boxChanged\", { boxId, ...changed });\n    }\n    async init(data = this.file?.data, fileName = this.fileName) {\n        if (data instanceof ArrayBuffer) {\n            if (!data.byteLength) return this.load({});\n            const patcherIn = await new Response(data).json();\n            const splitName = fileName.split(\".\");\n            const ext = splitName.pop();\n            const extMap: Record<string, PatcherMode> = { json: \"js\", jspat: \"js\", maxpat: \"max\", gendsp: \"gen\", dsppat: \"faust\" };\n            return this.load(patcherIn, extMap[ext] || \"js\");\n        }\n        return this.load(data || {});\n    }\n    async load(patcherIn: RawPatcher | TMaxPatcher | any, modeIn?: PatcherMode) {\n        this._state.isReady = false;\n        this._state.preventEmitChanged = true;\n        await this.unload();\n        if (typeof patcherIn !== \"object\") {\n            this._state.isReady = true;\n            this._state.preventEmitChanged = false;\n            this.emit(\"ready\");\n            return this;\n        }\n        await this.env.taskMgr.newTask(this, \"Loading patcher...\", async (onUpdate) => {\n            this.props.mode = patcherIn.props?.mode || modeIn || \"js\";\n            this.state.pkgMgr = new PackageManager(this);\n            const { mode } = this.props;\n            const $init: Promise<Box>[] = [];\n            onUpdate(\"Decoding Patcher...\");\n            let patcher;\n            if (mode === \"max\" || mode === \"gen\") {\n                if (!(patcherIn as TMaxPatcher).patcher) {\n                    patcher = patcherIn;\n                } else {\n                    patcher = max2js(patcherIn as TMaxPatcher);\n                }\n            } else if (mode === \"js\" || mode === \"faust\" || mode === \"jsaw\") {\n                if (\"data\" in patcherIn && \"patcher\" in patcherIn) {\n                    patcher = patcherIn.patcher;\n                } else {\n                    patcher = patcherIn;\n                }\n            }\n            if (patcher.props) this.props = { ...this.props, ...patcher.props, mode };\n            if (Array.isArray(this.props.bgColor)) this.props.bgColor = `rgba(${this.props.bgColor.join(\", \")})`;\n            if (Array.isArray(this.props.editingBgColor)) this.props.editingBgColor = `rgba(${this.props.editingBgColor.join(\", \")})`;\n            if (mode === \"js\" && this.props.dependencies) {\n                const { dependencies } = this.props;\n                if (!Array.isArray(dependencies)) {\n                    this.props.dependencies = [];\n                    for (const key in dependencies as Record<string, string>) {\n                        this.props.dependencies.push([key, dependencies[key]]);\n                    }\n                }\n            }\n            onUpdate(\"Initializing Packages...\");\n            await this._state.pkgMgr.init();\n            onUpdate(\"Creating Boxes...\");\n            if (patcher.boxes) { // Boxes & data\n                for (const id in patcher.boxes) {\n                    onUpdate(`Creating Boxes ${id}`);\n                    const $ = this.createBox(patcher.boxes[id]);\n                    $init.push($);\n                    const numID = parseInt(id.match(/\\d+/)[0]);\n                    if (numID > this.props.boxIndexCount) this.props.boxIndexCount = numID;\n                }\n            }\n            onUpdate(\"Initializing Boxes...\");\n            await Promise.all($init);\n            onUpdate(\"Creating Lines...\");\n            if (patcher.lines) { // Lines\n                for (const id in patcher.lines) {\n                    this.createLine(patcher.lines[id]);\n                    const numID = parseInt(id.match(/\\d+/)[0]);\n                    if (numID > this.props.lineIndexCount) this.props.lineIndexCount = numID;\n                }\n            }\n            onUpdate(\"Finishing...\");\n            this._state.isReady = true;\n            this._state.preventEmitChanged = false;\n            this.emitGraphChanged();\n            this.emit(\"ready\");\n            await Promise.all(Object.keys(this.boxes).map(id => this.boxes[id].postInit()));\n            this.emit(\"postInited\");\n        });\n        return this;\n    }\n    async getPatcherNode(inputs = 2, outputs = 2) {\n        if (this.props.mode === \"jsaw\" && this.env.thread === \"main\") {\n            const PatcherNode = (await import(\"../worklets/PatcherNode\")).default;\n            await PatcherNode.register(this.audioCtx.audioWorklet);\n            this.state.patcherNode = new PatcherNode(this.audioCtx, { env: this.env, instanceId: this.id, fileId: this.file?.id, data: this.file ? undefined : this.toSerializable(), inputs, outputs });\n            await this.state.patcherNode.init();\n            return this.state.patcherNode;\n        }\n        return null;\n    }\n    async loadFromURL(url: string) {\n        try {\n            const file = await fetch(url);\n            const parsed = await file.json() as RawPatcher | TMaxPatcher;\n            return this.load(parsed);\n        } catch (e) {\n            this.error(`Fetch file ${url} failed.`);\n        }\n        return this;\n    }\n    async loadFromString(sIn: string) {\n        try {\n            const parsed = JSON.parse(sIn) as RawPatcher | TMaxPatcher;\n            return this.load(parsed);\n        } catch (e) {\n            this.error(`Load from string: ${sIn.slice(20)}... failed.`);\n        }\n        return this;\n    }\n    async loadFromFile(file: File) {\n        const splitName = file.name.split(\".\");\n        const ext = splitName.pop();\n        const name = splitName.join(\".\");\n        const extMap: Record<string, PatcherMode> = { json: \"js\", jspat: \"js\", maxpat: \"max\", gendsp: \"gen\", dsppat: \"faust\" };\n        if (!extMap[ext]) return this;\n        const reader = new FileReader();\n        reader.onload = () => {\n            let parsed: RawPatcher | TMaxPatcher;\n            try {\n                parsed = JSON.parse(reader.result.toString());\n            } catch (e) {\n                this.error((e as Error).message);\n            }\n            if (parsed) {\n                this.load(parsed, extMap[ext]);\n                this._state.name = name;\n            }\n        };\n        reader.onerror = () => this.error(reader.error.message);\n        reader.readAsText(file, \"UTF-8\");\n        return this;\n    }\n    async unload() {\n        await this.emit(\"unload\");\n        if (Object.keys(this.boxes).length) {\n            this._state.preventEmitChanged = true;\n            await Promise.all(Object.keys(this.boxes).map(id => this.boxes[id].destroy()));\n            this._state.preventEmitChanged = false;\n            this.emitGraphChanged();\n        }\n        this.lines = {};\n        this.boxes = {};\n        this.props = {\n            mode: \"js\",\n            dependencies: Patcher.props.dependencies.default.slice(),\n            bgColor: Patcher.props.bgColor.default,\n            editingBgColor: Patcher.props.editingBgColor.default,\n            grid: Patcher.props.grid.default.slice() as [number, number],\n            openInPresentation: Patcher.props.openInPresentation.default,\n            boxIndexCount: 0,\n            lineIndexCount: 0,\n            objectInit: true\n        };\n        this._state.selected = [];\n    }\n    async destroy() {\n        await this.unload();\n        await super.destroy();\n    }\n    async addPackage(namespace: string, url: string) {\n        const { dependencies } = this.props;\n        dependencies.push([namespace, url]);\n        this.setProps({ dependencies: dependencies.slice() });\n        await this.state.pkgMgr.init();\n        if (!(namespace in this.activePkg)) {\n            this.setProps({ dependencies: dependencies.filter(([id]) => id !== namespace) });\n        }\n    }\n    async removePackage(id: string) {\n        const { dependencies } = this.props;\n        const i = dependencies.findIndex(t => t[0] === id);\n        if (i === -1) return;\n        dependencies.splice(i, 1);\n        this.setProps({ dependencies: dependencies.slice() });\n        await this.state.pkgMgr.init();\n    }\n    async createBox(boxIn: TBox) {\n        if (!boxIn.id || (boxIn.id in this.boxes)) boxIn.id = \"box-\" + ++this.props.boxIndexCount;\n        const box = new Box(this, boxIn);\n        this.boxes[box.id] = box;\n        await box.init();\n        this.emitGraphChanged();\n        return box;\n    }\n    getObjectConstructor(parsed: { class: string; args: any[]; props: Record<string, any> }) {\n        const className = parsed.class;\n        if (typeof className !== \"string\" || className.length === 0) return this.activeLib.EmptyObject;\n        if (this.activeLib[className]) return this.activeLib[className];\n        return this.activeLib.InvalidObject;\n    }\n    getObjectMeta(parsed: { class: string; args: any[]; props: Record<string, any> }) {\n        return this.getObjectConstructor(parsed).meta;\n    }\n    async changeBoxText(boxId: string, text: string) {\n        const oldText = this.boxes[boxId].text;\n        if (oldText === text) return this.boxes[boxId];\n        await this.boxes[boxId].changeText(text);\n        this.emit(\"changeBoxText\", { oldText, text, boxId });\n        this.emitGraphChanged();\n        return this.boxes[boxId];\n    }\n    async deleteBox(boxId: string) {\n        const box = this.boxes[boxId];\n        if (!box) return null;\n        await box.destroy();\n        this.emitGraphChanged();\n        return box;\n    }\n    createLine(lineIn: TLine) {\n        if (!this.canCreateLine(lineIn)) return null;\n        if (!lineIn.id || (lineIn.id in this.lines)) lineIn.id = \"line-\" + ++this.props.lineIndexCount;\n        const line = new Line(this, lineIn);\n        this.lines[line.id] = line;\n        line.enable();\n        this.emitGraphChanged();\n        return line;\n    }\n    canCreateLine(lineIn: TLine) {\n        if (lineIn.src[1] >= this.boxes[lineIn.src[0]].outlets) return false;\n        if (lineIn.dest[1] >= this.boxes[lineIn.dest[0]].inlets) return false;\n        if (this.getLinesByBox(lineIn.src[0], lineIn.dest[0], lineIn.src[1], lineIn.dest[1]).length > 0) return false;\n        return true;\n    }\n    deleteLine(lineId: string) {\n        const line = this.lines[lineId];\n        if (!line) return null;\n        line.destroy();\n        if (!this._state.preventEmitChanged) this.emit(\"passiveDeleteLine\", line);\n        this.emitGraphChanged();\n        return line;\n    }\n    changeLineSrc(lineId: string, srcId: string, srcOutlet: number) {\n        const line = this.lines[lineId];\n        // if (this.instance.getLinesByBox(srcId, line.destId, srcOutlet, line.destInlet).length > 0) return line;\n        const oldSrc: [string, number] = [line.srcId, line.srcOutlet];\n        const src: [string, number] = [srcId, srcOutlet];\n        line.setSrc(src);\n        this.emitGraphChanged();\n        return { lineId, oldSrc, src };\n    }\n    changeLineDest(lineId: string, destId: string, destOutlet: number) {\n        const line = this.lines[lineId];\n        // if (this.getLinesByBox(line.srcId, destId, line.destInlet, destOutlet).length > 0) return line;\n        const oldDest: [string, number] = [line.destId, line.destInlet];\n        const dest: [string, number] = [destId, destOutlet];\n        line.setDest(dest);\n        this.emitGraphChanged();\n        return { lineId, oldDest, dest };\n    }\n    getLinesBySrcID(srcId: string) {\n        const result = [];\n        for (let i = 0; i < this.boxes[srcId].outlets; i++) { // Array.fill fills the array with same instance\n            result[i] = [];\n        }\n        for (const id in this.lines) {\n            const line = this.lines[id];\n            if (line && line.srcId === srcId) {\n                const srcOutlet = line.srcOutlet;\n                if (!result[srcOutlet]) result[srcOutlet] = [id];\n                else result[srcOutlet].push(id);\n            }\n        }\n        return result;\n    }\n    getLinesByDestID(destId: string) {\n        const result = [];\n        for (let i = 0; i < this.boxes[destId].inlets; i++) {\n            result[i] = [];\n        }\n        for (const id in this.lines) {\n            const line = this.lines[id];\n            if (line && line.destId === destId) {\n                const destInlet = line.destInlet;\n                if (!result[destInlet]) result[destInlet] = [id];\n                else result[destInlet].push(id);\n            }\n        }\n        return result;\n    }\n    getLinesByBox(srcId: string, destId: string, srcOutlet?: number, destInlet?: number) {\n        const result: string[] = [];\n        let srcOuts: string[] = [];\n        let destIns: string[] = [];\n        const srcOutsWraped = this.getLinesBySrcID(srcId);\n        if (srcOutlet !== undefined) srcOuts = srcOutsWraped[srcOutlet];\n        else srcOutsWraped.forEach(el => srcOuts = srcOuts.concat(el));\n        const destInsWraped = this.getLinesByDestID(destId);\n        if (destInlet !== undefined) destIns = destInsWraped[destInlet];\n        else destInsWraped.forEach(el => destIns = destIns.concat(el));\n        if (!srcOuts || !destIns) return result;\n        srcOuts.forEach(idOut => destIns.forEach(idIn => (idIn === idOut ? result.push(idIn) : undefined)));\n        return result;\n    }\n    fn(data: any, inlet: number) {\n        this.emit(\"dataInput\", { data, inlet });\n    }\n    inputAudio(input: number, buffer: Float32Array) {\n        this.emitSync(\"audioInput\", { input, buffer });\n    }\n    inputParam(param: string, buffer: Float32Array) {\n        this.emitSync(\"paramInput\", { param, buffer });\n    }\n    outputAudio(output: number, buffer: Float32Array) {\n        this.emitSync(\"audioOutput\", { output, buffer });\n    }\n    outlet(outlet: number, data: any) {\n        this.emit(\"dataOutput\", { data, outlet });\n    }\n    get inletAudioConnections() {\n        return this._inletAudioConnections;\n    }\n    get outletAudioConnections() {\n        return this._outletAudioConnections;\n    }\n    connectAudioInlet(index: number) {\n        this.emit(\"connectAudioInlet\", index);\n    }\n    connectAudioOutlet(index: number) {\n        this.emit(\"connectAudioOutlet\", index);\n    }\n    disconnectAudioInlet(index: number) {\n        this.emit(\"disconnectAudioInlet\", index);\n    }\n    disconnectAudioOutlet(index: number) {\n        this.emit(\"disconnectAudioOutlet\", index);\n    }\n    changeIO() {\n        this.emit(\"ioChanged\", this.meta);\n    }\n    inspectAudioIO() {\n        const inputBoxes: Box[] = [];\n        const outputBoxes: Box[] = [];\n        const parametersBoxes: [string, Box][] = [];\n        for (const boxId in this.boxes) {\n            const box = this.boxes[boxId];\n            const arg0 = box.args[0];\n            const port = Math.max(1, ~~arg0) - 1;\n            if (box.meta.isPatcherInlet === \"audio\") inputBoxes[port] = box;\n            else if (box.meta.isPatcherInlet === \"parameter\") parametersBoxes.push([arg0, box]);\n            else if (box.meta.isPatcherOutlet === \"audio\") outputBoxes[port] = box;\n        }\n        for (let i = 0; i < this._inletAudioConnections.length; i++) {\n            if (!inputBoxes[i]) delete this._inletAudioConnections[i];\n        }\n        for (let i = 0; i < this._outletAudioConnections.length; i++) {\n            if (!outputBoxes[i]) delete this._outletAudioConnections[i];\n        }\n        return { inputBoxes, outputBoxes, parametersBoxes };\n    }\n    get meta(): IJSPatcherObjectMeta {\n        const { metaFromPatcher } = this;\n        return {\n            package: this.props.package || \"\",\n            name: this.props.name || \"\",\n            icon: null,\n            author: this.props.author || \"\",\n            version: this.props.version || \"\",\n            description: this.props.description || \"\",\n            isPatcherInlet: false,\n            isPatcherOutlet: false,\n            ...metaFromPatcher\n        };\n    }\n    get metaFromPatcher(): Pick<IJSPatcherObjectMeta, \"inlets\" | \"outlets\" | \"args\" | \"props\"> {\n        const inlets: IJSPatcherObjectMeta[\"inlets\"] = [];\n        const outlets: IJSPatcherObjectMeta[\"outlets\"] = [];\n        for (const boxId in this.boxes) {\n            const box = this.boxes[boxId] as Box<IJSPatcherObject<any, any, any[], any[], any[], { description: string; type: TMetaType }>>;\n            const port = Math.max(1, ~~box.args[0]) - 1;\n            const description = box.props.description || \"\";\n            if (box.meta.isPatcherInlet === \"data\" && !inlets[port]) {\n                inlets[port] = {\n                    isHot: true,\n                    type: box.props.type || \"anything\",\n                    description\n                };\n            } else if (box.meta.isPatcherInlet === \"audio\") {\n                inlets[port] = {\n                    isHot: true,\n                    type: \"signal\",\n                    description\n                };\n            } else if (box.meta.isPatcherOutlet === \"data\" && !outlets[port]) {\n                outlets[port] = {\n                    type: box.props.type || \"anything\",\n                    description\n                };\n            } else if (box.meta.isPatcherOutlet === \"audio\") {\n                outlets[port] = {\n                    type: \"signal\",\n                    description\n                };\n            }\n        }\n        return { inlets, outlets, args: [], props: {} };\n    }\n    log(message: string) {\n        this.newLog(\"none\", \"Patcher\", message, this);\n    }\n    error(message: string) {\n        this.newLog(\"error\", \"Patcher\", message, this);\n    }\n    newLog(errorLevel: TErrorLevel, title: string, message: string, emitter?: any) {\n        this.env.newLog(errorLevel, title, message, emitter);\n    }\n    setProps(props: Partial<TPublicPatcherProps>) {\n        let changed = false;\n        const oldProps: Partial<TPublicPatcherProps> = {};\n        for (const keyIn in props) {\n            const key = keyIn as keyof TPublicPatcherProps;\n            if (this.props[key] === props[key]) continue;\n            changed = true;\n            (oldProps as any)[key] = this.props[key];\n            (this.props as any)[key] = props[key];\n            this.emit(key, props[key]);\n        }\n        if (changed) {\n            this.emit(\"propsChanged\", { props, oldProps });\n            this.emitChanged();\n        }\n    }\n    get publicProps() {\n        const { dependencies, bgColor, editingBgColor, grid, openInPresentation } = this.props;\n        return { dependencies, bgColor, editingBgColor, grid, openInPresentation } as TPublicPatcherProps;\n    }\n    toFaustDspCode() {\n        const code = toFaustDspCode(this);\n        return code;\n    }\n    toString(spacing?: number) {\n        if (this.props.mode === \"max\" || this.props.mode === \"gen\") {\n            return JSON.stringify(js2max(this), undefined, spacing);\n        }\n        const { props } = this;\n        const boxes: RawPatcher[\"boxes\"] = {};\n        const lines: RawPatcher[\"lines\"] = {};\n        for (const id in this.boxes) {\n            boxes[id] = this.boxes[id].toSerializable();\n        }\n        for (const id in this.lines) {\n            lines[id] = this.lines[id].toSerializable();\n        }\n        return JSON.stringify({ boxes, lines, props }, undefined, spacing);\n    }\n    toSerializable(): RawPatcher {\n        return JSON.parse(this.toString());\n    }\n    serialize() {\n        return new Blob([this.toString()]).arrayBuffer();\n    }\n}\n","import type { SemanticICONS } from \"semantic-ui-react\";\nimport { getTimestamp, isRectMovable, isRectResizable, isTRect } from \"../../utils/utils\";\nimport FileEditor from \"../file/FileEditor\";\nimport Box from \"./Box\";\nimport Line from \"./Line\";\nimport type { RawPatcher, TBox, TLine, TMaxClipboard, TRect, TResizeHandlerType } from \"../types\";\nimport type Patcher from \"./Patcher\";\nimport type PersistentProjectFile from \"../file/PersistentProjectFile\";\nimport type TempPatcherFile from \"./TempPatcherFile\";\nimport type { IJSPatcherEnv } from \"../Env\";\nimport type { IProject } from \"../Project\";\nimport type { PatcherEventMap, TPublicPatcherProps } from \"./Patcher\";\n\nexport interface PatcherEditorEventMap extends PatcherEditorState {\n    \"create\": RawPatcher;\n    \"delete\": RawPatcher;\n    \"changeBoxText\": { boxId: string; oldText: string; text: string };\n    \"boxChanged\": { boxId: string; oldArgs?: any[]; args?: any[]; oldProps?: Record<string, any>; props?: Record<string, any>; oldState?: Record<string, any>; state?: Record<string, any>; oldZIndex?: number; zIndex?: number };\n    \"zIndexChanged\": { boxId: string; zIndex: number };\n    \"changeLineSrc\": { lineId: string; oldSrc: [string, number]; src: [string, number] };\n    \"changeLineDest\": { lineId: string; oldDest: [string, number]; dest: [string, number] };\n    \"selected\": string[];\n    \"moving\": { selected: string[]; delta: { x: number; y: number }; presentation: boolean };\n    \"moved\": { selected: string[]; delta: { x: number; y: number }; presentation: boolean };\n    \"resized\": { selected: string[]; delta: { x: number; y: number }; type: TResizeHandlerType; presentation: boolean };\n    \"tempLine\": { findSrc: boolean; from: [string, number] };\n    \"inspector\": never;\n    \"dockUI\": string;\n    \"propsChanged\": { props: Partial<TPublicPatcherProps>; oldProps: Partial<TPublicPatcherProps> };\n    \"highlightBox\": string;\n    \"highlightPort\": { boxId: string; isSrc: boolean; i: number } | null;\n}\n\nexport interface PatcherHistoryEventMap extends Pick<PatcherEditorEventMap, \"create\" | \"delete\" | \"changeBoxText\" | \"changeLineSrc\" | \"changeLineDest\" | \"moved\" | \"resized\" | \"boxChanged\" | \"propsChanged\"> {}\n\nexport interface PatcherEditorState {\n    locked: boolean;\n    presentation: boolean;\n    showGrid: boolean;\n    snapToGrid: boolean;\n    selectAfterEdit: boolean;\n    selected: string[];\n}\n\nexport default class PatcherEditor extends FileEditor<Patcher, PatcherEditorEventMap> {\n    static async fromProjectItem({ file, env, project, instanceId }: { file: PersistentProjectFile | TempPatcherFile; env: IJSPatcherEnv; project?: IProject; instanceId?: string }): Promise<PatcherEditor> {\n        const patcher = await file.instantiate({ env, project, instanceId }) as Patcher;\n        const editor = new this(patcher);\n        return editor.init();\n    }\n    state: PatcherEditorState = {\n        locked: true,\n        presentation: false,\n        showGrid: true,\n        snapToGrid: true,\n        selectAfterEdit: true,\n        selected: []\n    };\n    get isLocked() {\n        return this.state.locked;\n    }\n    get boxes() {\n        return this.instance.boxes;\n    }\n    get lines() {\n        return this.instance.lines;\n    }\n    get props() {\n        return this.instance.props;\n    }\n    get publicProps() {\n        return this.instance.publicProps;\n    }\n    get fileExtension() {\n        return this.instance.fileExtension;\n    }\n    get fileName() {\n        return this.instance.fileName;\n    }\n    get fileIcon(): SemanticICONS {\n        return \"sitemap\";\n    }\n    handleChangeBoxText = (e: PatcherEventMap[\"changeBoxText\"]) => this.emit(\"changeBoxText\", e);\n    handlePassiveDeleteLine = (e: PatcherEventMap[\"passiveDeleteLine\"]) => this.emit(\"delete\", { boxes: {}, lines: { [e.id]: e.toSerializable() } });\n    handleBoxChanged = (e: PatcherEventMap[\"boxChanged\"]) => this.emit(\"boxChanged\", e);\n    handlePropsChanged = (e: PatcherEventMap[\"propsChanged\"]) => this.emit(\"propsChanged\", e);\n    handleZIndexChanged = (e: PatcherEventMap[\"zIndexChanged\"]) => this.emit(\"zIndexChanged\", e);\n    handleHighlightBox = (e: PatcherEventMap[\"highlightBox\"]) => this.emit(\"highlightBox\", e);\n    handleHighlightPort = (e: PatcherEventMap[\"highlightPort\"]) => this.emit(\"highlightPort\", e);\n    handleChanged = () => this.instance.emitChanged();\n    constructor(instance: Patcher) {\n        super(instance);\n        const { openInPresentation } = this.props;\n        this.setState({\n            locked: true,\n            presentation: !!openInPresentation,\n            showGrid: true,\n            snapToGrid: true,\n            selectAfterEdit: true,\n            selected: []\n        });\n    }\n    async init() {\n        if (!this.instance.isReady) {\n            await new Promise<void>((resolve, reject) => {\n                const handleReady = () => {\n                    resolve();\n                    this.instance.off(\"ready\", handleReady);\n                };\n                this.instance.on(\"ready\", handleReady);\n            });\n        }\n        this.on(\"changed\", this.handleChanged);\n        this.instance.on(\"changeBoxText\", this.handleChangeBoxText);\n        this.instance.on(\"passiveDeleteLine\", this.handlePassiveDeleteLine);\n        this.instance.on(\"boxChanged\", this.handleBoxChanged);\n        this.instance.on(\"propsChanged\", this.handlePropsChanged);\n        this.instance.on(\"zIndexChanged\", this.handleZIndexChanged);\n        this.instance.on(\"highlightBox\", this.handleHighlightBox);\n        this.instance.on(\"highlightPort\", this.handleHighlightPort);\n        const { openInPresentation } = this.props;\n        this.setState({\n            locked: true,\n            presentation: !!openInPresentation,\n            showGrid: true,\n            snapToGrid: true,\n            selectAfterEdit: true,\n            selected: []\n        });\n        this._isReady = true;\n        this.emit(\"ready\");\n        return this;\n    }\n    setState(state: Partial<PatcherEditorState>) {\n        let changed = false;\n        for (const keyIn in state) {\n            const key = keyIn as keyof PatcherEditorState;\n            if (this.state[key] === state[key]) continue;\n            changed = true;\n            if (key === \"locked\" || key === \"presentation\") this.deselectAll();\n            this.state[key] = state[key] as any;\n            this.emit(key, state[key]);\n        }\n        // if (changed) this.emit(\"stateChanged\", this.state);\n        return changed;\n    }\n    async createBox(boxIn: TBox) {\n        const box = await this.instance.createBox(boxIn);\n        this.emit(\"create\", { boxes: { [box.id]: box.toSerializable() }, lines: {} });\n        await box.postInit();\n        return box;\n    }\n    async createBoxFromFile(file: PersistentProjectFile, boxIn: Omit<TBox, \"text\">) {\n        const path = file.projectPath;\n        const type = file.type;\n        const ext = file.fileExtension;\n        if (type === \"patcher\") {\n            const extMap: Record<string, string> = this.props.mode === \"js\"\n                ? { json: \"p\", jspat: \"p\", maxpat: \"max\", gendsp: \"gen\", dsppat: \"pfaust\" }\n                : this.props.mode === \"faust\"\n                    ? { gendsp: \"gen\", dsppat: \"p\" }\n                    : this.props.mode === \"gen\"\n                        ? { gendsp: \"gen\" }\n                        : {};\n            const obj = extMap[ext];\n            if (obj) await this.createBox({ text: `${obj} ${path}`, ...boxIn });\n        } else if (type === \"audio\") {\n            await this.createBox({ text: `buffer~ ${path}`, ...boxIn });\n        } else if (type === \"image\") {\n            await this.createBox({ text: `img ${path}`, ...boxIn });\n        } else if (type === \"text\") {\n            await this.createBox({ text: `ptext ${path}`, ...boxIn });\n        }\n    }\n    async deleteBox(boxId: string) {\n        this.deselect(boxId);\n        const box = await this.instance.deleteBox(boxId);\n        if (!box) return null;\n        this.emit(\"delete\", { boxes: { [box.id]: box.toSerializable() }, lines: {} });\n        return box;\n    }\n    createLine(lineIn: TLine) {\n        const line = this.instance.createLine(lineIn);\n        if (!line) return null;\n        this.emit(\"create\", { boxes: {}, lines: { [line.id]: line.toSerializable() } });\n        return line;\n    }\n    deleteLine(lineId: string) {\n        this.deselect(lineId);\n        const line = this.instance.deleteLine(lineId);\n        if (!line) return null;\n        this.emit(\"delete\", { boxes: {}, lines: { [line.id]: line.toSerializable() } });\n        return line;\n    }\n    changeLineSrc(lineId: string, srcId: string, srcOutlet: number) {\n        const e = this.instance.changeLineSrc(lineId, srcId, srcOutlet);\n        this.emit(\"changeLineSrc\", e);\n    }\n    changeLineDest(lineId: string, destId: string, destOutlet: number) {\n        const e = this.instance.changeLineDest(lineId, destId, destOutlet);\n        this.emit(\"changeLineDest\", e);\n    }\n    async changeBox(boxId: string, change: { args?: any[]; props?: Record<string, any>; state?: Record<string, any>; zIndex?: number }) {\n        if (typeof change.zIndex === \"number\") this.instance.boxes[boxId]?.setZIndex(change.zIndex);\n        await this.instance.boxes[boxId]?.changeObject(change);\n    }\n\n    select(...ids: string[]) {\n        ids.forEach((id) => {\n            if (this.state.selected.indexOf(id) >= 0) return;\n            if (this.boxes[id] || this.lines[id]) this.state.selected.push(id);\n        });\n        this.emit(\"selected\", this.state.selected.slice());\n    }\n    selectAllBoxes() {\n        let ids = Object.keys(this.boxes);\n        if (this.state.presentation) ids = ids.filter(id => this.boxes[id].presentation);\n        this.state.selected = ids;\n        this.emit(\"selected\", ids);\n    }\n    selectOnly(...ids: string[]) {\n        this.state.selected = [];\n        this.select(...ids);\n    }\n    deselect(...ids: string[]) {\n        ids.forEach((id) => {\n            const i = this.state.selected.indexOf(id);\n            if (i === -1) return;\n            this.state.selected.splice(i, 1);\n        });\n        this.emit(\"selected\", this.state.selected.slice());\n    }\n    deselectAll() {\n        this.state.selected = [];\n        this.emit(\"selected\", []);\n    }\n    selectedToString() {\n        const lineSet = new Set<Line>();\n        const patcher: RawPatcher = { lines: {}, boxes: {} };\n        this.state.selected\n            .filter(id => id.startsWith(\"box\") && this.boxes[id])\n            .map(id => this.boxes[id])\n            .forEach((box) => {\n                box.allLines.forEach(line => lineSet.add(line));\n                patcher.boxes[box.id] = box.toSerializable();\n            });\n        lineSet.forEach((line) => {\n            if (patcher.boxes[line.srcId] && patcher.boxes[line.destId]) patcher.lines[line.id] = line.toSerializable();\n        });\n        if (!Object.keys(patcher.boxes)) return undefined;\n        return JSON.stringify(patcher, undefined, 4);\n    }\n    bringToFront() {\n        this.state.selected\n            .filter(id => id.startsWith(\"box\") && this.boxes[id])\n            .map(id => this.boxes[id])\n            .forEach((box) => {\n                box.setZIndex(getTimestamp());\n            });\n    }\n    sendToBack() {\n        this.state.selected\n            .filter(id => id.startsWith(\"box\") && this.boxes[id])\n            .map(id => this.boxes[id])\n            .forEach((box) => {\n                box.setZIndex(-getTimestamp());\n            });\n    }\n    async pasteToPatcher(clipboard: RawPatcher | TMaxClipboard) {\n        const idMap: Record<string, string> = {};\n        const pasted: RawPatcher = { boxes: {}, lines: {} };\n        if (!clipboard || !clipboard.boxes) return pasted;\n        const $init: Promise<Box>[] = [];\n        const $postInit: Promise<Box>[] = [];\n        if (Array.isArray(clipboard.boxes)) { // Max Patcher\n            this.instance.state.preventEmitChanged = true;\n            const maxBoxes = clipboard.boxes;\n            for (let i = 0; i < maxBoxes.length; i++) {\n                const maxBox = maxBoxes[i].box;\n                const numID = parseInt(maxBox.id.match(/\\d+/)[0]);\n                let id = \"box-\" + numID;\n                if (this.boxes[id]) {\n                    idMap[id] = \"box-\" + ++this.props.boxIndexCount;\n                    id = idMap[id];\n                } else {\n                    idMap[id] = id;\n                    if (numID > this.props.boxIndexCount) this.props.boxIndexCount = numID;\n                }\n                const box: TBox = {\n                    id,\n                    inlets: maxBox.numinlets,\n                    outlets: maxBox.numoutlets,\n                    rect: maxBox.patching_rect,\n                    text: (maxBox.maxclass === \"newobj\" ? \"\" : maxBox.maxclass + \" \") + (maxBox.text ? maxBox.text : \"\")\n                };\n                $init.push(this.instance.createBox(box));\n            }\n            const createdBoxes = (await Promise.all($init)).filter(box => !!box);\n            createdBoxes.forEach((box) => {\n                pasted.boxes[box.id] = box.toSerializable();\n                $postInit.push(box.postInit());\n            });\n            if (Array.isArray(clipboard.lines)) {\n                const maxLines = clipboard.lines;\n                for (let i = 0; i < maxLines.length; i++) {\n                    const lineArgs = maxLines[i].patchline;\n                    const id = \"line-\" + ++this.props.lineIndexCount;\n                    const line: TLine = {\n                        id,\n                        src: [idMap[lineArgs.source[0].replace(/obj/, \"box\")], lineArgs.source[1]],\n                        dest: [idMap[lineArgs.destination[0].replace(/obj/, \"box\")], lineArgs.destination[1]]\n                    };\n                    const createdLine = this.instance.createLine(line);\n                    if (createdLine) pasted.lines[createdLine.id] = createdLine.toSerializable();\n                }\n            }\n            this.instance.state.preventEmitChanged = false;\n            if (Object.keys(pasted.boxes).length) {\n                if (this.state.selectAfterEdit) {\n                    this.deselectAll();\n                    this.select(...Object.keys(pasted.boxes));\n                }\n                this.emit(\"create\", pasted);\n                this.instance.emitGraphChanged();\n                await Promise.all($postInit);\n            }\n            return pasted;\n        }\n        if (Array.isArray(clipboard.boxes) || Array.isArray(clipboard.lines)) return pasted;\n        this.instance.state.preventEmitChanged = true;\n        for (const boxId in clipboard.boxes) {\n            const box = clipboard.boxes[boxId];\n            if (this.boxes[box.id]) {\n                idMap[box.id] = \"box-\" + ++this.props.boxIndexCount;\n                box.id = idMap[box.id];\n            } else {\n                idMap[box.id] = box.id;\n                const numID = parseInt(box.id.match(/\\d+/)[0]);\n                if (numID > this.props.boxIndexCount) this.props.boxIndexCount = numID;\n            }\n            box.rect = [box.rect[0] + 30, box.rect[1] + 30, box.rect[2], box.rect[3]];\n            $init.push(this.instance.createBox(box));\n        }\n        const createdBoxes = (await Promise.all($init)).filter(box => !!box);\n        createdBoxes.forEach((box) => {\n            pasted.boxes[box.id] = box.toSerializable();\n            $postInit.push(box.postInit());\n        });\n        await Promise.all($postInit);\n        for (const lineId in clipboard.lines) {\n            const line = clipboard.lines[lineId];\n            line.id = \"line-\" + ++this.props.lineIndexCount;\n            line.src[0] = idMap[line.src[0]];\n            line.dest[0] = idMap[line.dest[0]];\n            const createdLine = this.instance.createLine(line);\n            if (createdLine) pasted.lines[createdLine.id] = createdLine.toSerializable();\n        }\n        this.instance.state.preventEmitChanged = false;\n        if (Object.keys(pasted.boxes).length) {\n            if (this.state.selectAfterEdit) {\n                this.deselectAll();\n                this.select(...Object.keys(pasted.boxes));\n            }\n            this.emit(\"create\", pasted);\n            this.instance.emitGraphChanged();\n        }\n        return pasted;\n    }\n    async create(objects: RawPatcher) {\n        const $init: Promise<Box>[] = [];\n        const $postInit: Promise<Box>[] = [];\n        const created: RawPatcher = { boxes: {}, lines: {} };\n        for (const boxId in objects.boxes) {\n            const boxIn = objects.boxes[boxId];\n            const box = new Box(this.instance, boxIn);\n            this.boxes[box.id] = box;\n            created.boxes[box.id] = box.toSerializable();\n            $init.push(box.init());\n            $postInit.push(box.postInit());\n        }\n        await Promise.all($init);\n        await Promise.all($postInit);\n        for (const lineId in objects.lines) {\n            const lineIn = objects.lines[lineId];\n            if (!this.instance.canCreateLine(lineIn)) continue;\n            const line = new Line(this.instance, lineIn);\n            this.lines[line.id] = line;\n            created.lines[line.id] = line.toSerializable();\n            line.enable();\n        }\n        if (this.state.selectAfterEdit) {\n            this.deselectAll();\n            this.select(...Object.keys(objects.boxes));\n        }\n        this.emit(\"create\", created);\n        this.instance.emitGraphChanged();\n    }\n    async deleteSelected() {\n        const boxSet = new Set<Box>();\n        const lineSet = new Set<Line>();\n        this.state.selected.filter(id => id.startsWith(\"line\")).forEach(id => lineSet.add(this.lines[id]));\n        this.state.selected.filter(id => id.startsWith(\"box\")).forEach((id) => {\n            boxSet.add(this.boxes[id]);\n            this.boxes[id].allLines.forEach(line => lineSet.add(line));\n        });\n        if (!boxSet.size && !lineSet.size) return undefined;\n        this.state.selected = [];\n        const deleted: RawPatcher = { boxes: {}, lines: {} };\n        const promises: Promise<Box>[] = [];\n        lineSet.forEach((line) => {\n            deleted.lines[line.id] = line.toSerializable();\n            line.destroy();\n        });\n        boxSet.forEach((box) => {\n            deleted.boxes[box.id] = box.toSerializable();\n            promises.push(box.destroy());\n        });\n        await Promise.all(promises);\n        this.emit(\"selected\", this.state.selected.slice());\n        this.emit(\"delete\", deleted);\n        this.instance.emitGraphChanged();\n        return deleted;\n    }\n    async delete(objects: RawPatcher) {\n        const deleted: RawPatcher = { boxes: {}, lines: {} };\n        for (const id in objects.lines) {\n            deleted.lines[id] = this.lines[id].destroy().toSerializable();\n        }\n        const promises: Promise<Box>[] = [];\n        for (const id in objects.boxes) {\n            deleted.boxes[id] = this.boxes[id].toSerializable();\n            promises.push(this.boxes[id].destroy());\n        }\n        await Promise.all(promises);\n        this.emit(\"selected\", this.state.selected.slice());\n        this.emit(\"delete\", deleted);\n        this.instance.emitGraphChanged();\n    }\n    async cut() {\n        if (this.state.locked) return;\n        await this.copy();\n        this.deleteSelected();\n    }\n    async copy() {\n        if (this.state.locked) return;\n        const s = this.selectedToString();\n        if (!s) return;\n        await navigator.clipboard.writeText(s);\n    }\n    async paste() {\n        if (this.state.locked) return;\n        const s = await navigator.clipboard.readText();\n        if (!s) return;\n        let parsed: RawPatcher | TMaxClipboard;\n        try {\n            parsed = JSON.parse(s);\n        } catch (e) {} // eslint-disable-line no-empty\n        await this.pasteToPatcher(parsed);\n    }\n    async duplicate() {\n        if (this.state.locked) return;\n        const s = this.selectedToString();\n        if (!s) return;\n        let parsed: RawPatcher | TMaxClipboard;\n        try {\n            parsed = JSON.parse(s);\n        } catch (e) {} // eslint-disable-line no-empty\n        await this.pasteToPatcher(parsed);\n    }\n    async selectAll() {\n        this.selectAllBoxes();\n    }\n    selectRegion(selectionRect: number[], selectedBefore: string[]) {\n        let [left, top, right, bottom] = selectionRect;\n        if (left > right) [left, right] = [right, left];\n        if (top > bottom) [top, bottom] = [bottom, top];\n        const { presentation } = this.state;\n        const rectKey = presentation ? \"presentationRect\" : \"rect\";\n        const select = selectedBefore.slice();\n        for (const boxId in this.boxes) {\n            const box = this.boxes[boxId];\n            if (presentation && !box.presentation) continue;\n            const rect = box[rectKey];\n            if (!isTRect(rect)) continue;\n            const [boxLeft, boxTop, boxWidth, boxHeight] = rect;\n            const [boxRight, boxBottom] = [boxLeft + boxWidth, boxTop + boxHeight];\n            if (boxLeft < right && boxTop < bottom && boxRight > left && boxBottom > top) {\n                const i = select.indexOf(boxId);\n                if (i === -1) select.push(boxId);\n                else select.splice(i, 1);\n            }\n        }\n        const deselect = this.state.selected.filter(id => select.indexOf(id) === -1);\n        this.select(...select);\n        this.deselect(...deselect);\n    }\n    moveSelectedBox(dragOffset: { x: number; y: number }, refBoxID?: string) {\n        const { presentation, snapToGrid, selected } = this.state;\n        const rectKey = presentation ? \"presentationRect\" : \"rect\";\n        const delta = { ...dragOffset };\n        if (refBoxID) {\n            const rect = this.boxes[refBoxID][rectKey];\n            if (!isRectMovable(rect)) return { x: 0, y: 0 };\n            delta.x = snapToGrid ? Math.round((rect[0] + dragOffset.x) / this.props.grid[0]) * this.props.grid[0] - rect[0] : dragOffset.x;\n            delta.y = snapToGrid ? Math.round((rect[1] + dragOffset.y) / this.props.grid[1]) * this.props.grid[1] - rect[1] : dragOffset.y;\n        }\n        if (!delta.x && !delta.y) return dragOffset;\n        this.move(selected, delta, presentation);\n        return { x: dragOffset.x - delta.x, y: dragOffset.y - delta.y };\n    }\n    moveEnd(selected: string[], delta: { x: number; y: number }) {\n        const { presentation } = this.state;\n        const rectKey = presentation ? \"presentationRect\" : \"rect\";\n        let ids = selected.filter(id => id.startsWith(\"box\") && this.boxes[id]);\n        if (presentation) ids = ids.filter(id => isRectMovable(this.boxes[id][rectKey]));\n        const boxes = ids.map(id => this.boxes[id]);\n        boxes.forEach(box => box.emit(presentation ? \"presentationRectChanged\" : \"rectChanged\", box));\n        this.emit(\"moved\", { delta, selected: ids, presentation: this.state.presentation });\n    }\n    move(selected: string[], delta: { x: number; y: number }, presentation: boolean) {\n        if (this.state.selectAfterEdit) this.select(...selected);\n        const rectKey = presentation ? \"presentationRect\" : \"rect\";\n        let ids = selected.filter(id => id.startsWith(\"box\") && this.boxes[id]);\n        if (presentation) ids = ids.filter(id => isRectMovable(this.boxes[id][rectKey]));\n        const boxes = ids.map(id => this.boxes[id]);\n        if (boxes.length === 0) return;\n        let [left, top] = boxes[0][rectKey] as TRect;\n        for (let i = 1; i < boxes.length; i++) {\n            const box = boxes[i];\n            const [$left, $top] = box[rectKey] as TRect;\n            if ($left < left) left = $left;\n            if ($top < top) top = $top;\n        }\n        // Not allowing resize out of bound\n        delta.x = Math.max(delta.x, -left);\n        delta.y = Math.max(delta.y, -top);\n        if (delta.x) boxes.forEach(box => (box[rectKey] as TRect)[0] += delta.x);\n        if (delta.y) boxes.forEach(box => (box[rectKey] as TRect)[1] += delta.y);\n        // Emit events\n        if (!delta.x && !delta.y) return;\n        if (presentation !== this.state.presentation) return;\n        // boxes.forEach(box => box.emit(presentation ? \"presentationRectChanged\" : \"rectChanged\", box));\n        this.emit(\"moving\", { selected: ids, delta, presentation });\n        if (presentation) return;\n        const lineSet = new Set<Line>();\n        boxes.forEach((box) => {\n            box.inletLines.forEach(set => set.forEach(line => lineSet.add(line)));\n            box.outletLines.forEach(set => set.forEach(line => lineSet.add(line)));\n        });\n        lineSet.forEach(line => line.emit(\"posChanged\", line));\n    }\n    resizeSelectedBox(boxId: string, dragOffset: { x: number; y: number }, type: TResizeHandlerType) {\n        const { presentation, snapToGrid, selected } = this.state;\n        const rectKey = presentation ? \"presentationRect\" : \"rect\";\n        const rect = this.boxes[boxId][rectKey];\n        if (!isRectResizable(rect)) return { x: 0, y: 0 };\n        const delta = { x: 0, y: 0 };\n        // Round delta to grid\n        if (type === \"e\" || type === \"se\" || type === \"ne\") {\n            delta.x = snapToGrid ? Math.round((rect[0] + rect[2] + dragOffset.x) / this.props.grid[0]) * this.props.grid[0] - rect[0] - rect[2] : dragOffset.x;\n        }\n        if (type === \"s\" || type === \"se\" || type === \"sw\") {\n            delta.y = snapToGrid ? Math.round((rect[1] + rect[3] + dragOffset.y) / this.props.grid[1]) * this.props.grid[1] - rect[1] - rect[3] : dragOffset.y;\n        }\n        if (type === \"w\" || type === \"nw\" || type === \"sw\") {\n            delta.x = snapToGrid ? Math.round((rect[0] + dragOffset.x) / this.props.grid[0]) * this.props.grid[0] - rect[0] : dragOffset.x;\n        }\n        if (type === \"n\" || type === \"nw\" || type === \"ne\") {\n            delta.y = snapToGrid ? Math.round((rect[1] + dragOffset.y) / this.props.grid[1]) * this.props.grid[1] - rect[1] : dragOffset.y;\n        }\n        if (!delta.x && !delta.y) return dragOffset;\n        this.resize(selected, delta, type, presentation);\n        return { x: dragOffset.x - delta.x, y: dragOffset.y - delta.y };\n    }\n    resizeEnd(selected: string[], delta: { x: number; y: number }, type: TResizeHandlerType) {\n        const { presentation } = this.state;\n        this.emit(\"resized\", { delta, type, selected, presentation });\n    }\n    resize(selected: string[], delta: { x: number; y: number }, type: TResizeHandlerType, presentation: boolean) {\n        if (this.state.selectAfterEdit) this.select(...selected);\n        const rectKey = presentation ? \"presentationRect\" : \"rect\";\n        let ids = selected.filter(id => id.startsWith(\"box\") && this.boxes[id]);\n        if (presentation) ids = ids.filter(id => isRectResizable(this.boxes[id][rectKey]));\n        const boxes = ids.map(id => this.boxes[id]);\n        if (boxes.length === 0) return;\n        let [left, top, width, height] = boxes[0][rectKey] as TRect;\n        for (let i = 1; i < boxes.length; i++) {\n            const box = boxes[i];\n            const [$left, $top, $width, $height] = box[rectKey] as TRect;\n            if ($left < left) left = $left;\n            if ($top < top) top = $top;\n            if ($width < width) width = $width;\n            if ($height < height) height = $height;\n        }\n        // Not allowing resize out of bound\n        if (type === \"sw\" || type === \"w\" || type === \"nw\") delta.x = Math.max(delta.x, -left);\n        if (type === \"nw\" || type === \"n\" || type === \"ne\") delta.y = Math.max(delta.y, -top);\n        // Not allowing resize below 15px width or height\n        if (type === \"ne\" || type === \"e\" || type === \"se\") delta.x = Math.max(delta.x, 15 - width);\n        if (type === \"sw\" || type === \"w\" || type === \"nw\") delta.x = Math.min(delta.x, width - 15);\n        if (type === \"se\" || type === \"s\" || type === \"sw\") delta.y = Math.max(delta.y, 15 - height);\n        if (type === \"nw\" || type === \"n\" || type === \"ne\") delta.y = Math.min(delta.y, height - 15);\n        boxes.forEach((box) => {\n            const sizingX = box.UI ? box.UI?.sizing === \"horizontal\" || box.UI?.sizing === \"both\" : true;\n            const sizingY = box.UI ? box.UI?.sizing === \"vertical\" || box.UI?.sizing === \"both\" : true;\n            if (delta.x && sizingX) {\n                if (type === \"ne\" || type === \"e\" || type === \"se\") (box[rectKey] as TRect)[2] += delta.x;\n                if (type === \"sw\" || type === \"w\" || type === \"nw\") {\n                    (box[rectKey] as TRect)[2] -= delta.x;\n                    (box[rectKey] as TRect)[0] += delta.x;\n                }\n            }\n            if (delta.y && sizingY) {\n                if (type === \"se\" || type === \"s\" || type === \"sw\") (box[rectKey] as TRect)[3] += delta.y;\n                if (type === \"nw\" || type === \"n\" || type === \"ne\") {\n                    (box[rectKey] as TRect)[3] -= delta.y;\n                    (box[rectKey] as TRect)[1] += delta.y;\n                }\n            }\n        });\n        // Emit events\n        if (!delta.x && !delta.y) return;\n        if (presentation !== this.state.presentation) return;\n        boxes.forEach(box => box.emit(presentation ? \"presentationRectChanged\" : \"rectChanged\", box));\n        if (presentation) return;\n        const lineSet = new Set<Line>();\n        boxes.forEach((box) => {\n            box.inletLines.forEach(set => set.forEach(line => lineSet.add(line)));\n            box.outletLines.forEach(set => set.forEach(line => lineSet.add(line)));\n        });\n        lineSet.forEach(line => line.emit(\"posChanged\", line));\n    }\n    findNearestPort(findSrc: boolean, left: number, top: number, from: [string, number], to?: [string, number]) {\n        let nearest: [string, number] = [null, null];\n        let minDistance = 100;\n        if (to) {\n            const currentPos = this.boxes[to[0]][findSrc ? \"getOutletPos\" : \"getInletPos\"](to[1]);\n            const currentDistance = ((currentPos.left - left) ** 2 + (currentPos.top - top) ** 2) ** 0.5;\n            if (currentDistance < 100) {\n                nearest = to;\n                minDistance = currentDistance;\n            }\n        }\n        for (const id in this.boxes) {\n            const box = this.boxes[id];\n            box[findSrc ? \"outletsPositions\" : \"inletsPositions\"].forEach((pos, i) => {\n                const distance = ((pos.left - left) ** 2 + (pos.top - top) ** 2) ** 0.5;\n                if (distance < minDistance) {\n                    const canCreate = this.instance.canCreateLine({ src: findSrc ? [id, i] : from, dest: findSrc ? from : [id, i] });\n                    if (!canCreate) return;\n                    nearest = [id, i];\n                    minDistance = distance;\n                }\n            });\n        }\n        return nearest;\n    }\n    highlightNearestPort(findSrc: boolean, dragOffset: { x: number; y: number }, from: [string, number], to?: [string, number]) { // to = the port need to be reconnect\n        const origPos = to ? this.boxes[to[0]][findSrc ? \"getOutletPos\" : \"getInletPos\"](to[1]) : this.boxes[from[0]][findSrc ? \"getInletPos\" : \"getOutletPos\"](from[1]);\n        const left = origPos.left + dragOffset.x;\n        const top = origPos.top + dragOffset.y;\n        const [boxId, portIndex] = this.findNearestPort(findSrc, left, top, from, to);\n        if (boxId) this.highlightPort(boxId, findSrc, portIndex);\n        else this.unhighlightPort();\n        return [boxId, portIndex] as [string, number];\n    }\n    highlightBox(boxId: string) {\n        this.emit(\"highlightBox\", boxId);\n    }\n    highlightPort(boxId: string, isSrc: boolean, portIndex: number) {\n        this.emit(\"highlightPort\", { boxId, isSrc, i: portIndex });\n    }\n    unhighlightPort() {\n        this.emit(\"highlightPort\", null);\n    }\n    tempLine(findSrc: boolean, from: [string, number]) {\n        this.emit(\"tempLine\", { findSrc, from });\n        return this;\n    }\n    inspector(box?: Box) {\n        if (box) this.emit(\"inspector\");\n        else if (this.state.selected.length) {\n            const found = this.state.selected.find(id => id.startsWith(\"box\"));\n            if (found && this.boxes[found]) this.emit(\"inspector\");\n        }\n    }\n    dockUI(box?: Box) {\n        if (box && box.UI.dockable) this.emit(\"dockUI\", box.id);\n        else if (this.state.selected.length) {\n            const found = this.state.selected.find(id => id.startsWith(\"box\"));\n            if (found && this.boxes[found] && this.boxes[found].UI.dockable) this.emit(\"dockUI\", found);\n        }\n    }\n    onUiResized() {}\n    async toTempData() {\n        return this.instance.toSerializable();\n    }\n}\n","import History, { IHistoryEvent } from \"../file/History\";\nimport PatcherEditor, { PatcherHistoryEventMap } from \"./PatcherEditor\";\n\nexport default class PatcherHistory extends History<PatcherHistoryEventMap, PatcherEditor> {\n    get eventListening(): (keyof PatcherHistoryEventMap)[] {\n        return [\n            \"create\", \"delete\", \"changeBoxText\", \"boxChanged\",\n            \"changeLineSrc\", \"changeLineDest\", \"moved\", \"resized\", \"propsChanged\"\n        ];\n    }\n    async undoOf(editor: PatcherEditor, eventName: keyof PatcherHistoryEventMap, eventData?: any) {\n        if (eventName === \"delete\") {\n            const e: PatcherHistoryEventMap[typeof eventName] = eventData;\n            await editor.create(e);\n        } else if (eventName === \"changeBoxText\") {\n            const e: PatcherHistoryEventMap[typeof eventName] = eventData;\n            const { boxId, oldText } = e;\n            await editor.instance.changeBoxText(boxId, oldText);\n        } else if (eventName === \"boxChanged\") {\n            const e: PatcherHistoryEventMap[typeof eventName] = eventData;\n            const { boxId, oldArgs, oldProps, oldState, oldZIndex } = e;\n            await editor.changeBox(boxId, { args: oldArgs, props: oldProps, state: oldState, zIndex: oldZIndex });\n        } else if (eventName === \"moved\") {\n            const e: PatcherHistoryEventMap[typeof eventName] = eventData;\n            const { selected, delta, presentation } = e;\n            const d = { x: -1 * delta.x, y: -1 * delta.y };\n            editor.move(selected, d, presentation);\n            editor.moveEnd(selected, d);\n        } else if (eventName === \"changeLineSrc\") {\n            const e: PatcherHistoryEventMap[typeof eventName] = eventData;\n            const { lineId, oldSrc } = e;\n            editor.changeLineSrc(lineId, oldSrc[0], oldSrc[1]);\n        } else if (eventName === \"changeLineDest\") {\n            const e: PatcherHistoryEventMap[typeof eventName] = eventData;\n            const { lineId, oldDest } = e;\n            editor.changeLineDest(lineId, oldDest[0], oldDest[1]);\n        } else if (eventName === \"create\") {\n            const e: PatcherHistoryEventMap[typeof eventName] = eventData;\n            await editor.delete(e);\n        } else if (eventName === \"resized\") {\n            const e: PatcherHistoryEventMap[typeof eventName] = eventData;\n            const { selected, delta, type: t, presentation } = e;\n            const d = { x: -1 * delta.x, y: -1 * delta.y };\n            editor.resize(selected, d, t, presentation);\n            editor.resizeEnd(selected, d, t);\n        } else if (eventName === \"propsChanged\") {\n            const e: PatcherHistoryEventMap[typeof eventName] = eventData;\n            editor.instance.setProps(e.oldProps);\n        }\n    }\n    async redoOf(editor: PatcherEditor, eventName: keyof PatcherHistoryEventMap, eventData?: any) {\n        if (eventName === \"create\") {\n            const e: PatcherHistoryEventMap[typeof eventName] = eventData;\n            await editor.create(e);\n        } else if (eventName === \"changeBoxText\") {\n            const e: PatcherHistoryEventMap[typeof eventName] = eventData;\n            const { boxId, text } = e;\n            await editor.instance.changeBoxText(boxId, text);\n        } else if (eventName === \"boxChanged\") {\n            const e: PatcherHistoryEventMap[typeof eventName] = eventData;\n            const { boxId, args, props, state, zIndex } = e;\n            await editor.changeBox(boxId, { args, props, state, zIndex });\n        } else if (eventName === \"moved\") {\n            const e: PatcherHistoryEventMap[typeof eventName] = eventData;\n            const { selected, delta, presentation } = e;\n            editor.move(selected, delta, presentation);\n            editor.moveEnd(selected, delta);\n        } else if (eventName === \"changeLineSrc\") {\n            const e: PatcherHistoryEventMap[typeof eventName] = eventData;\n            const { lineId, src } = e;\n            editor.changeLineSrc(lineId, src[0], src[1]);\n        } else if (eventName === \"changeLineDest\") {\n            const e: PatcherHistoryEventMap[typeof eventName] = eventData;\n            const { lineId, dest } = e;\n            editor.changeLineDest(lineId, dest[0], dest[1]);\n        } else if (eventName === \"delete\") {\n            const e: PatcherHistoryEventMap[typeof eventName] = eventData;\n            await editor.delete(e);\n        } else if (eventName === \"resized\") {\n            const e: PatcherHistoryEventMap[typeof eventName] = eventData;\n            const { selected, delta, type: t, presentation } = e;\n            editor.resize(selected, delta, t, presentation);\n            editor.resizeEnd(selected, delta, t);\n        } else if (eventName === \"propsChanged\") {\n            const e: PatcherHistoryEventMap[typeof eventName] = eventData;\n            editor.instance.setProps(e.props);\n        }\n    }\n    async mergeChanges(...events: IHistoryEvent<PatcherHistoryEventMap>[]) {\n        this.editors.forEach(e => e.state.selectAfterEdit = false);\n        const merged = await super.mergeChanges(...events);\n        this.editors.forEach(e => e.state.selectAfterEdit = true);\n        return merged;\n    }\n}\n","import TemporaryProjectFile from \"../file/TemporaryProjectFile\";\nimport type { RawPatcher } from \"../types\";\nimport type { IJSPatcherEnv } from \"../Env\";\nimport type { IProject } from \"../Project\";\n\nexport default class TempPatcherFile extends TemporaryProjectFile<RawPatcher> {\n    get type() {\n        return \"patcher\" as const;\n    }\n    async instantiate({ env, project, instanceId }: { env: IJSPatcherEnv; project?: IProject; instanceId?: string }) {\n        const Patcher = (await import(\"./Patcher\")).default;\n        const patcher = new Patcher({ file: this, env, project, instanceId });\n        await patcher.load(this.data);\n        return patcher;\n    }\n    async instantiateEditor({ env, project, instanceId }: { env: IJSPatcherEnv; project?: IProject; instanceId?: string }) {\n        const PatcherEditor = (await import(\"./PatcherEditor\")).default;\n        return PatcherEditor.fromProjectItem({ file: this, env, project, instanceId });\n    }\n}\n","import TemporaryProjectFile from \"../file/TemporaryProjectFile\";\nimport type PatcherText from \"./PatcherText\";\nimport type { IJSPatcherEnv } from \"../Env\";\nimport type { IProject } from \"../Project\";\n\nexport default class TempTextFile extends TemporaryProjectFile<PatcherText> {\n    get type() {\n        return \"text\" as const;\n    }\n    async instantiate() {\n        return this.data;\n    }\n    async instantiateEditor({ env, project, instanceId }: { env: IJSPatcherEnv; project?: IProject; instanceId?: string }) {\n        const TextEditor = (await import(\"./TextEditor\")).default;\n        return TextEditor.fromProjectItem({ file: this, env, project, instanceId });\n    }\n}\n","import { AudioWorkletGlobalScope, MessagePortRequest, MessagePortResponse, TypedMessageEvent } from \"./TypedAudioWorklet\";\nimport { AudioWorkletProxyProcessor } from \"./AudioWorkletProxyProcessor.types\";\n\ndeclare const globalThis: AudioWorkletGlobalScope;\nconst { AudioWorkletProcessor } = globalThis;\n\nconst Processor = class AudioWorkletProxyProcessor extends AudioWorkletProcessor {\n    static fnNames: string[] = [];\n    _disposed = false;\n    constructor(options: AudioWorkletNodeOptions) {\n        super(options);\n        const resolves: Record<number, ((...args: any[]) => any)> = {};\n        const rejects: Record<number, ((...args: any[]) => any)> = {};\n        let messagePortRequestId = -1;\n        const handleDisposed = () => {\n            this.port.removeEventListener(\"message\", handleMessage);\n            this.port.close();\n        };\n        const handleMessage = async (e: TypedMessageEvent<MessagePortResponse & MessagePortRequest>) => {\n            const { id, call, args, value, error } = e.data;\n            if (call) {\n                const r: MessagePortResponse = { id };\n                try {\n                    r.value = await (this as any)[call](...args);\n                } catch (e) {\n                    r.error = e;\n                }\n                this.port.postMessage(r as any);\n                if (this._disposed) handleDisposed();\n            } else {\n                if (error) rejects[id]?.(error);\n                else if (resolves[id]) resolves[id]?.(value);\n                delete resolves[id];\n                delete rejects[id];\n            }\n        };\n        const call = (call: string, ...args: any[]) => new Promise<any>((resolve, reject) => {\n            const id = messagePortRequestId--;\n            resolves[id] = resolve;\n            rejects[id] = reject;\n            this.port.postMessage({ id, call, args });\n        });\n        const Ctor = (this.constructor as typeof AudioWorkletProxyProcessor);\n        Ctor.fnNames.forEach(name => (this as any)[name] = (...args: any[]) => call(name, ...args));\n        this.port.start();\n        this.port.addEventListener(\"message\", handleMessage);\n    }\n} as typeof AudioWorkletProxyProcessor;\n\nexport default Processor;\n","export const $AnyEventType = Symbol(\"__TypedEventListener_AnyEventType\");\nexport interface ITypedEventEmitter<M> extends Omit<TypedEventEmitter<M>, \"_listeners\" | \"getListeners\"> {\n}\nexport interface IEmitOptions {\n    /** if true, the emission will not trigger `onAny` listeners */\n    excludeAny?: boolean;\n    /** Exclude listeners with emit */\n    exclude?: ((...args: any[]) => any)[];\n}\nexport class TypedEventEmitter<M> {\n    private _listeners: { [eventName: string]: ((e?: any, emitter?: any) => any | Promise<any>)[]; [$AnyEventType]: ((eventName: string, eventData?: any, emitter?: any) => any | Promise<any>)[] } = { [$AnyEventType]: [] };\n    get listeners() {\n        return this._listeners;\n    }\n    private getListeners<K extends keyof M & string>(eventName: K) {\n        if (!(eventName in this._listeners)) this._listeners[eventName] = [];\n        return this._listeners[eventName];\n    }\n    on<K extends keyof M & string>(eventName: K, listener: (e: M[K], emitter?: this) => any) {\n        if (this.getListeners(eventName).indexOf(listener) === -1) this.getListeners(eventName).push(listener);\n    }\n    once<K extends keyof M & string>(eventName: K, listener: (e: M[K], emitter?: this) => any) {\n        const listenerWithOff = (arg: M[K], emitter?: this) => {\n            const returnValue = listener(arg, emitter);\n            this.off(eventName, listenerWithOff);\n            return returnValue;\n        };\n        this.on(eventName, listenerWithOff);\n    }\n    onAny<K extends keyof M & string>(listener: <KK extends K>(eventName: KK, eventData?: M[KK], emitter?: this) => any) {\n        this._listeners[$AnyEventType].push(listener);\n    }\n    off<K extends keyof M & string>(eventName: K, listener: (e: M[K], emitter?: this) => any) {\n        const i = this.getListeners(eventName).indexOf(listener);\n        if (i !== -1) this.getListeners(eventName).splice(i, 1);\n    }\n    offAny<K extends keyof M & string>(listener: <KK extends K>(eventName: KK, eventData?: M[KK], emitter?: this) => any) {\n        const i = this._listeners[$AnyEventType].indexOf(listener);\n        if (i !== -1) this._listeners[$AnyEventType].splice(i, 1);\n    }\n    async emit<K extends keyof M & string>(eventName: K, eventData?: M[K], options?: IEmitOptions) {\n        let listeners = this.getListeners(eventName);\n        let anyListeners = options?.excludeAny ? [] : this._listeners[$AnyEventType];\n        if (!listeners.length && !anyListeners.length) return [];\n        if (options?.exclude?.length) {\n            const { exclude } = options;\n            listeners = listeners.filter(l => exclude.indexOf(l) === -1);\n            anyListeners = anyListeners.filter(l => exclude.indexOf(l) === -1);\n        }\n        return Promise.all([...listeners.map(f => f(eventData, this)), ...anyListeners.map(f => f(eventName, eventData, this))]);\n    }\n    async emitSerial<K extends keyof M & string>(eventName: K, eventData?: M[K], options?: IEmitOptions) {\n        let listeners = this.getListeners(eventName);\n        let anyListeners = options?.excludeAny ? [] : this._listeners[$AnyEventType];\n        if (!listeners.length && !anyListeners.length) return [];\n        if (options?.exclude?.length) {\n            const { exclude } = options;\n            listeners = listeners.filter(l => exclude.indexOf(l) === -1);\n            anyListeners = anyListeners.filter(l => exclude.indexOf(l) === -1);\n        }\n        const returnValues = [];\n        for (let i = 0; i < listeners.length; i++) {\n            const listener = listeners[i];\n            returnValues[i] = await listener(eventData, this);\n        }\n        for (let i = 0; i < anyListeners.length; i++) {\n            const listener = anyListeners[i];\n            returnValues[listeners.length + i] = await listener(eventName, eventData, this);\n        }\n        return returnValues;\n    }\n    emitSync<K extends keyof M & string>(eventName: K, eventData?: M[K], options?: IEmitOptions) {\n        let listeners = this.getListeners(eventName);\n        let anyListeners = options?.excludeAny ? [] : this._listeners[$AnyEventType];\n        if (!listeners.length && !anyListeners.length) return [];\n        if (options?.exclude?.length) {\n            const { exclude } = options;\n            listeners = listeners.filter(l => exclude.indexOf(l) === -1);\n            anyListeners = anyListeners.filter(l => exclude.indexOf(l) === -1);\n        }\n        return [...listeners.map(f => f(eventData, this)), ...anyListeners.map(f => f(eventName, eventData, this))];\n    }\n    offAll(eventName?: keyof M & string) {\n        if (eventName) {\n            this._listeners[eventName] = [];\n        } else {\n            this._listeners = { [$AnyEventType]: [] };\n        }\n    }\n    listenerCount(eventName: keyof M & string) {\n        const anyListenerCount = this._listeners[$AnyEventType].length;\n        if (!(eventName in this._listeners)) return anyListenerCount;\n        return this._listeners[eventName].length + anyListenerCount;\n    }\n}\n\nexport default TypedEventEmitter;\n","import { mod } from \"./math\";\n\ntype TypedArray = Int8Array | Uint8Array | Int16Array | Uint16Array | Int32Array | Uint32Array | Uint8ClampedArray | Float32Array | Float64Array;\ntype TypedArrayConstructor = typeof Int8Array | typeof Uint8Array | typeof Int16Array | typeof Uint16Array | typeof Int32Array | typeof Uint32Array | typeof Uint8ClampedArray | typeof Float32Array | typeof Float64Array;\nexport const sum = (array: TypedArray | number[], from = 0, length = array.length) => {\n    let sum = 0;\n    const l = array.length;\n    for (let i = 0; i < length; i++) {\n        sum += array[(from + i) % l];\n    }\n    return sum;\n};\nexport const mean = (array: TypedArray | number[], from = 0, length = array.length) => sum(array, from, length) / length;\nexport const median = (array: TypedArray | number[], from = 0, length = array.length) => {\n    if (length === 0) throw new Error(\"trying to calculate median of empty array\");\n    const sortedArray = (from + length > array.length ? Array.isArray(array) ? array.slice(from).concat(array.slice(0, from + length - array.length)) : sliceBuffer(array, length, from) : array.slice(from, from + length)).sort();\n    if (length % 2 === 0) return (sortedArray[length / 2 - 1] + sortedArray[length / 2]) / 2;\n    return sortedArray[~~(length / 2)];\n};\nexport const maxIndex = (array: TypedArray | number[], from = 0, length = array.length) => {\n    const l = array.length;\n    if (!l) return 0;\n    let index = 0;\n    let max = array[0];\n    let i = length;\n    while (i-- > 1) {\n        const cur = array[(from + i) % l];\n        if (cur <= max) continue;\n        max = cur;\n        index = i;\n    }\n    return index;\n};\nexport const energy = (signal: TypedArray | number[], from = 0, length = signal.length) => {\n    let sum = 0;\n    let sample = 0;\n    const l = signal.length;\n    for (let i = 0; i < length; i++) {\n        sample = signal[(from + i) % l];\n        sum += sample * sample;\n    }\n    return sum;\n};\nexport const rms = (signal: TypedArray | number[], from = 0, length = signal.length) => Math.sqrt(energy(signal, from, length) / signal.length);\nexport const absMax = (signal: TypedArray | number[], from = 0, length = signal.length) => {\n    let max = 0;\n    let sample = 0;\n    const l = signal.length;\n    for (let i = 0; i < length; i++) {\n        sample = Math.abs(signal[(from + i) % l]);\n        if (sample > max) max = sample;\n    }\n    return max;\n};\nexport const zcr = (signal: TypedArray | number[], from = 0, length = signal.length) => {\n    let zcr = 0;\n    let lastPositive = true;\n    let positive = true;\n    const l = signal.length;\n    for (let i = 0; i < length; i++) {\n        positive = signal[(from + i) % l] >= 0;\n        if (positive !== lastPositive) zcr++;\n        lastPositive = positive;\n    }\n    return zcr;\n};\nexport const centroid = (array: TypedArray | number[], from = 0, length = array.length) => {\n    let weightedSum = 0;\n    let weight = 0;\n    let sample = 0;\n    const l = array.length;\n    for (let i = 0; i < length; i++) {\n        sample = array[(from + i) % l];\n        weightedSum += i * Math.abs(sample);\n        weight += sample;\n    }\n    return weight === 0 ? 0 : weightedSum / weight;\n};\nexport const conjugatedCentroid = (array: TypedArray | number[], factor: number, from = 0, length = array.length) => {\n    let weightedSum = 0;\n    let weight = 0;\n    let sample = 0;\n    const l = array.length;\n    for (let i = 0; i < length; i++) {\n        sample = array[(from + i) % l];\n        weightedSum += (i ** factor) * Math.abs(sample);\n        weight += sample;\n    }\n    return weight === 0 ? 0 : weightedSum / weight;\n};\nexport const geometricMean = (array: TypedArray | number[], from = 0, length = array.length) => {\n    let sum = 0;\n    let sample = 0;\n    const l = array.length;\n    for (let i = 0; i < length; i++) {\n        sample = array[(from + i) % l];\n        if (sample <= 0) return 0;\n        sum += Math.log(sample);\n    }\n    return Math.exp(sum / length);\n};\nexport const flatness = (array: TypedArray | number[], from = 0, length = array.length) => geometricMean(array, from, length) / mean(array, from, length);\n/**\n * https://essentia.upf.edu/reference/std_Flux.html\n */\nexport const flux = (cur: TypedArray | number[], prev: TypedArray | number[], norm?: \"L1\" | \"L2\", halfRectify?: boolean) => {\n    let flux = 0;\n    if (norm === \"L2\") {\n        if (halfRectify === true) { // L2 + halfRectify\n            for (let i = 0; i < cur.length; i++) {\n                const diff = cur[i] - prev[i];\n                if (diff < 0) continue;\n                flux += diff * diff;\n            }\n            return Math.sqrt(flux);\n        }\n        for (let i = 0; i < cur.length; i++) { // L2 not halfRectify\n            const diff = cur[i] - prev[i];\n            flux += diff * diff;\n        }\n        return Math.sqrt(flux);\n    }\n    if (halfRectify === true) { // L1 + halfRectify\n        for (let i = 0; i < cur.length; i++) {\n            const diff = cur[i] - prev[i];\n            if (diff < 0) continue;\n            flux += diff;\n        }\n        return flux;\n    }\n    for (let i = 0; i < cur.length; i++) { // L1 not halfRectify\n        const diff = cur[i] - prev[i];\n        flux += Math.abs(diff);\n    }\n    return flux;\n};\n/**\n * https://github.com/meyda/meyda/blob/master/src/extractors/spectralKurtosis.js=\n */\nexport const kurtosis = (array: TypedArray | number[], from = 0, length = array.length) => {\n    const c1 = centroid(array, from, length);\n    const c2 = conjugatedCentroid(array, 2, from, length);\n    const c3 = conjugatedCentroid(array, 3, from, length);\n    const c4 = conjugatedCentroid(array, 4, from, length);\n    const numerator = -3 * c1 ** 4 + 6 * c1 * c2 - 4 * c1 * c3 + c4;\n    const denominator = (c2 - c1 ** 2) ** 2;\n    return numerator / denominator;\n};\n/**\n * https://github.com/meyda/meyda/blob/master/src/extractors/spectralSkewness.js\n */\nexport const skewness = (array: TypedArray | number[], from = 0, length = array.length) => {\n    const c1 = centroid(array, from, length);\n    const c2 = conjugatedCentroid(array, 2, from, length);\n    const c3 = conjugatedCentroid(array, 3, from, length);\n    const numerator = 2 * c1 ** 3 - 3 * c1 * c2 + c3;\n    const denominator = (c2 - c1 ** 2) ** 1.5;\n    return numerator / denominator;\n};\n/**\n * https://essentia.upf.edu/reference/std_RollOff.html\n *\n * @param {TypedArray} array\n * @param {number} [cutoff] Between 0 - 1\n * @returns\n */\nexport const rolloff = (array: TypedArray | number[], from = 0, length = array.length, cutoff?: number) => {\n    let e = energy(array, from, length);\n    const threshold = (cutoff || 0.99) * e;\n    let n = length - 1;\n    let element;\n    while (e > threshold && n >= 0) {\n        element = array[(n + from) % length];\n        e -= element * element;\n        --n;\n    }\n    return n + 1;\n};\nexport const slope = (array: TypedArray | number[], from = 0, n = array.length) => {\n    const xSum = n * n / 2;\n    const x2Sum = (n - 1) * n * (2 * n - 1) / 6;\n    let ySum = 0;\n    let xySum = 0;\n    let y;\n    for (let x = 0; x < n; x++) {\n        y = array[(x + from) % n];\n        ySum += y;\n        xySum += x * y;\n    }\n    return (n * xySum - xSum * ySum) / (n * x2Sum - xSum * xSum);\n};\nexport const spread = (array: TypedArray | number[], from = 0, length = array.length) => Math.sqrt(conjugatedCentroid(array, 2, from, length)) - centroid(array, from, length) ** 2;\n/**\n * Copy buffer to another, support negative offset index\n */\nexport const setTypedArray = <T extends TypedArray = TypedArray>(to: T, from: T, offsetTo?: number, offsetFrom?: number) => {\n    const toLength = to.length;\n    const fromLength = from.length;\n    const spillLength = Math.min(toLength, fromLength);\n    let spilled = 0;\n    let $to = mod(offsetTo, toLength) || 0;\n    let $from = mod(offsetFrom, fromLength) || 0;\n    while (spilled < spillLength) {\n        const $spillLength = Math.min(spillLength - spilled, toLength - $to, fromLength - $from);\n        const $fromEnd = $from + $spillLength;\n        if ($from === 0 && $fromEnd === fromLength) to.set(from, $to);\n        else to.set(from.subarray($from, $fromEnd), $to);\n        $to = ($to + $spillLength) % toLength;\n        $from = $fromEnd % fromLength;\n        spilled += $spillLength;\n    }\n    return $to;\n};\n\nexport const getSubTypedArray = <T extends TypedArray = TypedArray>(from: T, length: number, offset = 0) => {\n    const fromLength = from.length;\n    const $ = mod(offset, fromLength) || 0;\n    if ($ === 0 && length === fromLength) return from;\n    if ($ + length < fromLength) return from.subarray($, $ + length) as T;\n    const to = new (from.constructor as TypedArrayConstructor)(length) as T;\n    setTypedArray(to, from, 0, $);\n    return to;\n};\n\nexport const sliceBuffer = <T extends TypedArray = TypedArray>(from: T, length: number, offset?: number) => {\n    const fromLength = from.length;\n    const $ = mod(offset, fromLength) || 0;\n    if ($ === 0 && length === fromLength) return from.slice();\n    if ($ + length < fromLength) return from.slice($, $ + length) as T;\n    const to = new (from.constructor as TypedArrayConstructor)(length) as T;\n    setTypedArray(to, from, 0, $);\n    return to;\n};\n/**\n * http://www.fftw.org/fftw3_doc/The-Halfcomplex_002dformat-DFT.html\n */\nexport const fftw2Amp = (from: Float32Array, windowEnergyFactor: number) => {\n    const { length } = from;\n    const amps = new Float32Array(length / 2);\n    for (let i = 0; i < length / 2; i++) {\n        const real = from[i];\n        const imag = (i === 0 || i === length / 2 - 1) ? 0 : from[length - i];\n        amps[i] = (real * real + imag * imag) ** 0.5 / length * windowEnergyFactor;\n    }\n    return amps;\n};\nexport const estimateFreq = (amps: Float32Array, sampleRate: number) => indexToFreq(maxIndex(amps), amps.length, sampleRate);\nexport const indexToFreq = (i: number, fftBins: number, sampleRate: number) => (i % fftBins) / fftBins * sampleRate / 2;\n","import { isNumberArray } from \"./utils\";\n\n/**\n * Mod support wrapping with negative numbers\n */\nexport const mod = (x: number, y: number): number => (x % y + y) % y;\n/**\n * Round a number to multiple of another\n */\nexport const round = (x: number, to: number): number => (Math.abs(to) < 1 ? Math.round(x * (1 / to)) / (1 / to) : Math.round(x / to) * to);\n/**\n * Floor a number to multiple of another\n */\nexport const floor = (x: number, to: number): number => (Math.abs(to) < 1 ? Math.floor(x * (1 / to)) / (1 / to) : Math.floor(x / to) * to);\n/**\n * Ceil a number to multiple of another\n */\nexport const ceil = (x: number, to: number): number => (Math.abs(to) < 1 ? Math.ceil(x * (1 / to)) / (1 / to) : Math.ceil(x / to) * to);\n/**\n * Degree to radian\n */\nexport const toRad = (degrees: number): number => degrees * Math.PI / 180;\n/**\n * MIDI note number to string\n */\nexport const toMIDI = (f: number): string => [\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"][(f % 12 + 12) % 12] + Math.round(f / 12 - 2);\n/**\n * Linear amplitude ([0, 1]) to dB ([-Inf, 0])\n *\n * @param {number} a linear amplitude value\n * @returns {number} dB value\n */\nexport const atodb = (a: number): number => 20 * Math.log10(a);\n/**\n * dB ([-Inf, 0]) to Linear mplitude ([0, 1])\n *\n * @param {number} db dB value\n * @returns {number} linear amplitude value\n */\nexport const dbtoa = (db: number): number => 10 ** (db / 20);\n/**\n * De-scale a exponently scaled value\n *\n * @param {number} x normalized value to scale between ([0, 1])\n * @param {number} e exponent factor used to scale, 0 means linear, 1 does ** 1.5 curve\n * @returns {number} de-scaled value\n */\nexport const iNormExp = (x: number, e: number): number => Math.max(0, x) ** (1.5 ** -e);\n/**\n * Scale exponently a normalized value\n *\n * @param {number} x normalized value to scale between ([0, 1])\n * @param {number} e exponent factor, 0 means linear, 1 does ** 1.5 curve\n * @returns {number} scaled value\n */\nexport const normExp = (x: number, e: number): number => Math.max(0, x) ** (1.5 ** e);\n\nexport const scale = (x: number, l1: number, h1: number, l2: number, h2: number) => {\n    const r1 = h1 - l1;\n    const r2 = h2 - l2;\n    return (x - l1) / r1 * r2 + l2;\n};\n\nexport const scaleClip = (x: number, l1: number, h1: number, l2: number, h2: number) => Math.max(l2, Math.min(h2, scale(x, l1, h1, l2, h2)));\n\n// eslint-disable-next-line arrow-body-style\nexport const isIdentityMatrix = (x: number[][]) => {\n    return Array.isArray(x)\n    && x.every((row, i) => isNumberArray(row)\n    && row.length === x.length\n    && row.every((e, j) => e === (j === i ? 1 : 0)));\n};\n\nexport const identityMatrix = (dim: number) => new Array(dim).fill(undefined).map((x, i) => new Array(dim).fill(undefined).map((y, j) => +(i === j)));\n","export const ImporterDirSelfObject = Symbol(\"__JSPatcher_ImporterDirSelfObject\");\nexport const ImportedStaticMethodObject = Symbol(\"__JSPatcher_ImportedStaticMethodObject\");\nexport const SharedDataNoValue = Symbol(\"__JSPatcher_ShareDataNoValue\");\nexport const TempManagerFolder = Symbol(\"__JSPatcher_TempManagerFolder\");\n","/* eslint-disable arrow-body-style */\nimport type { TPatcherProps } from \"../core/patcher/Patcher\";\nimport type { TMIDIEvent, TBPF, TRect, TPresentationRect, ProjectItemType, RawPatcher, TMaxPatcher, TAudioUnit } from \"../core/types\";\n\nexport const uuid = () => {\n    return globalThis?.crypto?.randomUUID\n        ? crypto.randomUUID()\n        : \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, (c) => {\n            const r = Math.random() * 16 | 0;\n            const v = c === \"x\" ? r : (r & 0x3 | 0x8);\n            return v.toString(16);\n        });\n};\n\nexport const getTimestamp = () => {\n    if (globalThis.performance) {\n        return performance.now() + (performance.timeOrigin || performance.timing.navigationStart);\n    }\n    return Date.now();\n};\n\nexport const isStringArray = (x: any): x is string[] => Array.isArray(x) && x.every(e => typeof e === \"string\");\nexport const isNumberArray = (x: any): x is number[] => Array.isArray(x) && x.every(e => typeof e === \"number\");\nexport const isTRect = (x: any): x is TRect => {\n    return isNumberArray(x)\n        && x.length === 4\n        && x[0] >= 0\n        && x[1] >= 0\n        && x[2] >= 15\n        && x[3] >= 15;\n};\nexport const isTPresentationRect = (x: any): x is TPresentationRect => {\n    return Array.isArray(x)\n        && x.length === 4\n        && x.every(v => typeof v === \"number\" || typeof v === \"string\");\n};\nexport const isRectMovable = (x: any): x is [number, number, number | string, number | string] => {\n    return isTPresentationRect(x) && typeof x[0] === \"number\" && typeof x[1] === \"number\";\n};\nexport const isRectResizable = (x: any): x is TRect => isTRect(x);\nexport const isMIDIEvent = (x: any): x is TMIDIEvent => (isNumberArray(x) || x instanceof Uint8Array) && x.length === 3;\nexport const stringifyError = (data: any) => {\n    if (typeof data === \"string\") return data;\n    if (data instanceof Error) return data.message;\n    if (typeof data === \"object\") return JSON.stringify(data);\n    return `${data}`;\n};\nexport const parseToPrimitive = (value: any) => {\n    try {\n        return JSON.parse(value);\n    } catch (e) {\n        return value.toString();\n    }\n};\nexport const rgbaMax2Css = (maxColor: number[]) => {\n    const cssColor = [255, 255, 255, 1] as TRect;\n    if (Array.isArray(maxColor)) {\n        for (let i = 0; i < 3; i++) {\n            if (typeof maxColor[i] === \"number\") cssColor[i] = Math.floor(maxColor[i] * 255);\n        }\n        if (typeof maxColor[3] === \"number\") cssColor[3] = maxColor[3];\n    }\n    return `rgba(${cssColor.join(\",\")})`;\n};\nexport const css2RgbaMax = (color: string) => {\n    const maxColor = [0.2, 0.2, 0.2, 1] as TRect;\n    const matched = color.match(/rgba\\((.+)\\)/);\n    if (!matched) return maxColor;\n    const cssColor = matched[1].split(\",\").map(s => +s);\n    for (let i = 0; i < 3; i++) {\n        if (typeof cssColor[i] === \"number\") maxColor[i] = cssColor[i] / 255;\n        if (typeof cssColor[3] === \"number\") maxColor[3] = cssColor[3];\n    }\n    return maxColor;\n};\nexport const chunkArray = (array: any[], perChunk: number) => {\n    return array.reduce((acc, cur, idx) => {\n        const i = ~~(idx / perChunk);\n        acc[i] = [...acc[i] || [], cur];\n        return acc;\n    }, [] as any[][]);\n};\n/**\n * A BPF can be described as a succesion of three number tuples.\n * i.e. `1 1 0.5 2 1 1` curve mode means go to 0 immediately then go to 1 in 1s with a curve of e^0.5, then go to 2 in 1s linear.\n * The function transform the string to number[][], i.e. `[[1, 1, 0.5], [2, 1, 1]]`\n *\n * @param {TBPF} sIn\n * @returns {number[][]}\n */\nexport const decodeBPF = (sIn: TBPF, tupleLength: number): number[][] => {\n    if (typeof sIn === \"number\") return [[sIn]];\n    if (isNumberArray(sIn)) return chunkArray(sIn, tupleLength);\n    if (Array.isArray(sIn) && sIn.every(a => isNumberArray(a))) return sIn;\n    if (typeof sIn !== \"string\") throw new Error(\"Failed to decode curve.\");\n    const numbers = sIn.split(\" \").filter(s => !!s).map(s => +s);\n    if (numbers.find(v => !isFinite(v))) throw new Error(\"BPF contains invalid number.\");\n    return chunkArray(numbers, tupleLength);\n};\nexport const decodeCurve = (sIn: TBPF) => decodeBPF(sIn, 3);\nexport const decodeLine = (sIn: TBPF) => decodeBPF(sIn, 2);\n\n/**\n * Gives OS name as follows:\n * \"Windows\"    for all versions of Windows,\n * \"MacOS\"      for all versions of Macintosh OS,\n * \"Linux\"      for all versions of Linux,\n * \"UNIX\"       for all other UNIX flavors,\n * \"Unknown\" indicates failure to detect the OS\n *\n * @returns {\"Windows\" | \"MacOS\" | \"UNIX\" | \"Linux\" | \"Unknown\"} OS name\n */\nexport const detectOS = (): \"Windows\" | \"MacOS\" | \"UNIX\" | \"Linux\" | \"Unknown\" => {\n    const { appVersion } = navigator;\n    if (appVersion.indexOf(\"Win\") !== -1) return \"Windows\";\n    if (appVersion.indexOf(\"Mac\") !== -1) return \"MacOS\";\n    if (appVersion.indexOf(\"X11\") !== -1) return \"UNIX\";\n    if (appVersion.indexOf(\"Linux\") !== -1) return \"Linux\";\n    return \"Unknown\";\n};\nexport const detectBrowserCore = () => {\n    if ((window as any).chrome) return \"Chromium\";\n    if ((window as any).InstallTrigger) return \"Gecko\";\n    if (navigator.vendor.indexOf(\"Apple\") !== -1) return \"WebKit\";\n    return \"Unknown\";\n};\nexport const roundedRect = (ctx: CanvasRenderingContext2D, x: number, y: number, width: number, height: number, radius: number | number[]) => {\n    const radii = [0, 0, 0, 0];\n    if (typeof radius === \"number\") radii.fill(radius);\n    else radius.forEach((v, i) => radii[i] = v);\n    ctx.beginPath();\n    ctx.moveTo(x + radii[0], y);\n    ctx.lineTo(x + width - radii[1], y);\n    ctx.quadraticCurveTo(x + width, y, x + width, y + radii[1]);\n    ctx.lineTo(x + width, y + height - radii[2]);\n    ctx.quadraticCurveTo(x + width, y + height, x + width - radii[2], y + height);\n    ctx.lineTo(x + radii[3], y + height);\n    ctx.quadraticCurveTo(x, y + height, x, y + height - radii[3]);\n    ctx.lineTo(x, y + radii[0]);\n    ctx.quadraticCurveTo(x, y, x + radii[0], y);\n    ctx.closePath();\n    ctx.stroke();\n};\nexport const fillRoundedRect = (ctx: CanvasRenderingContext2D, x: number, y: number, width: number, height: number, radius: number | number[]) => {\n    const radii = [0, 0, 0, 0];\n    if (typeof radius === \"number\") radii.fill(radius);\n    else radius.forEach((v, i) => radii[i] = v);\n    ctx.beginPath();\n    ctx.moveTo(x + radii[0], y);\n    ctx.lineTo(x + width - radii[1], y);\n    ctx.quadraticCurveTo(x + width, y, x + width, y + radii[1]);\n    ctx.lineTo(x + width, y + height - radii[2]);\n    ctx.quadraticCurveTo(x + width, y + height, x + width - radii[2], y + height);\n    ctx.lineTo(x + radii[3], y + height);\n    ctx.quadraticCurveTo(x, y + height, x, y + height - radii[3]);\n    ctx.lineTo(x, y + radii[0]);\n    ctx.quadraticCurveTo(x, y, x + radii[0], y);\n    ctx.closePath();\n    ctx.fill();\n};\nexport const selectElementRange = (e: HTMLElement) => {\n    const elementIsEditable = (e: HTMLElement): e is HTMLInputElement | HTMLTextAreaElement => !!e.nodeName.match(/^(INPUT|TEXTAREA)$/i);\n    const selection = window.getSelection();\n    if (elementIsEditable(e)) {\n        e.focus();\n        e.select();\n        return;\n    }\n    if (selection.setBaseAndExtent) {\n        // Safari\n        selection.setBaseAndExtent(e, 0, e, e.hasChildNodes() ? 1 : 0);\n        return;\n    }\n    if (selection.addRange && selection.removeAllRanges && document.createRange) {\n        // Mozilla or Opera 10.5+\n        const range = document.createRange();\n        range.selectNodeContents(e);\n        selection.removeAllRanges();\n        selection.addRange(range);\n    }\n};\nexport const selectElementPos = (e: HTMLElement, pos: number) => {\n    const range = document.createRange();\n    const selection = window.getSelection();\n    range.setStart(e.childNodes[0], pos);\n    range.collapse(true);\n    selection.removeAllRanges();\n    selection.addRange(range);\n};\nexport const findFromAscendants = (e: HTMLElement, predict: (e: HTMLElement) => boolean) => {\n    const ascendants = [];\n    let parent = e.parentElement;\n    while (parent !== document.body) {\n        ascendants.push(parent);\n        parent = parent.parentElement;\n    }\n    return ascendants.find(predict);\n};\n// eslint-disable-next-line arrow-body-style\nexport const getPropertyDescriptor = (obj: Record<string, any>, key: string): PropertyDescriptor => {\n    return Object.getOwnPropertyDescriptor(obj, key) || getPropertyDescriptor(Object.getPrototypeOf(obj), key);\n};\nexport const getPropertyDescriptors = (obj: Function | Record<string, any>): PropertyDescriptorMap => {\n    if (typeof obj === \"function\") return Object.getOwnPropertyDescriptors(obj);\n    const proto = Object.getPrototypeOf(obj);\n    if (obj !== Object.prototype && proto === Object.prototype) return Object.getOwnPropertyDescriptors(obj);\n    return Object.assign(proto ? getPropertyDescriptors(proto) : {}, Object.getOwnPropertyDescriptors(obj));\n};\n\nexport const extToType = (ext: string): Exclude<ProjectItemType, \"folder\"> => {\n    if ([\"jspat\", \"maxpat\", \"gendsp\", \"dsppat\"].indexOf(ext) !== -1) return \"patcher\";\n    if ([\"wav\", \"aif\", \"aiff\", \"mp3\", \"aac\", \"flac\", \"ogg\", \"m4a\"].indexOf(ext) !== -1) return \"audio\";\n    if ([\"txt\", \"json\"].indexOf(ext) !== -1) return \"text\";\n    if ([\"apng\", \"avif\", \"gif\", \"jpg\", \"jpeg\", \"jfif\", \"pjpeg\", \"pjp\", \"png\", \"svg\", \"webp\", \"bmp\", \"ico\", \"cur\", \"tif\", \"tiff\"].indexOf(ext) !== -1) return \"image\";\n    if ([\"mp4\", \"webm\", \"3gp\"].indexOf(ext) !== -1) return \"video\";\n    return \"unknown\";\n};\n\nexport const max2js = (patcherIn: TMaxPatcher, mode = \"max\" as TPatcherProps[\"mode\"]): RawPatcher => {\n    const patcher: RawPatcher = { boxes: {}, lines: {} };\n    const maxPatcher = (patcherIn as TMaxPatcher).patcher;\n    patcher.props = {\n        bgColor: rgbaMax2Css(maxPatcher.bgcolor),\n        editingBgColor: rgbaMax2Css(maxPatcher.editing_bgcolor),\n        dependencies: [],\n        grid: maxPatcher.gridsize,\n        openInPresentation: !!maxPatcher.openinpresentation,\n        mode\n    };\n    const maxBoxes = maxPatcher.boxes;\n    const maxLines = maxPatcher.lines;\n    for (let i = 0; i < maxBoxes.length; i++) {\n        const maxBox = maxBoxes[i].box;\n        const numID = parseInt(maxBox.id.match(/\\d+/)[0]);\n        const id = \"box-\" + numID;\n        patcher.boxes[id] = {\n            id,\n            inlets: maxBox.numinlets,\n            outlets: maxBox.numoutlets,\n            rect: maxBox.patching_rect,\n            presentationRect: maxBox.presentation_rect,\n            background: !!maxBox.background,\n            presentation: !!maxBox.presentation,\n            text: (maxBox.maxclass === \"newobj\" ? \"\" : maxBox.maxclass + \" \") + (maxBox.text ? maxBox.text : \"\")\n        };\n    }\n    for (let i = 0; i < maxLines.length; i++) {\n        const lineArgs = maxLines[i].patchline;\n        const id = \"line-\" + i;\n        patcher.lines[id] = {\n            id,\n            src: [lineArgs.source[0].replace(/obj/, \"box\"), lineArgs.source[1]],\n            dest: [lineArgs.destination[0].replace(/obj/, \"box\"), lineArgs.destination[1]]\n        };\n    }\n    return patcher;\n};\n\nexport const js2max = (patcherIn: RawPatcher): TMaxPatcher => {\n    const maxPatcher: TMaxPatcher[\"patcher\"] = {\n        boxes: [],\n        lines: [],\n        rect: undefined,\n        bgcolor: css2RgbaMax(patcherIn.props.bgColor),\n        editing_bgcolor: css2RgbaMax(patcherIn.props.editingBgColor),\n        gridsize: patcherIn.props.grid,\n        openinpresentation: +patcherIn.props.openInPresentation\n    };\n    for (const id in patcherIn.boxes) {\n        const box = patcherIn.boxes[id];\n        const numID = parseInt(id.match(/\\d+/)[0]);\n        maxPatcher.boxes.push({\n            box: {\n                id: `obj-${numID}`,\n                maxclass: \"newobj\",\n                numinlets: box.inlets,\n                numoutlets: box.outlets,\n                patching_rect: box.rect,\n                presentation: +box.presentation,\n                background: +box.background,\n                text: box.text\n            }\n        });\n    }\n    for (const id in patcherIn.lines) {\n        const line = patcherIn.lines[id];\n        maxPatcher.lines.push({\n            patchline: {\n                source: [line.src[0].replace(/box/, \"obj\"), line.src[1]],\n                destination: [line.dest[0].replace(/box/, \"obj\"), line.dest[1]]\n            }\n        });\n    }\n    return { patcher: maxPatcher };\n};\n\nexport const convertSampleToUnit = (sample: number, unit: TAudioUnit, { sampleRate = 48000, bpm = 60, beatsPerMeasure = 4, division = 16 }) => {\n    if (unit === \"sample\") return { unit, str: sample.toString(), value: sample, values: [sample] };\n    const milliseconds = sample * 1000 / sampleRate;\n    const roundedMs = Math.round(milliseconds);\n    if (unit === \"measure\") {\n        const dpms = bpm * division / 60000;\n        const totalDivisions = dpms * milliseconds;\n        const roundedTotalDivisions = dpms * milliseconds;\n        const divisions = ~~(roundedTotalDivisions % division);\n        const beats = ~~(roundedTotalDivisions / division) % beatsPerMeasure + 1;\n        const measure = ~~(roundedTotalDivisions / beatsPerMeasure / division) + 1;\n        const str = `${measure}:${beats}.${divisions.toString().padStart(2, \"0\")}`;\n        return { unit, str, value: totalDivisions / division, values: [measure, beats, divisions] };\n    }\n    // if (unit === \"time\")\n    const ms = roundedMs % 1000;\n    const s = ~~(roundedMs / 1000) % 60;\n    const min = ~~(roundedMs / 60000) % 60;\n    const h = ~~(roundedMs / 3600000);\n    const str = !min ? `${s}.${ms.toString().padStart(3, \"0\")}`\n        : !h ? `${min}:${s.toString().padStart(2, \"0\")}.${ms.toString().padStart(3, \"0\")}`\n            : `${h}:${min.toString().padStart(2, \"0\")}:${s.toString().padStart(2, \"0\")}.${ms.toString().padStart(3, \"0\")}`;\n    return { unit, str, value: milliseconds / 1000, values: [h, min, s, ms] };\n};\nexport const MEASURE_UNIT_REGEX = /^((\\d+):)?(\\d+)\\.?(\\d+)?$/;\nexport const TIME_UNIT_REGEX = /^((\\d+):)??((\\d+):)?(\\d+)\\.?(\\d+)?$/;\nexport const convertUnitToSample = (str: string, unit: TAudioUnit, { sampleRate = 48000, bpm = 60, beatsPerMeasure = 4, division = 16 }) => {\n    if (unit === \"sample\") return +str || 0;\n    if (unit === \"measure\") {\n        const matched = str.match(MEASURE_UNIT_REGEX);\n        if (!matched) throw new Error(`String ${str} cannot be parsed to ${unit}`);\n        const [, , measureIn, beatsIn, divisionsIn] = matched;\n        const bps = bpm / 60;\n        const samplesPerBeat = sampleRate / bps;\n        let measures = +measureIn || 0;\n        let beats = +beatsIn || 0;\n        let divisions = +divisionsIn || 0;\n        beats += ~~(divisions / division);\n        divisions %= division;\n        measures += ~~(beats / beatsPerMeasure);\n        beats %= beatsPerMeasure;\n        return (measures * beatsPerMeasure + beats + divisions / division) * samplesPerBeat;\n    }\n    const matched = str.match(TIME_UNIT_REGEX);\n    if (!matched) throw new Error(`String ${str} cannot be parsed to ${unit}`);\n    const [, , hIn, , minIn, sIn, msIn] = matched;\n    let h = +hIn || 0;\n    let min = +minIn || 0;\n    let s = +sIn || 0;\n    let ms = +msIn || 0;\n    s += ~~(ms / 1000);\n    ms %= 1000;\n    min += ~~(s / 60);\n    s %= 60;\n    h += ~~(min / 60);\n    min %= 60;\n    return (h * 3600 + min * 60 + s + ms / 1000) * sampleRate;\n};\n\nexport const ab2sab = (ab: SharedArrayBuffer | ArrayBuffer) => {\n    if (ab instanceof ArrayBuffer) return ab;\n    const sab = new SharedArrayBuffer(ab.byteLength);\n    const ui8ab = new Uint8Array(ab);\n    const ui8sab = new Uint8Array(sab);\n    for (let i = 0; i < ui8ab.length; i++) {\n        ui8sab[i] = ui8ab[i];\n    }\n    return sab;\n};\n\nexport const sab2ab = (sab: SharedArrayBuffer | ArrayBuffer) => {\n    if (sab instanceof SharedArrayBuffer) return sab;\n    const ab = new ArrayBuffer(sab.byteLength);\n    const ui8ab = new Uint8Array(ab);\n    const ui8sab = new Uint8Array(sab);\n    for (let i = 0; i < ui8sab.length; i++) {\n        ui8ab[i] = ui8sab[i];\n    }\n    return ab;\n};\nexport const ab2str = (buf: ArrayBuffer) => {\n    return String.fromCharCode.apply(null, new Uint16Array(buf));\n};\n\nexport const str2ab = (str: string) => {\n    const buf = new ArrayBuffer(str.length * 2); // 2 bytes for each char\n    const bufView = new Uint16Array(buf);\n    for (let i = 0, strLen = str.length; i < strLen; i++) {\n        bufView[i] = str.charCodeAt(i);\n    }\n    return buf;\n};\n\nexport const getFactors = (n: number) => {\n    const factors = [1];\n    let i = 2;\n    while (i < Math.sqrt(n)) {\n        if (n % i === 0) factors.push(i, n / i);\n        i++;\n    }\n    return factors.sort((a, b) => a - b);\n};\n\nexport const getRuler = (range: [number, number], unit: TAudioUnit, { sampleRate = 48000, bpm = 60, beatsPerMeasure = 4, division = 16 }) => {\n    const ruler: Record<number, string> = {};\n    const length = range[1] - range[0];\n    let coarse: number;\n    let refined: number;\n    if (unit === \"sample\") {\n        const steps = [1, 2, 5];\n        let mag = 1;\n        let step = 0;\n        do {\n            const grid = steps[step] * mag;\n            if (step + 1 < steps.length) {\n                step++;\n            } else {\n                step = 0;\n                mag *= 10;\n            }\n            if (!coarse && length / grid <= 10) coarse = grid;\n            if (!refined && length / grid <= 50) refined = grid;\n        } while (!coarse || !refined);\n    } else if (unit === \"measure\") {\n        const bps = bpm / 60;\n        const samplesPerBeat = sampleRate / bps;\n        const divisionFactors = getFactors(division);\n        const beatsFactors = getFactors(beatsPerMeasure);\n        const measureFactors = [1, 2, 5];\n        let actualUnit: \"division\" | \"beat\" | \"measure\" = \"division\";\n        let mag = 1;\n        let step = 0;\n        do {\n            const grid = actualUnit === \"division\"\n                ? samplesPerBeat * divisionFactors[step] / division\n                : actualUnit === \"beat\"\n                    ? samplesPerBeat * beatsFactors[step]\n                    : samplesPerBeat * measureFactors[step] * mag * beatsPerMeasure;\n            if (actualUnit === \"division\") {\n                if (step + 1 < divisionFactors.length) {\n                    step++;\n                } else {\n                    actualUnit = \"beat\";\n                    step = 0;\n                }\n            } else if (actualUnit === \"beat\") {\n                if (step + 1 < beatsFactors.length) {\n                    step++;\n                } else {\n                    actualUnit = \"measure\";\n                    step = 0;\n                }\n            } else {\n                if (step + 1 < measureFactors.length) {\n                    step++;\n                } else {\n                    step = 0;\n                    mag *= 10;\n                }\n            }\n            if (!coarse && length / grid <= 10) coarse = grid;\n            if (!refined && length / grid <= 50) refined = grid;\n        } while (!coarse || !refined);\n    } else {\n        const msFactors = [1, 2, 5, 10, 20, 50, 100, 200, 500];\n        const sFactors = getFactors(60);\n        const minFactors = sFactors;\n        const hFactors = [1, 2, 5];\n        let actualUnit: \"ms\" | \"s\" | \"min\" | \"h\" = \"ms\";\n        let mag = 1;\n        let step = 0;\n        do {\n            const grid = actualUnit === \"ms\"\n                ? sampleRate * msFactors[step] / 1000\n                : actualUnit === \"s\"\n                    ? sampleRate * sFactors[step]\n                    : actualUnit === \"min\"\n                        ? sampleRate * minFactors[step] * 60\n                        : sampleRate * hFactors[step] * mag * 60;\n            if (actualUnit === \"ms\") {\n                if (step + 1 < msFactors.length) {\n                    step++;\n                } else {\n                    actualUnit = \"s\";\n                    step = 0;\n                }\n            } else if (actualUnit === \"s\") {\n                if (step + 1 < sFactors.length) {\n                    step++;\n                } else {\n                    actualUnit = \"min\";\n                    step = 0;\n                }\n            } else if (actualUnit === \"min\") {\n                if (step + 1 < minFactors.length) {\n                    step++;\n                } else {\n                    actualUnit = \"h\";\n                    step = 0;\n                }\n            } else {\n                if (step + 1 < hFactors.length) {\n                    step++;\n                } else {\n                    step = 0;\n                    mag *= 10;\n                }\n            }\n            if (!coarse && length / grid <= 10) coarse = grid;\n            if (!refined && length / grid <= 50) refined = grid;\n        } while (!coarse || !refined);\n    }\n    let m = ~~(range[0] / refined);\n    if (m * refined < range[0]) m++;\n    while (m * refined < range[1]) {\n        const t = m * refined;\n        if (t && t % coarse < 0.001 || coarse - t % coarse < 0.001) {\n            ruler[t] = unit === \"sample\" ? t.toString() : convertSampleToUnit(t, unit, { sampleRate, bpm, beatsPerMeasure, division }).str.replace(/\\.[0.]+$/, \"\");\n        } else {\n            ruler[t] = \"\";\n        }\n        m++;\n    }\n    return { ruler, coarse, refined };\n};\n","export default \"0.0.10.1657272645062\";\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.p = \"\";","import AudioWorkletProxyProcessor from \"./AudioWorkletProxyProcessor\";\nimport TaskManager from \"../TaskMgr\";\nimport TemporaryProjectItemManager from \"../file/TemporaryProjectItemManager\";\nimport TypedEventEmitter from \"../../utils/TypedEventEmitter\";\nimport WorkletProjectItemManager from \"../file/WorkletProjectItemManager\";\nimport WorkletGlobalPackageManager from \"../WorkletGlobalPackageManager\";\nimport Project from \"../Project\";\nimport JSPatcherWorkletSDK from \"../WorkletSDK\";\nimport type { WorkletEnvParameters, IWorkletEnvNode, IWorkletEnvProcessor, WorkletEnvOptions } from \"./WorkletEnv.types\";\nimport type { AudioWorkletGlobalScope, TypedAudioWorkletNodeOptions } from \"./TypedAudioWorklet\";\nimport type { Task, TaskError } from \"../TaskMgr\";\nimport type { EnvEventMap, IJSPatcherEnv } from \"../Env\";\nimport type { IFileEditor } from \"../file/FileEditor\";\nimport type { IFileInstance } from \"../file/FileInstance\";\nimport type { ProjectItemManagerDataForDiff } from \"../file/PersistentProjectItemManager\";\nimport type { TErrorLevel } from \"../types\";\nimport type { IExternalPackage } from \"../GlobalPackageManager\";\nimport type GlobalTransportProcessor from \"./GlobalTransportProcessor.worklet\";\n\nexport const processorId = \"__JSPatcher_WorkletEnv\";\ndeclare const globalThis: AudioWorkletGlobalScope;\nconst { registerProcessor } = globalThis;\n\nexport default class WorkletEnvProcessor extends AudioWorkletProxyProcessor<IWorkletEnvProcessor, IWorkletEnvNode, WorkletEnvParameters, WorkletEnvOptions> implements IWorkletEnvProcessor, IJSPatcherEnv {\n    static fnNames: (keyof IWorkletEnvNode)[] = [\"envNewLog\", \"taskBegin\", \"taskUpdate\", \"taskError\", \"taskEnd\", \"fileMgrExists\", \"fileMgrGetFileDetails\", \"fileMgrPutFile\", \"fileMgrReadDir\", \"fileMgrReadFile\", \"fileMgrWriteFile\", \"fileMgrGetPathIdMap\", \"fileMgrDiff\", \"addObjects\", \"addWorkletModule\"];\n    private readonly ee = new TypedEventEmitter<EnvEventMap>();\n    readonly thread = \"AudioWorklet\";\n    readonly os: \"Windows\" | \"MacOS\" | \"UNIX\" | \"Linux\" | \"Unknown\";\n    readonly browser: \"Unknown\" | \"Chromium\" | \"Gecko\" | \"WebKit\";\n    readonly generatedId: Uint32Array;\n    readonly taskMgr = new TaskManager();\n    readonly fileMgr: WorkletProjectItemManager;\n    readonly tempMgr: TemporaryProjectItemManager;\n    readonly pkgMgr: WorkletGlobalPackageManager;\n    readonly sdk = new JSPatcherWorkletSDK();\n    readonly username = \"\";\n    readonly autoSave = true;\n    currentProject: Project;\n    globalTransport: GlobalTransportProcessor;\n    constructor(options?: TypedAudioWorkletNodeOptions<WorkletEnvOptions>) {\n        super(options);\n        globalThis.jspatcherEnv = this;\n        const { os, browser, generatedId } = options.processorOptions;\n        this.os = os;\n        this.browser = browser;\n        this.generatedId = generatedId;\n        this.fileMgr = new WorkletProjectItemManager(this);\n        this.tempMgr = new TemporaryProjectItemManager(this);\n        this.pkgMgr = new WorkletGlobalPackageManager(this);\n    }\n    async init() {\n        await this.pkgMgr.init();\n        this.currentProject = new Project(this);\n        await this.fileMgr.init();\n        await this.tempMgr.init();\n        this.bindTaskMgr();\n        this.bindFileMgr();\n    }\n    instances = new Set<IFileInstance>();\n    activeInstance: IFileInstance;\n    activeEditor: IFileEditor;\n    newLog(errorLevel: TErrorLevel, title: string, message: string, emitterIn?: any) {\n        const emitter = typeof emitterIn === \"string\" ? emitterIn : typeof emitterIn === \"object\" ? emitterIn.constructor.name : typeof emitterIn === \"function\" ? emitterIn.name : \"\";\n        this.envNewLog(errorLevel, title, message, emitter);\n    }\n    generateId(objectIn: object) {\n        return this.thread + objectIn.constructor.name + (((globalThis as any).Atomics as typeof Atomics)?.add(this.generatedId, 0, 1) ?? ++this.generatedId[0]);\n    }\n    registerInstance(i: IFileInstance, id?: string) {\n        this.instances.add(i);\n        i.on(\"destroy\", () => {\n            this.instances.delete(i);\n            this.ee.emit(\"instances\", Array.from(this.instances));\n        });\n        this.ee.emit(\"instances\", Array.from(this.instances));\n        if (!id) return this.generateId(i);\n        return id;\n    }\n    getInstanceById(id: string) {\n        for (const instance of this.instances) {\n            if (instance.id === id) return instance;\n        }\n        return null;\n    }\n    // get _listeners() { return this.ee._listeners; }\n    // get getListeners() { return this.ee.getListeners; }\n    get listeners() { return this.ee.listeners; }\n    get on() { return this.ee.on; }\n    get once() { return this.ee.once; }\n    get onAny() { return this.ee.onAny; }\n    get off() { return this.ee.off; }\n    get offAny() { return this.ee.offAny; }\n    get offAll() { return this.ee.offAll; }\n    get emit() { return this.ee.emit; }\n    get emitSerial() { return this.ee.emitSerial; }\n    get emitSync() { return this.ee.emitSync; }\n    get listenerCount() { return this.ee.listenerCount; }\n    bindTaskMgr() {\n        const handleTaskBegin = ({ id, message, emitter }: Task) => this.taskBegin({ id, message, emitter: typeof emitter === \"string\" ? emitter : emitter.constructor?.name });\n        const handleTaskUpdate = ({ id, message }: Task) => this.taskUpdate({ id, message });\n        const handleTaskError = ({ id, error }: TaskError) => this.taskError({ id, error });\n        const handleTaskEnd = ({ id }: Task) => this.taskEnd({ id });\n        this.taskMgr.on(\"taskBegin\", handleTaskBegin);\n        this.taskMgr.on(\"taskUpdate\", handleTaskUpdate);\n        this.taskMgr.on(\"taskError\", handleTaskError);\n        this.taskMgr.on(\"taskEnd\", handleTaskEnd);\n    }\n    handleFileMgrChange = () => {\n        /* SharedArrayBuffer\n        if (this.fileMgr.disabled) return;\n        this.fileMgrDiff(this.fileMgr.getDataForDiff());\n        */\n    };\n    bindFileMgr() {\n        this.fileMgr.on(\"changed\", this.handleFileMgrChange);\n    }\n    async workletFileMgrDiff(diff: ProjectItemManagerDataForDiff) {\n        this.fileMgr.off(\"changed\", this.handleFileMgrChange);\n        await this.fileMgr.processDiff(diff);\n        this.fileMgr.on(\"changed\", this.handleFileMgrChange);\n    }\n    async importPackage(url: string, pkgInfo: IExternalPackage) {\n        await this.pkgMgr.importPackage(url, pkgInfo);\n    }\n    process(inputs: Float32Array[][], outputs: Float32Array[][]) {\n        if (this._disposed) return false;\n        return true;\n    }\n}\n\ntry {\n    registerProcessor(processorId, WorkletEnvProcessor);\n} catch (error) {\n    // eslint-disable-next-line no-console\n    console.warn(error);\n}\n"],"names":[],"sourceRoot":""}