{"version":3,"file":"js/4b51cda933a2d7a9c4b7.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAC8C;AAC9C;AACkD;AACa;AAM/D,2BAA2B,yDAAW,CAAa;AAAA,EAAnD,cAVA;AAUA;AACI,0BAAiB;AAIjB,sBAAa,CAAC,SAAiB;AAC3B,WAAK,OAAO,QAAQ,EAAE;AACtB,WAAK,OAAO,QAAQ,MAAM,KAAK,OAAO,EAAE;AAAA;AAAA;AAAA,MALxC,OAAO;AACP,WAAO,KAAK,OAAO,KAAK;AAAA;AAAA;AAqBjB,yBAKL,2DAAa,CAAwC;AAAA,EAL/D,cAlCA;AAkCA;AA0BI,aAA6B,EAAE,QAAQ,QAAW,UAAU,QAAW,WAAW,QAAW,MAAM,QAAW,QAAQ,CAAC,CAAC,KAAK,IAAI,GAAG,KAAK,KAAK;AA4F9I,yBAAgB,MAAM;AACtB,0BAAiB,YAAY;AACzB,UAAI,KAAK,KAAK;AAAM,cAAM,KAAK,QAAQ,KAAK,KAAK,MAAM,KAAK,EAAE;AAAA;AAElE,4BAAmB,CAAC,SAA2B;AAC3C,UAAI,OAAO,KAAK,OAAO;AAAU,aAAK,EAAE,SAAS,CAAC,CAAC,KAAK,IAAI,GAAG,KAAK;AAAA;AAExE,uBAAc,OAAO,EAAE,MAAM,YAAgD;AACzE,UAAI,UAAU,GAAG;AACb,YAAI,kDAAM,CAAC,OAAO;AACd,cAAI,KAAK,EAAE;AAAM,iBAAK,OAAO,KAAK,UAAU,GAAG,KAAK,EAAE;AAAA,mBAC/C,OAAO,SAAS,UAAU;AACjC,eAAK,QAAQ,EAAE,MAAM;AACrB,gBAAM,KAAK,QAAQ,MAAM,KAAK,EAAE;AAAA,mBACzB,OAAO,SAAS,UAAU;AACjC,eAAK,EAAE,SAAS,KAAK,IAAI,GAAG,CAAC,CAAC;AAAA,mBACvB,yDAAW,CAAC,OAAO;AAC1B,cAAI,KAAK,EAAE;AAAW,iBAAK,EAAE,UAAU,YAAY,KAAK,IAAI,KAAK,IAAI,KAAK;AAAA,mBACnE,OAAO,SAAS,UAAU;AACjC,cAAI,KAAK,EAAE,MAAM;AACb,uBAAW,OAAO,MAAM;AACpB,kBAAI;AACA,sBAAM,MAAM,wDAAU,CAAE,KAA8B;AACtD,qBAAK,SAAS,KAAK,EAAE,KAAK,WAAW,IAAI,MAAM;AAAA,uBAC1C,GAAP;AACE,qBAAK,MAAM,EAAE;AAAA;AAAA;AAAA;AAAA;AAAA,iBAKtB,KAAK,EAAE,MAAM;AACpB,cAAM,MAAM,KAAK,sBAAsB,OAAO;AAC9C,YAAI,eAAe,YAAY;AAC3B,cAAI;AACA,kBAAM,MAAM,wDAAU,CAAC;AACvB,iBAAK,SAAS,KAAK;AAAA,mBACd,GAAP;AACE,iBAAK,MAAM,EAAE;AAAA;AAAA;AAAA;AAAA;AAK7B,yBAAgB,YAAY;AACxB,YAAM,EAAE,QAAQ,MAAM,cAAc,KAAK;AACzC,UAAI;AAAQ,eAAO;AACnB,UAAI,MAAM;AACN,aAAK;AAAA;AAET,UAAI;AAAW,cAAM,UAAU;AAAA;AAAA;AAAA,QA3I7B,cAAc,MAAc;AAC9B,UAAM,SAAS,MAAM,KAAK,IAAI;AAC9B,UAAM,YAAY,MAAM,OAAO;AAAA,MAC3B,cAAc,KAAK;AAAA,MACnB,aAAa;AAAA,MACb,QAAQ,OAAO,sBAAsB;AAAA,MACrC,QAAQ;AAAA,MACR,WAAW;AAAA;AAEf,cAAU,UAAU;AACpB,cAAU,GAAG,WAAW,CAAC,YAAoB,KAAK,OAAO,GAAG;AAE5D,UAAM,SAAS,MAAM,UAAU,eAAe;AAC9C,QAAI,WAAW,GAAG;AACd,YAAM,UAAU;AAAA,WACb;AACH,UAAI;AACA,cAAM,UAAU;AAAA,eACX,OAAP;AACE,aAAK,MAAM;AAAA;AAAA;AAGnB,UAAM,OAAO,MAAM,UAAU;AAC7B,SAAK,wBAAwB;AAE7B,WAAO,EAAE,WAAW;AAAA;AAAA,QAElB,QAAQ,MAAc;AACxB,QAAI;AACJ,QAAI;AACJ,UAAM,EAAE,MAAM,cAAc,MAAM,KAAK,cAAc;AACrD,QAAI,CAAC;AAAM,YAAM,IAAI,MAAM;AAC3B,SAAK,wBAAwB;AAC7B,UAAM,EAAE,aAAa,KAAK;AAC1B,UAAM,SAAS,MAAM,UAAU;AAC/B,UAAM,UAAU,MAAM,UAAU;AAChC,QAAI,QAAQ;AACR,eAAS,SAAS,oBAAoB;AACtC,aAAO,wBAAwB;AAC/B,aAAO,QAAQ,MAAM,GAAG;AAAA;AAE5B,QAAI,SAAS;AACT,iBAAW,SAAS,sBAAsB;AAC1C,WAAK,QAAQ,UAAU,GAAG;AAAA;AAE9B,WAAO,EAAE,QAAQ,SAAS,MAAM,UAAU,QAAQ;AAAA;AAAA,QAEhD,QAAQ,MAAc,QAAgB;AACxC,SAAK;AACL,UAAM,KAAK;AACX,QAAI;AACJ,QAAI;AACA,iBAAW,MAAM,KAAK,QAAQ;AAAA,aACzB,GAAP;AACE,WAAK,MAAO,EAAY;AACxB;AAAA;AAEJ,UAAM,EAAE,QAAQ,SAAS,QAAQ,UAAU,MAAM,cAAc;AAC/D,WAAO,OAAO,KAAK,GAAG,EAAE,QAAQ,QAAQ,UAAU,MAAM;AACxD,UAAM,OAAO,KAAK;AAClB,UAAM,iBAAiB,KAAK,OAAO;AACnC,UAAM,uBAAmC,iCAAK,iBAAL,EAAqB,MAAM;AACpE,UAAM,YAAwB,EAAE,OAAO,OAAO,MAAM,UAAU,aAAa;AAC3E,UAAM,sBAAkC,EAAE,OAAO,OAAO,MAAM,UAAU,aAAa;AACrF,UAAM,aAA0B,EAAE,MAAM,UAAU,aAAa;AAC/D,UAAM,iBAAiB,KAAK,QAAQ;AACpC,UAAM,cAAc,KAAK;AACzB,aAAS,IAAI,GAAG,IAAI,QAAQ,KAAK;AAC7B,UAAI,MAAM;AAAG,oBAAY,OAAO,KAAK,SAAS,SAAS,uBAAuB;AAAA;AACzE,oBAAY,OAAO,KAAK;AAC7B,WAAK,sBAAsB,KAAK,EAAE,MAAM,QAAQ,OAAO;AAAA;AAE3D,aAAS,IAAI,GAAG,IAAI,SAAS,KAAK;AAC9B,kBAAY,QAAQ,KAAK;AACzB,WAAK,uBAAuB,KAAK,EAAE,MAAM,UAAU,OAAO;AAAA;AAE9D,gBAAY,QAAQ,WAAW;AAC/B,UAAM,cAAwB,CAAC,GAAG,KAAK,YAAY,IAAI,CAAC,CAAC,OAAO,GAAG;AACnE,aAAS,IAAI,UAAU,GAAG,IAAK,WAAU,KAAK,YAAY,QAAQ,KAAK;AACnE,YAAM,OAAO,YAAY,IAAK,WAAU;AACxC,YAAM,QAAQ,KAAK,WAAW,IAAI;AAClC,YAAM,EAAE,cAAc,UAAU,aAAa;AAC7C,kBAAY,OAAO,KAAK,iCAAK,sBAAL,EAA0B,aAAa,GAAG,OAAO,oBAAoB,gBAAgB,iBAAiB,cAAc;AAC5I,WAAK,sBAAsB,KAAK,EAAE,MAAM;AAAA;AAE5C,SAAK,QAAQ;AACb,SAAK,SAAU,WAAU,KAAK,YAAY;AAC1C,SAAK,UAAU,UAAU;AACzB,SAAK;AACL,SAAK,OAAO,KAAK,UAAU,GAAG,KAAK,EAAE;AAAA;AAAA,EAoDzC,YAAY;AACR,UAAM;AACN,SAAK,GAAG,WAAW,KAAK;AACxB,SAAK,GAAG,YAAY,KAAK;AACzB,SAAK,GAAG,cAAc,KAAK;AAC3B,SAAK,GAAG,SAAS,KAAK;AACtB,SAAK,GAAG,WAAW,KAAK;AAAA;AAAA;AAxKrB,qBAAU;AACV,oBAAS;AACT,qBAAU;AACV,yBAAc;AACd,oBAAsB,CAAC;AAAA,EAC1B,OAAO;AAAA,EACP,MAAM;AAAA,EACN,aAAa;AAAA;AAEV,qBAAwB,CAAC;AAAA,EAC5B,MAAM;AAAA,EACN,aAAa;AAAA;AAEV,kBAAkB,CAAC;AAAA,EACtB,MAAM;AAAA,EACN,UAAU;AAAA,EACV,SAAS;AAAA,EACT,aAAa;AAAA;AAEV,gBAAuB;;;;;;;;;;;;;;;;AC3DI;AAItC,iEAAe,OAAO,QAAc;AAAA,EAChC,eAAe,mDAAU;AAAV","sources":["webpack://JSPatcher/./src/core/objects/csound/CsoundNode.ts","webpack://JSPatcher/./src/core/objects/csound/index.jspatpkg.ts"],"sourcesContent":["import type { CsoundObj } from \"@csound/browser\";\nimport CodePopupUI from \"../base/CodePopupUI\";\nimport Bang, { isBang } from \"../base/Bang\";\nimport DefaultObject from \"../base/DefaultObject\";\nimport { isMIDIEvent, decodeLine } from \"../../../utils/utils\";\nimport type DefaultUI from \"../base/DefaultUI\";\nimport type { TBPF, TMIDIEvent } from \"../../types\";\nimport type { UnPromisifiedFunction } from \"../../workers/Worker\";\nimport type { IInletMeta, IOutletMeta, IInletsMeta, IOutletsMeta, IArgsMeta } from \"../base/AbstractObject\";\n\nclass CsoundNodeUI extends CodePopupUI<CsoundNode> {\n    editorLanguage = \"plain\";\n    get code() {\n        return this.object.data.code;\n    }\n    handleSave = (code: string) => {\n        this.object.setData({ code });\n        this.object.newNode(code, this.object._.voices);\n    };\n}\nexport interface CsoundNodeData {\n    code?: string;\n}\nexport interface CsoundNodeInternalState {\n    merger: ChannelMergerNode;\n    splitter: ChannelSplitterNode;\n    csoundObj: CsoundObj;\n    node: AudioWorkletNode;\n    voices: number;\n}\ntype Args = [number];\ntype I = [Bang | number | string | TMIDIEvent | Record<string, TBPF>, ...TBPF[]];\ntype O = (null | string | AudioWorkletNode)[];\n\nexport default class CsoundNode<\n    D extends Record<string, any> & Partial<CsoundNodeData> = {},\n    S extends {} = {},\n    A extends any[] = Args,\n    U extends {} = {}\n> extends DefaultObject<D & CsoundNodeData, S, I, O, A, {}, U> {\n    static package = \"Csound\";\n    static author = \"Fr0stbyteR\";\n    static version = \"1.0.0\";\n    static description = \"Dynamically generate WebAudioNode from Csound\";\n    static inlets: IInletsMeta = [{\n        isHot: true,\n        type: \"anything\",\n        description: \"A bang to output the node, csd string to compile, number to set voices, or a param-bpf map, or a MIDI event\"\n    }];\n    static outlets: IOutletsMeta = [{\n        type: \"object\",\n        description: \"CsoundNode instance output: AudioWorkletNode | ScriptProcessor\"\n    }];\n    static args: IArgsMeta = [{\n        type: \"number\",\n        optional: true,\n        default: 0,\n        description: \"Polyphonic instrument voices count\"\n    }];\n    static UI: typeof DefaultUI = CsoundNodeUI;\n    _: CsoundNodeInternalState = { merger: undefined, splitter: undefined, csoundObj: undefined, node: undefined, voices: ~~Math.max(0, this.args[0]) };\n    async getCsoundNode(code: string) {\n        const Csound = await this.env.getCsound();\n        const csoundObj = await Csound({\n            audioContext: this.audioCtx,\n            autoConnect: false,\n            useSAB: typeof SharedArrayBuffer !== \"undefined\",\n            useSPN: false,\n            useWorker: false\n        });\n        csoundObj.setOption(\"-odac\");\n        csoundObj.on(\"message\", (message: string) => this.outlet(0, message));\n        // console.log(csoundObj);\n        const result = await csoundObj.compileCsdText(code);\n        if (result === 0) {\n            await csoundObj.start();\n        } else {\n            try {\n                await csoundObj.cleanup();\n            } catch (error) {\n                this.error(error);\n            }\n        }\n        const node = await csoundObj.getNode() as AudioWorkletNode;\n        node.channelInterpretation = \"discrete\";\n        // console.log(node);\n        return { csoundObj, node };\n    }\n    async compile(code: string) {\n        let splitter: ChannelSplitterNode;\n        let merger: ChannelMergerNode;\n        const { node, csoundObj } = await this.getCsoundNode(code);\n        if (!node) throw new Error(\"Cannot compile Csound code\");\n        node.channelInterpretation = \"discrete\";\n        const { audioCtx } = this.patcher;\n        const inlets = await csoundObj.getNchnlsInput();\n        const outlets = await csoundObj.getNchnls();\n        if (inlets) {\n            merger = audioCtx.createChannelMerger(inlets);\n            merger.channelInterpretation = \"discrete\";\n            merger.connect(node, 0, 0);\n        }\n        if (outlets) {\n            splitter = audioCtx.createChannelSplitter(outlets);\n            node.connect(splitter, 0, 0);\n        }\n        return { inlets, outlets, node, splitter, merger, csoundObj };\n    }\n    async newNode(code: string, voices: number) {\n        this.disconnectAudio();\n        await this.handleDestroy();\n        let compiled: ReturnType<UnPromisifiedFunction<CsoundNode[\"compile\"]>>;\n        try {\n            compiled = await this.compile(code);\n        } catch (e) {\n            this.error((e as Error).message);\n            return;\n        }\n        const { inlets, outlets, merger, splitter, node, csoundObj } = compiled;\n        Object.assign(this._, { voices, merger, splitter, node, csoundObj } as CsoundNodeInternalState);\n        const Ctor = this.constructor as typeof CsoundNode;\n        const firstInletMeta = Ctor.inlets[0];\n        const firstInletSignalMeta: IInletMeta = { ...firstInletMeta, type: \"signal\" };\n        const inletMeta: IInletMeta = { isHot: false, type: \"signal\", description: \"Node connection\" };\n        const audioParamInletMeta: IInletMeta = { isHot: false, type: \"signal\", description: \": bpf or node connection\" };\n        const outletMeta: IOutletMeta = { type: \"signal\", description: \"Node connection\" };\n        const lastOutletMeta = Ctor.outlets[0];\n        const factoryMeta = Ctor.meta as this[\"meta\"];\n        for (let i = 0; i < inlets; i++) {\n            if (i === 0) factoryMeta.inlets[i] = compiled.inlets ? firstInletSignalMeta : firstInletMeta;\n            else factoryMeta.inlets[i] = inletMeta;\n            this.inletAudioConnections[i] = { node: merger, index: i };\n        }\n        for (let i = 0; i < outlets; i++) {\n            factoryMeta.outlets[i] = outletMeta;\n            this.outletAudioConnections[i] = { node: splitter, index: i };\n        }\n        factoryMeta.outlets[outlets] = lastOutletMeta;\n        const audioParams: string[] = [...node.parameters].map(([k]) => k).sort();\n        for (let i = inlets || 1; i < (inlets || 1) + audioParams.length; i++) {\n            const path = audioParams[i - (inlets || 1)];\n            const param = node.parameters.get(path);\n            const { defaultValue, minValue, maxValue } = param;\n            factoryMeta.inlets[i] = { ...audioParamInletMeta, description: `${path}${audioParamInletMeta.description}: ${defaultValue} (${minValue} - ${maxValue})` };\n            this.inletAudioConnections[i] = { node: param };\n        }\n        this.setMeta(factoryMeta);\n        this.inlets = (inlets || 1) + audioParams.length;\n        this.outlets = outlets + 1;\n        this.connectAudio();\n        this.outlet(this.outlets - 1, this._.node);\n    }\n    handlePreInit = () => undefined as any;\n    handlePostInit = async () => {\n        if (this.data.code) await this.newNode(this.data.code, this._.voices);\n    };\n    handleUpdateArgs = (args: Partial<A>): void => {\n        if (typeof args[0] === \"number\") this._.voices = ~~Math.max(0, args[0]);\n    };\n    handleInlet = async ({ data, inlet }: { data: I[number]; inlet: number }) => {\n        if (inlet === 0) {\n            if (isBang(data)) {\n                if (this._.node) this.outlet(this.outlets - 1, this._.node);\n            } else if (typeof data === \"string\") {\n                this.setData({ code: data } as D);\n                await this.newNode(data, this._.voices);\n            } else if (typeof data === \"number\") {\n                this._.voices = Math.max(0, ~~data);\n            } else if (isMIDIEvent(data)) {\n                if (this._.csoundObj) this._.csoundObj.midiMessage(data[0], data[1], data[2]);\n            } else if (typeof data === \"object\") {\n                if (this._.node) {\n                    for (const key in data) {\n                        try {\n                            const bpf = decodeLine((data as Record<string, TBPF>)[key]);\n                            this.applyBPF(this._.node.parameters.get(key), bpf);\n                        } catch (e) {\n                            this.error(e.message);\n                        }\n                    }\n                }\n            }\n        } else if (this._.node) {\n            const con = this.inletAudioConnections[inlet].node;\n            if (con instanceof AudioParam) {\n                try {\n                    const bpf = decodeLine(data as TBPF);\n                    this.applyBPF(con, bpf);\n                } catch (e) {\n                    this.error(e.message);\n                }\n            }\n        }\n    };\n    handleDestroy = async () => {\n        const { merger, node, csoundObj } = this._;\n        if (merger) merger.disconnect();\n        if (node) {\n            node.disconnect();\n        }\n        if (csoundObj) await csoundObj.destroy();\n    };\n    subscribe() {\n        super.subscribe();\n        this.on(\"preInit\", this.handlePreInit);\n        this.on(\"postInit\", this.handlePostInit);\n        this.on(\"updateArgs\", this.handleUpdateArgs);\n        this.on(\"inlet\", this.handleInlet);\n        this.on(\"destroy\", this.handleDestroy);\n    }\n}\n","import CsoundNode from \"./CsoundNode\";\nimport DefaultImporter from \"../importer/DefaultImporter\";\nimport type Env from \"../../Env\";\n\nexport default async (env: Env) => ({\n    \"csoundnode~\": CsoundNode\n    // ...DefaultImporter.import(\"faust\", { ...env.Faust })\n});\n"],"names":[],"sourceRoot":""}