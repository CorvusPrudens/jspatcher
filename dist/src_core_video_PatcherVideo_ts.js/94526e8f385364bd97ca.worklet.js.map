{"version":3,"file":"src_core_video_PatcherVideo_ts.js/94526e8f385364bd97ca.worklet.js","mappings":";;;;;;;;;;;;;;;AAAgD;AACR;AAOzB,2BAA2B,0DAAY,CAA8C;AAAA,eACnF,gBAAgB,SAAuG;AAChI,WAAO,IAAI,KAAK,SAAS,KAAK,QAAQ,KAAK;AAAA;AAAA,QAGzC,YAAY;AACd,UAAM,SAAS,IAAI,oDAAW,CAAC;AAC/B,WAAO,OAAO;AAAA;AAAA,QAEZ,KAAK,MAAoB;AAC3B,QAAI;AAAM,WAAK,YAAY,IAAI,gBAAgB,MAAM,IAAI,SAAS,MAAM;AAAA;AACnE,WAAK,YAAY;AACtB,SAAK,WAAW;AAChB,SAAK,KAAK;AACV,WAAO;AAAA;AAAA,QAEL,YAAY;AACd,WAAQ,OAAM,MAAM,KAAK,YAAY;AAAA;AAAA,EAEzC,QAAQ;AACJ,UAAM,eAAe,IAAI,aAAa,EAAE,KAAK,KAAK,KAAK,SAAS,KAAK,SAAS,MAAM,KAAK;AACzF,iBAAa,YAAY,KAAK;AAC9B,WAAO;AAAA;AAAA;;;;;;;;;;;;;;;;AC7B6B;AAS7B,0BAA0B,wDAAU,CAAoC;AAAA,eACtE,gBAAgB,EAAE,MAAM,KAAK,SAAS,cAA2G;AAC1J,UAAM,QAAQ,MAAM,KAAK,YAAY,EAAE,KAAK,SAAS;AACrD,UAAM,SAAS,IAAI,KAAK;AACxB,WAAO,OAAO;AAAA;AAAA,MAGd,gBAAgB;AAChB,WAAO;AAAA;AAAA,MAEP,WAA0B;AAC1B,WAAO;AAAA;AAAA,MAEP,UAAU;AACV,WAAO,KAAK;AAAA;AAAA,QAEV,OAAO;AACT,QAAI,CAAC,KAAK,SAAS,SAAS;AACxB,YAAM,IAAI,QAAc,CAAC,SAAS,WAAW;AACzC,cAAM,cAAc,MAAM;AACtB;AACA,eAAK,SAAS,IAAI,SAAS;AAAA;AAE/B,aAAK,SAAS,GAAG,SAAS;AAAA;AAAA;AAGlC,SAAK,WAAW;AAChB,SAAK,KAAK;AACV,WAAO;AAAA;AAAA,QAEL,OAAO;AAAA;AAAA,QACP,OAAO;AAAA;AAAA,QACP,OAAO;AAAA;AAAA,QACP,MAAM;AAAA;AAAA,QACN,QAAQ;AAAA;AAAA,QACR,iBAAiB;AAAA;AAAA,QACjB,YAAY;AAAA;AAAA,EAClB,cAAc;AAAA;AAAA","sources":["webpack://JSPatcher/./src/core/video/PatcherVideo.ts","webpack://JSPatcher/./src/core/video/VideoEditor.ts"],"sourcesContent":["import FileInstance from \"../file/FileInstance\";\nimport VideoEditor from \"./VideoEditor\";\nimport type PersistentProjectFile from \"../file/PersistentProjectFile\";\nimport type { IJSPatcherEnv } from \"../Env\";\nimport type { IProject } from \"../Project\";\n\nexport interface PatcherVideoEventMap {}\n\nexport default class PatcherVideo extends FileInstance<PatcherVideoEventMap, PersistentProjectFile> {\n    static async fromProjectItem(options: { file: PersistentProjectFile; env: IJSPatcherEnv; project?: IProject; instanceId?: string }) {\n        return new this(options).init(options.file.data);\n    }\n    objectURL: string;\n    async getEditor() {\n        const editor = new VideoEditor(this);\n        return editor.init();\n    }\n    async init(data?: ArrayBuffer) {\n        if (data) this.objectURL = URL.createObjectURL(await new Response(data).blob());\n        else this.objectURL = \"\";\n        this._isReady = true;\n        this.emit(\"ready\");\n        return this;\n    }\n    async serialize() {\n        return (await fetch(this.objectURL)).arrayBuffer();\n    }\n    clone() {\n        const patcherVideo = new PatcherVideo({ env: this.env, project: this.project, file: this.file });\n        patcherVideo.objectURL = this.objectURL;\n        return patcherVideo;\n    }\n}\n","import type { SemanticICONS } from \"semantic-ui-react\";\nimport FileEditor from \"../file/FileEditor\";\nimport History from \"../file/History\";\nimport type PersistentProjectFile from \"../file/PersistentProjectFile\";\nimport type { IJSPatcherEnv } from \"../Env\";\nimport type { IProject } from \"../Project\";\nimport type PatcherVideo from \"./PatcherVideo\";\n\nexport interface VideoEditorEventMap {}\n\nexport default class VideoEditor extends FileEditor<PatcherVideo, VideoEditorEventMap> {\n    static async fromProjectItem({ file, env, project, instanceId }: { file: PersistentProjectFile; env: IJSPatcherEnv; project?: IProject; instanceId: string }) {\n        const image = await file.instantiate({ env, project, instanceId }) as PatcherVideo;\n        const editor = new this(image);\n        return editor.init();\n    }\n    readonly _history: History<Partial<VideoEditorEventMap>, this>;\n    get fileExtension() {\n        return \"mp4\";\n    }\n    get fileIcon(): SemanticICONS {\n        return \"video\";\n    }\n    get history() {\n        return this._history;\n    }\n    async init() {\n        if (!this.instance.isReady) {\n            await new Promise<void>((resolve, reject) => {\n                const handleReady = () => {\n                    resolve();\n                    this.instance.off(\"ready\", handleReady);\n                };\n                this.instance.on(\"ready\", handleReady);\n            });\n        }\n        this._isReady = true;\n        this.emit(\"ready\");\n        return this;\n    }\n    async undo() {}\n    async redo() {}\n    async copy() {}\n    async cut() {}\n    async paste() {}\n    async deleteSelected() {}\n    async selectAll() {}\n    onUiResized() {}\n}\n"],"names":[],"sourceRoot":""}