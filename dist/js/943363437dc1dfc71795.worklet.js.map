{"version":3,"file":"js/943363437dc1dfc71795.worklet.js","mappings":"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","sources":["webpack://JSPatcher/./src/core/worklets/AudioWorkletProxyProcessor.ts","webpack://JSPatcher/webpack/bootstrap","webpack://JSPatcher/webpack/runtime/define property getters","webpack://JSPatcher/webpack/runtime/hasOwnProperty shorthand","webpack://JSPatcher/webpack/runtime/make namespace object","webpack://JSPatcher/./src/core/worklets/Patcher.worklet.ts"],"sourcesContent":["import { AudioWorkletGlobalScope, MessagePortRequest, MessagePortResponse, TypedMessageEvent } from \"./TypedAudioWorklet\";\nimport { AudioWorkletProxyProcessor } from \"./AudioWorkletProxyProcessor.types\";\n\ndeclare const globalThis: AudioWorkletGlobalScope;\nconst { AudioWorkletProcessor } = globalThis;\n\nconst Processor = class extends AudioWorkletProcessor {\n    static fnNames: string[] = [];\n    _disposed = false;\n    constructor(options: AudioWorkletNodeOptions) {\n        super(options);\n        const resolves: Record<number, ((...args: any[]) => any)> = {};\n        const rejects: Record<number, ((...args: any[]) => any)> = {};\n        let messagePortRequestId = -1;\n        const handleDisposed = () => {\n            this.port.removeEventListener(\"message\", handleMessage);\n            this.port.close();\n        };\n        const handleMessage = async (e: TypedMessageEvent<MessagePortResponse & MessagePortRequest>) => {\n            const { id, call, args, value, error } = e.data;\n            if (call) {\n                const r: MessagePortResponse = { id };\n                try {\n                    r.value = await (this as any)[call](...args);\n                } catch (e) {\n                    r.error = e;\n                }\n                this.port.postMessage(r as any);\n                if (this._disposed) handleDisposed();\n            } else {\n                if (error) {\n                    if (rejects[id]) rejects[id](error);\n                    delete rejects[id];\n                    return;\n                }\n                if (resolves[id]) {\n                    resolves[id](value);\n                    delete resolves[id];\n                }\n            }\n        };\n        const call = (call: string, ...args: any[]) => new Promise<any>((resolve, reject) => {\n            const id = messagePortRequestId--;\n            resolves[id] = resolve;\n            rejects[id] = reject;\n            this.port.postMessage({ id, call, args });\n        });\n        const Ctor = (this.constructor as typeof AudioWorkletProxyProcessor);\n        Ctor.fnNames.forEach(name => (this as any)[name] = (...args: any[]) => call(name, ...args));\n        this.port.start();\n        this.port.addEventListener(\"message\", handleMessage);\n    }\n} as typeof AudioWorkletProxyProcessor;\n\nexport default Processor;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import AudioWorkletProxyProcessor from \"./AudioWorkletProxyProcessor\";\nimport type PatcherEditor from \"../patcher/PatcherEditor\";\nimport type Patcher from \"../patcher/Patcher\";\nimport type PersistentProjectFile from \"../file/PersistentProjectFile\";\nimport type { IPatcherNode, PatcherParameters, IPatcherProcessor, PatcherOptions } from \"./PatcherWorklet.types\";\nimport type { AudioWorkletGlobalScope, TypedAudioParamDescriptor, TypedAudioWorkletNodeOptions } from \"./TypedAudioWorklet\";\nimport type { IHistoryData } from \"../file/History\";\nimport type { PatcherEditorEventMap } from \"../patcher/PatcherEditor\";\nimport type { PatcherEventMap } from \"../patcher/Patcher\";\nimport type { RawPatcher } from \"../types\";\n\nconst processorId = \"__JSPatcher_Patcher\";\ndeclare const globalThis: AudioWorkletGlobalScope;\nconst { registerProcessor, jspatcherEnv } = globalThis;\n\nexport default class PatcherProcessor extends AudioWorkletProxyProcessor<IPatcherProcessor, IPatcherNode, PatcherParameters, PatcherOptions> implements IPatcherProcessor {\n    static fnNames: (keyof IPatcherNode)[] = [\"outlet\", \"objectEmitFromWorklet\"];\n    static get parameterDescriptors(): TypedAudioParamDescriptor<PatcherParameters>[] {\n        return new Array(128).fill(null).map((v, i) => ({\n            defaultValue: 0,\n            // maxValue: Number.MAX_VALUE,\n            // minValue: -Number.MAX_VALUE,\n            name: `00${i}`.slice(-3)\n        }));\n    }\n    readonly env = jspatcherEnv;\n    readonly instanceId: string;\n    readonly file: PersistentProjectFile;\n    readonly initData: RawPatcher;\n    patcher: Patcher;\n    editor: PatcherEditor;\n    constructor(options?: TypedAudioWorkletNodeOptions<PatcherOptions>) {\n        super(options);\n        const { instanceId, fileId, data } = options.processorOptions;\n        this.instanceId = instanceId;\n        this.file = this.env.fileMgr.getProjectItemFromId(fileId) as PersistentProjectFile;\n        this.initData = data;\n    }\n    async init() {\n        const Patcher = this.env.sdk.Patcher;\n        this.patcher = new Patcher({ env: this.env, file: this.file, project: this.env.currentProject, instanceId: this.instanceId });\n        this.patcher.state.patcherProcessor = this;\n        await this.patcher.init(this.initData);\n        this.patcher.on(\"dataOutput\", this.handleOutlet);\n        this.editor = await this.patcher.getEditor();\n    }\n    handleOutlet = (e: PatcherEventMap[\"dataOutput\"]) => this.outlet(e.outlet, e.data);\n    fn(data: any, port: number) {\n        this.patcher.fn(data, port);\n    }\n    sync(data: IHistoryData<PatcherEditorEventMap>) {\n        this.patcher.history.syncData(data);\n    }\n    process(inputs: Float32Array[][], outputs: Float32Array[][], parameters: Record<PatcherParameters, Float32Array>) {\n        if (this._disposed) return false;\n        if (!inputs?.[0]?.[0]?.length) return true;\n        const { parametersBoxes } = this.patcher.inspectAudioIO();\n        const handleOutput = ({ output, buffer }: PatcherEventMap[\"audioOutput\"]) => {\n            if (outputs[output]?.[0]) outputs[output][0].set(buffer);\n        };\n        this.patcher.on(\"audioOutput\", handleOutput);\n        for (let i = 0; i < inputs.length; i++) {\n            if (inputs[i]?.[0]) this.patcher.inputAudio(i, inputs[i][0]);\n        }\n        for (const key in parameters) {\n            const boxInfo = parametersBoxes[+key];\n            if (!boxInfo) continue;\n            const param = boxInfo[0];\n            this.patcher.inputParam(param, parameters[param]);\n        }\n        this.patcher.off(\"audioOutput\", handleOutput);\n        return true;\n    }\n    destroy() {\n        this.patcher.destroy();\n        this._disposed = true;\n    }\n    objectEmit(boxId: string, eventName: string, eventData: any) {\n        return this.patcher.boxes[boxId]?.object.emit(eventName as any, eventData);\n    }\n}\n\ntry {\n    registerProcessor(processorId, PatcherProcessor);\n} catch (error) {\n    // eslint-disable-next-line no-console\n    console.warn(error);\n}\n"],"names":[],"sourceRoot":""}