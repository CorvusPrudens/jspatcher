{"version":3,"file":"js/7e8729ab303b77eab8d8.js","mappings":";;;;;;;;;;;;;;;;;AAAgD;AACY;AACF;AAM1D,MAAM,cAAc;AAEL,0BAA0B,8DAAqB,CAA6F;AAAA,EAKvJ,YAAY,SAA2B,SAAmF;AACtH,UAAM,SAAS,aAAa;AAAA,MACxB,gBAAgB,QAAQ;AAAA,MACxB,iBAAiB,QAAQ;AAAA,MACzB,kBAAkB;AAAA,MAClB,uBAAuB;AAAA,MACvB,kBAAkB,EAAE,YAAY,QAAQ,YAAY,QAAQ,QAAQ,QAAQ,MAAM,QAAQ;AAAA;AAYlG,yBAAgB,MAAM;AAClB,YAAM,WAAW,KAAK,QAAQ,QAAQ;AACtC,WAAK,KAAK;AAAA;AAEd,uBAAc,CAAC,MAAoC,KAAK,GAAG,EAAE,MAAM,EAAE;AACrE,yBAAgB,MAAM,KAAK;AAfvB,SAAK,UAAU,QAAQ,IAAI,gBAAgB,QAAQ;AACnD,SAAK,QAAQ,GAAG,WAAW,KAAK;AAChC,SAAK,QAAQ,GAAG,aAAa,KAAK;AAClC,SAAK,QAAQ,GAAG,WAAW,KAAK;AAChC,UAAM,WAAW,KAAK;AACtB,SAAK,UAAU,YAAY;AACvB,YAAM,SAAS,KAAK;AACpB,WAAK,YAAY;AAAA;AAAA;AAAA,EASzB,OAAO,MAAc,MAAW;AAC5B,SAAK,QAAQ,OAAO,MAAM;AAAA;AAAA,EAE9B,sBAAsB,OAAe,WAAmB,WAAgB;AA1C5E;AA2CQ,WAAO,WAAK,QAAQ,MAAM,WAAnB,mBAA2B,OAAO,KAAK,WAAkB;AAAA;AAAA;AAhC7D,0BAAc;AACd,uBAAW,CAAC,iBAA+B,sEAA6B,CAAC,cAAc,aAAa,4DAAY;AAChH,sBAAuC,CAAC,QAAQ,MAAM,QAAQ,cAAc;;;;;;;;;;;ACbvF,iBAAiB,qBAAuB","sources":["webpack://JSPatcher/./src/core/worklets/PatcherNode.ts","webpack://JSPatcher/./src/core/worklets/Patcher.worklet.ts"],"sourcesContent":["import processorURL from \"./Patcher.worklet.ts\"; // eslint-disable-line import/extensions\nimport AudioWorkletProxyNode from \"./AudioWorkletProxyNode\";\nimport AudioWorkletRegister from \"./AudioWorkletRegister\";\nimport type Patcher from \"../patcher/Patcher\";\nimport type { PatcherEventMap } from \"../patcher/Patcher\";\nimport type { IPatcherNode, IPatcherProcessor, PatcherOptions, PatcherParameters } from \"./PatcherWorklet.types\";\nimport type { IJSPatcherEnv } from \"../Env\";\n\nconst processorId = \"__JSPatcher_Patcher\";\n\nexport default class PatcherNode extends AudioWorkletProxyNode<IPatcherNode, IPatcherProcessor, PatcherParameters, PatcherOptions> implements IPatcherNode {\n    static processorId = processorId;\n    static register = (audioWorklet: AudioWorklet) => AudioWorkletRegister.register(audioWorklet, processorId, processorURL);\n    static fnNames: (keyof IPatcherProcessor)[] = [\"init\", \"fn\", \"sync\", \"objectEmit\", \"destroy\"];\n    readonly patcher: Patcher;\n    constructor(context: BaseAudioContext, options: { env: IJSPatcherEnv; inputs: number; outputs: number } & PatcherOptions) {\n        super(context, processorId, {\n            numberOfInputs: options.inputs,\n            numberOfOutputs: options.outputs,\n            channelCountMode: \"explicit\",\n            channelInterpretation: \"discrete\",\n            processorOptions: { instanceId: options.instanceId, fileId: options.fileId, data: options.data }\n        });\n        this.patcher = options.env.getInstanceById(options.instanceId) as Patcher;\n        this.patcher.on(\"changed\", this.handleChanged);\n        this.patcher.on(\"dataInput\", this.handleInput);\n        this.patcher.on(\"destroy\", this.handleDestroy);\n        const _destroy = this.destroy;\n        this.destroy = async () => {\n            await _destroy.call(this);\n            this._disposed = true;\n        };\n    }\n    handleChanged = () => {\n        const syncData = this.patcher.history.getSyncData();\n        this.sync(syncData);\n    };\n    handleInput = (e: PatcherEventMap[\"dataInput\"]) => this.fn(e.data, e.inlet);\n    handleDestroy = () => this.destroy();\n    outlet(port: number, data: any) {\n        this.patcher.outlet(port, data);\n    }\n    objectEmitFromWorklet(boxId: string, eventName: string, eventData: any) {\n        return this.patcher.boxes[boxId]?.object.emit(eventName as any, eventData);\n    }\n}\n","module.exports = __webpack_public_path__ + \"js/1b130d9deb0c69ced1ab.worklet.js\";"],"names":[],"sourceRoot":""}