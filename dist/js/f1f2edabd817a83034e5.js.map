{"version":3,"sources":["webpack://JSPatcher/./src/core/objects/importer/Func.tsx"],"names":["FuncUI","ImportedObjectUI","Func","DefaultObject","Wrapper","outlet","imported","subscribe","on","inlets","outlets","args","patcher","activeLib","error","prototype","StaticMethod","Method","state","data","inlet","isBang","output","callback","loading","updateUI","name","c","path","length","Object","r","reduce","acc","cur","root","e","v","constructor","parent","slice","forEach","key","isHot","type","description","optional","varLength"],"mappings":"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","file":"js/f1f2edabd817a83034e5.js","sourcesContent":["import { StaticMethod } from \"./StaticMethod\";\nimport { DefaultObject, Bang, isBang } from \"../Base\";\nimport { ImportedObject, ImportedObjectUI } from \"./ImportedObject\";\nimport { TMeta } from \"../../types\";\nimport { Method } from \"./Method\";\n\nclass FuncUI extends ImportedObjectUI<Func> {\n    prependColor = \"rgb(78, 201, 176)\";\n}\ntype TAnyFunction = (...args: any[]) => any;\ntype TWrapper = typeof StaticMethod | typeof Method;\ntype S = { Wrapper: TWrapper };\nexport default class Func extends DefaultObject<{}, S, [Bang], [TAnyFunction], any[], {}, {}> {\n    static description = \"Get the function itself\";\n    static inlets: TMeta[\"inlets\"] = [{\n        isHot: true,\n        type: \"bang\",\n        description: \"Bang to get the function itself\"\n    }];\n    static outlets: TMeta[\"outlets\"] = [{\n        type: \"function\",\n        description: \"function\"\n    }];\n    static args: TMeta[\"args\"] = [{\n        type: \"string\",\n        optional: false,\n        varLength: false,\n        description: \"Function name\"\n    }];\n    static UI = FuncUI;\n    state: S = { Wrapper: null };\n    subscribe() {\n        super.subscribe();\n        this.on(\"postInit\", () => {\n            this.inlets = 1;\n            this.outlets = 1;\n        });\n        this.on(\"updateArgs\", (args) => {\n            if (typeof args[0] !== \"undefined\") {\n                const Wrapper = this.patcher.activeLib[args[0]];\n                if (!Wrapper) this.error(`Function ${args[0]} not found.`);\n                else if (Wrapper.prototype instanceof StaticMethod || Wrapper.prototype instanceof Method) {\n                    this.state.Wrapper = Wrapper as TWrapper;\n                } else {\n                    this.error(\"Given identifier function is not a function\");\n                }\n            } else {\n                this.error(\"A function identifier is needed.\");\n            }\n        });\n        this.on(\"inlet\", ({ data, inlet }) => {\n            if (inlet === 0) {\n                if (isBang(data)) this.output();\n            }\n        });\n    }\n    callback = () => this.outlet(0, this.imported);\n    output() {\n        return this.callback();\n    }\n    set loading(loading: boolean) {\n        this.updateUI({ loading });\n    }\n    get name() {\n        const c = this.state.Wrapper;\n        return c.path[c.path.length - 1];\n    }\n    get imported(): TAnyFunction {\n        const c = this.state.Wrapper || this.patcher.activeLib.Object as TWrapper;\n        let r: TAnyFunction;\n        try {\n            r = c.path.reduce((acc, cur) => acc[cur], c.root);\n        } catch (e) {\n            this.error(e);\n        }\n        return r;\n    }\n    set imported(v: TAnyFunction) {\n        const c = (this.constructor as typeof ImportedObject);\n        let parent = c.root;\n        try {\n            if (!c.path.length) {\n                c.root = v;\n            } else {\n                c.path.slice(0, -1).forEach(key => parent = parent[key]);\n                parent[c.path[c.path.length - 1]] = v;\n            }\n        } catch (e) {\n            this.error(e);\n        }\n    }\n}\n"],"sourceRoot":""}