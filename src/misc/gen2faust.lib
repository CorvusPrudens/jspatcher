import("stdfaust.lib");

neqp(a, b) = a * (a != b);
eq(a, b) = a == b;
eqp(a, b) = a * (a == b);
gt(a, b) = a > b;
gte(a, b) = a >= b;
gtep(a, b) = a * (a >= b);
gtp(a, b) = a * (a > b);
lt(a, b) = a < b;
lte(a, b) = a <= b;
ltep(a, b) = a * (a <= b);
ltp(a, b) = a * (a < b);
maximum = max;
minimum = min;
neq(a, b) = a != b;
step(a, b) = a >= b;

DEGTORAD = ma.PI / 180;
degtorad = DEGTORAD;
E = exp(1);
e = E;
f = float;
HALFPI = ma.PI * 0.5;
halfpi = HALFPI;
i = int;
INVPI = 1 / ma.PI;
invpi = INVPI;
LN10 = log(10);
ln10 = LN10;
LN2 = log(2);
ln2 = LN2;
LOG10E = log10(E);
log10e = LOG10E;
LOG2E = ma.log2(E);
log2e = LOG2E;
PHI = 1.61803398874989484820;
phi = PHI;
PI = ma.PI;
pi = PI;
RADTODEG = 180 / ma.PI;
radtodeg = RADTODEG;
SQRT1_2 = 1 / sqrt(2);
sqrt1_2 = SQRT1_2;
SQRT2 = sqrt(2);
sqrt2 = SQRT2;
TWOPI = ma.PI * 2;
twopi = TWOPI;

pass = _;

not(a) = a != 0;
and = &;
bool(a) = a != 0;
or = |;
rmod(a, b) = b % a;
rsub(a, b) = b - a;
rdiv(a, b) = b / a;
mod = fmod;
add = +;
sub = -;
div = /;

absdiff(a, b) = abs(a - b);
cartopol(x, y) = sqrt(x * x + y * y), atan2(y, x);
neg(a) = -a;
poltocar(r, t) = r * cos(t), r * sin(t);

fract(a) = a - trunc(a);
sign = ma.signum;
trunc(a) = (a > 0) * floor(a) + (a < 0) * ceil(a);

exp2(a) = 2 ^ a; 
fastexp = exp;
fastpow = pow;
ln = log;
log2 = ma.log2;

clamp(s, l, h) = s : max(l) : min(h); // different from gen implementation if l > h
clip = clamp;
fold(s, lIn, hIn) = s - l : abs : fmod(_, d * 2) : *(d != 0) : -(d) : abs : +(l) with {
    l = min(lIn, hIn);
    h = max(lIn, hIn);
    d = h - l;
};
scale(s, l0, h0, l1, h1, e) = n1 * d1 + l1 with {
    d0 = h0 - l0;
    d1 = h1 - l1;
    n0 = s - l0 : /(d0) : *(d0 != 0);
    v = (n0 > 0) | ((n0 < 0) & (fmod(e, 1) == 0));
    e1 = (v * e) + (1 - v);
    n1 = (v * n0) ^ e1;
};
wrap(s, lIn, hIn) = s - l : fmod(_, d) : +(d) : fmod(_, d) : +(l) with {
    l = min(lIn, hIn);
    h = max(lIn, hIn);
    d = h - l;
};
switch(c, t, f) = (c != 0) * t + (c == 0) * f;
gate(t, g) = ba.selectoutn(t, g - 1);
mix(a, b, c) = c * b + (1 - c) * a;
selector(t, g) = ba.selectn(t, g - 1);
smoothstep(l, h, s) = 3 * n * n - 2 * n * n * n with {
    d = h - l;
    n = s - l : /(d) : *(d != 0) : max(0) : min(1);
};

acosh = ma.acosh;
asinh = ma.asinh;
atanh = ma.atanh;
cosh = ma.cosh;
sinh = ma.sinh;
tanh = ma.tanh;
degrees(a) = a * radtodeg;
radians(a) = a * degtorad;
fastcos = cos;
fastsin = sin;
fasttan = tan;
hypot = ma.hypot;
noise = no.noise;

cycle = os.osc;
cycle_phase(p) = os.oscp(0, p);

atodb = ba.linear2db;
dbtoa = ba.db2linear;
ftom = ba.hz2midikey;
mtof = ba.midikey2hz;
mstosamp(x) = ba.sec2samp(x * 0.001);
samptoms(x) = ba.samp2sec(x) * 1000.0;

SAMPLERATE = ma.SR;
samplerate = SAMPLERATE;

fixdenorm(x) = ma.FTZ;
fixnan(x) = x, 0.0 : select2(isnan(x));

isdenorm(x) = abs(x) < ma.MIN;
isnan(x) = x != x;
isinf(x) = (x == inf) | (x == -inf) with { inf = 2.0 * ma.INFINITY; };


t60(tau) = ba.if(clipCond, 0.0, exp(-1.0 / tauCenterClipped)) with {
    clipCond = abs(tau) < ma.EPSILON;
    tauCenterClipped = ba.if(clipCond, 1.0, tau / 6.9077552789821);
};
t60time(pole) = -6.9077552789821 / log(pole);

change = sign(x - x');
dcblock = fi.zero(1) : fi.pole(0.9997);
